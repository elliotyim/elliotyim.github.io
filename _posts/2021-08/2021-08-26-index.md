---
layout: post
title: Index
description: Index
date: 2021-08-26 22:36
---

# 인덱스

![Index](/assets/images/index/Index.png)

- 인덱스는 데이터베이스에서 테이블에 대한 동작 속도를 높여주는 자료 구조를 말하며, 테이블 내의 1개 혹은 여러 개의 컬럼을 이용하여 생성할 수 있다.
- 키-필드만 갖고 있는 구조이기 때문에 저장하는 데 작은 디스크 공간만을 필요로 하는 것에 비해 보편적으로 테이블을 조회하는 속도와 성능을 크게 향상 시켜줄 수 있지만 관리하기 위해서는 추가 작업이 필요하고 잘못 사용하면 오히려 성능이 저하되는 역효과가 발생 할 수 있다.
- 인덱스는 고유 제약 조건을 실현하기 위해서도 사용된다. 고유 인덱스는 중복된 항목이 등록되는 것을 금지하기 때문에 인덱스의 대상인 테이블에서 고유성이 보장된다.
- 사용하지 않는 인덱스는 바로 바로 제거해주는 것이 좋다.
- 인덱스는 원하는 값을 빠르게 탐색 하기 위해 항상 정렬된 상태를 유지한다.

## 인덱스를 사용 하는 이유

- 인덱스는 풀 스캔에서는 아무런 의미가 없지만 WHERE 절을 사용할 때 진가를 발휘하며 일치하는 열을 빠르게 찾을 수 있다.
- join을 실행할 때 다른 테이블에서 열을 빠르게 추출할 수 있다.
- 특정하게 인덱스된 컬럼을 위한 MIN() 또는 MAX() 값을 빠르게 연산할 수 있다.

## 인덱스를 사용해야 하는 경우

- 데이터 양이 많고 검색이 변경보다 빈번한 경우
- 인덱스를 걸고자 하는 필드의 값이 다양한 값을 가지는 경우

## 인덱스의 자료구조

- 인덱스는 Hash Table 또는 B+Tree로 구현된다.

### Hash Table

![HashTable](/assets/images/index/HashTable.png)

- 해시 테이블 기반의 DB 인덱스는 컬럼의 값, 데이터의 위치를 Key, Value로 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현한다.
- 시간복잡도는 O(1)로 매우 빠른 편이다.
- 다만, 등호(=) 연산에 특화되어 있어 부등호 연산(<, >)이 자주 사용되는 데이터베이스 검색을 위해서는 적합하지 않은 자료 구조이다.

### B+Tree

![B+Tree](/assets/images/index/B+Tree.png)

- 일반적인 데이터베이스에서 많이 사용되며, 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조다.
- B+Tree는 모든 노드에 데이터를 저장했던 B-Tree와 다른 특성을 가지고 있다.
  - 리프노드만 인덱스와 함께 데이터를 가지고 있고, 나머지 노드들은 데이터를 위한 인덱스(Key)만을 갖는다.
  - 리프노드들은 LinkedList로 연결되어 있다.
  - 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.
- 데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있는데, 이러한 이유로 B-Tree의 리프노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 B-Tree를 인덱스에 맞게 최적화 하였다.
- O(logN)의 시간복잡도를 갖는다.

## 인덱스를 어떻게 설정하는가

- 인덱스는 한 테이블당 3~5개 정도가 적당하다.
- 조회 시 자주 사용하고 고유한 값 위주로 설정하는 것이 좋다.
- 컬럼을 정해서 설정하는 것이므로 후보 컬럼의 특징을 잘 파악해야 한다. 아래의 4가지 기준을 사용하면 효율적으로 인덱스를 설정할 수 있다.

### 카디널리티

- 카디널리티는 컬럼에 사용되는 값의 중복 수치를 나타내는 지표로, 중복 정도가 낮으면 카디널리티도 낮다.
- 카디널리티가 높을 수록 인덱스 설정에 좋은 컬럼이다. (한 컬럼이 갖고 있는 값의 중복 정도가 낮을 수록 좋다.)
- 예시: 학생 테이블에 학번과 이름 컬럼이 있다고 가정
  - 학번은 학생마다 부여 받으므로 10개 값 모두 고유하여 중복 정도가 낮아 카디널리티도 낮다.
  - 이름은 동명이인이 있을 수 있어 카디널리티가 높다.

### 선택도

- 선택도가 낮을 수록 인덱스 설정에 좋은 컬럼이다.
- 선택도의 계산
  - 컬럼의 특정 값의 row 수 / 테이블의 총 row 수 \* 100
  - 컬럼의 값들의 평균 row 수 / 테이블의 총 row 수 \* 100
- 예시: 학생 테이블에 학번, 이름, 성별 컬럼이 있을 때, 학번은 고유하고, 이름은 2명씩 같고, 성별은 남녀 5:5 비율로 가정
  - 학번의 선택도 = 1/10 \* 100 = 10%
    - SELECT COUNT(1) FROM '학생' WHERE '학번' = 1; (모두 고유하므로 특정 값: 1)
  - 이름의 선택도 = 2/10 \* 100 = 20%
    - SELECT COUNT(1) FROM '학생' WHERE '이름' = '김철수'; (2명씩 같으므로 특정 값: 2)
  - 성별의 선택도 = 5/10 \* 100 = 50%
    - SELECT COUNT(1) FROM '학생' WHERE '성별' = 'F'; (5명씩 같으므로 특정 값: 5)
- 즉, 선택도는 특정 필드 값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 것이다.

### 활용도

- 해당 컬럼이 실제 작업에서 얼마나 활용되는지에 대한 값으로, 활용도가 높을 수록 인덱스 설정에 좋은 컬럼이다.
- 수동 쿼리 조회, 로직과 서비스에서 쿼리를 날릴 때 WHERE 절에 자주 활용되는지를 판단하면 된다.

### 중복도

- 같은 컬럼에 대해 중복으로 인덱스를 설정하지 않는 것이 좋다.
- 인덱스에 대한 중복도가 없을 수록 인덱스 설정에 좋은 컬럼이다.

## 인덱스의 사용

---

> 기존 테이블에 인덱스를 추가하기

- ALTER TABLE 테이블명 ADD INDEX(필드명(크기));

```
mysql> ALTER TABLE temp ADD INDEX(keyword(20));
Query OK, 554604 rows affected (1.31 sec)
Records: 554604  Duplicates: 0  Warnings: 0
```

> 테이블 생성 시 인덱스를 추가하기

- CREATE TABLE 테이블명 (필드명 데이터타입(데이터크기), INDEX(필드명(크기)) ENGINE 엔진명;

```
mysql> CREATE TABLE test (
  -> keyword varchar(20),
  -> INDEX(keyword(20)))
  -> ENGINE MyISAM;
Query OK, 0 rows affected (0.11 sec)
```

> FULLTEXT 인덱스 만들기

- 일반적인 인덱스와는 달리 MySQL의 FULLTEXT는 매우 빠르게 모든 텍스트 열을 검색한다. 검색 엔진과 유사한 방법으로 자연 언어를 검색할 수 있는 특별한 인덱스로 모든 데이터 문자열의 단어를 저장하기 때문이다.
- CHAR, VARCHAR, TEXT로만 생성 가능하다.
- ALTER TABLE 테이블명 ADD FULLTEXT(필드명)

```
mysql> ALTER TABLE temp ADD FULLTEXT(keyword);
Query OK, 554604 rows affected (1.49 sec)
Records: 554604  Duplicates: 0  Warnings: 0
```

# References

- https://itrainbowm.tistory.com/20
- https://mangkyu.tistory.com/96
- https://yurimkoo.github.io/db/2020/03/14/db-index.html
