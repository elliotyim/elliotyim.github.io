<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://elliotyim.github.io/</id><title>Elliot's dev hut</title><subtitle>Slow and Steady</subtitle> <updated>2022-11-12T22:55:25+09:00</updated> <author> <name>Elliot Yim</name> <uri>https://elliotyim.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://elliotyim.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://elliotyim.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 Elliot Yim </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Leetcode - 26. Remove Duplicates from Sorted Array</title><link href="https://elliotyim.github.io/posts/remove-duplicates-from-sorted-array/" rel="alternate" type="text/html" title="Leetcode - 26. Remove Duplicates from Sorted Array" /><published>2022-11-12T22:50:00+09:00</published> <updated>2022-11-12T22:50:00+09:00</updated> <id>https://elliotyim.github.io/posts/remove-duplicates-from-sorted-array/</id> <content src="https://elliotyim.github.io/posts/remove-duplicates-from-sorted-array/" /> <author> <name>{"name"=>"Elliot Yim", "link"=>"https://github.com/elliotyim"}</name> </author> <category term="알고리즘" /> <summary> Link: https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Introduction 입력으로 받은 배열 안의 중복된 데이터를 in-place로 제거하는 문제이다. 중복된 숫자들을 제거하고 앞에서부터 숫자를 채우면 되는데, 뒤쪽에는 어떤 숫자가 위치하든 상관없고, 중복없는 숫자의 갯수 k만 반환하면 된다. Solution class Solution: def removeDuplicates(self, nums: List[int]) -&amp;gt; int: if len(nums) &amp;lt; 2: return 1 cursor = 1 for i in range(1, le... </summary> </entry> <entry><title>(WIP) Algorithm Basic - Dynamic Programming</title><link href="https://elliotyim.github.io/posts/dynamic-programming/" rel="alternate" type="text/html" title="(WIP) Algorithm Basic - Dynamic Programming" /><published>2022-06-17T19:52:00+09:00</published> <updated>2022-06-17T19:52:00+09:00</updated> <id>https://elliotyim.github.io/posts/dynamic-programming/</id> <content src="https://elliotyim.github.io/posts/dynamic-programming/" /> <author> <name>{"name"=>"Elliot Yim", "link"=>"https://github.com/elliotyim"}</name> </author> <category term="알고리즘" /> <summary> Introduction Dynamic Programming은 알고리즘 중에서도 딱 하나로 정의가 되지 않는 알고리즘이다. DP와 관련된 내용을 인터넷에서 찾아보면 대부분 어딘가에서 가져와서 돌려쓰는 내용 복붙이 많다. (피보나치 멈춰!) DP를 쓰려면 점화식을 세워야 한단다. “음 그럼 점화식은 어떻게 세우죠? 어떤 규칙이 있나요?”라는 물음에, “이런건 감이다. 익숙해져야 한다. 많이 풀다 보면 패턴이 보인다.”라고 하는 알쏭달쏭한 답만 얻을 수 있었다. (많은 경우 풀이 방법만 있고, 어떻게 그런 결론을 도출하게 되었는지의 과정에 대한 내 작은 두뇌로도 이해할 만큼의 자세한 설명이 없었다.) 감이 잘 안 옵니다 DP에 대해서 공부하면 공부할수록 저 말이 무슨 말인지 이해가 가는 한 편... </summary> </entry> <entry><title>Leetcode - Logest String Chain</title><link href="https://elliotyim.github.io/posts/longest-string-chain/" rel="alternate" type="text/html" title="Leetcode - Logest String Chain" /><published>2022-06-15T19:41:00+09:00</published> <updated>2022-06-15T19:41:00+09:00</updated> <id>https://elliotyim.github.io/posts/longest-string-chain/</id> <content src="https://elliotyim.github.io/posts/longest-string-chain/" /> <author> <name>{"name"=>"Elliot Yim", "link"=>"https://github.com/elliotyim"}</name> </author> <category term="알고리즘" /> <summary> Link: https://leetcode.com/problems/longest-string-chain/ Introduction LeetCode 오늘의 문제로 나오길래 풀어보니 이전에 이미 풀어본적 있는 문제였는데, 그 당시 정답을 보고나서도 이해를 잘 못하고 있었어서 그런지 제대로 기억이 안났다. 길이가 더 작은 단어에서 큰 단어로 찾아가면서 이전 값을 사용하는 DP 문제이다. Solution I. 문제 정의 words의 길이가 n, words에 포함된 단어의 길이가 m이라고 하면 n * m만으로도 이미 16,000이므로, O((n * m)^2)으로 풀면 시간초과가 나서 이보다는 더 적은 수행시간 내에 해결해야 한다. II. DP word chain 값을 갱신해나가야 하기 위해 각 wor... </summary> </entry> <entry><title>Leetcode - Trapping Rain Water</title><link href="https://elliotyim.github.io/posts/trapping-rain-water/" rel="alternate" type="text/html" title="Leetcode - Trapping Rain Water" /><published>2022-06-08T22:15:00+09:00</published> <updated>2022-06-15T19:42:21+09:00</updated> <id>https://elliotyim.github.io/posts/trapping-rain-water/</id> <content src="https://elliotyim.github.io/posts/trapping-rain-water/" /> <author> <name>{"name"=>"Elliot Yim", "link"=>"https://github.com/elliotyim"}</name> </author> <category term="알고리즘" /> <summary> Link: https://leetcode.com/problems/trapping-rain-water/ Introduction 그냥 우연히 펼친 파이썬 알고리즘 인터뷰 책에 전에 혼자서는 못 풀고 책에 있는 풀이의 도움을 받아 풀었던 문제가 있어서 다시 풀어보니 기억이 잘 안나서(제대로 이해를 못 했다는 뜻) 정리하게 됐다. Solution I. 문제 정의 n의 최대치가 20,000이기 때문에 O(n^2)으로 풀면 수행횟수가 4억이 되어버리기 때문에 무조건 시간초과가 난다. 따라서 그보다는 적은 시간내에 풀 수 있는 방식으로 접근해야 한다. II. 투 포인터 left와 right 두 개의 포인터를 두고 left는 오른쪽으로, right는 왼쪽으로 진행시키면서 쌓인 물의 높이를 더해나간다... </summary> </entry> <entry><title>Leetcode - Implement Trie (Prefix Tree)</title><link href="https://elliotyim.github.io/posts/leetcode-22-06-07/" rel="alternate" type="text/html" title="Leetcode - Implement Trie (Prefix Tree)" /><published>2022-06-07T21:14:00+09:00</published> <updated>2022-06-07T21:22:53+09:00</updated> <id>https://elliotyim.github.io/posts/leetcode-22-06-07/</id> <content src="https://elliotyim.github.io/posts/leetcode-22-06-07/" /> <author> <name>{"name"=>"Elliot Yim", "link"=>"https://github.com/elliotyim"}</name> </author> <category term="프로그래밍" /> <category term="자료구조" /> <summary> Link: https://leetcode.com/problems/implement-trie-prefix-tree Introduction Trie 자료구조는 계속 정리해둬야지 하고 있었는데 마침 Leetcode에서 좋은 문제를 발견했다. arr = [‘A’, ‘to’, ‘tea’, ‘ted’, ‘ten’, ‘t’, ‘in’, ‘inn’]를 Trie에 저장한 상태 Trie는 트리 형태의 자료 구조로, Root Node에서 이어지며 문자열의 글자를 하나씩 저장한다. 저장 공간을 많이 차지한다는 단점을 가지지만 문자열 검색에 탁월한 성능을 가진다는 장점이 있다. Insert: O(n) 길이가 n인 문자열 삽입 Search: O(n) 길이... </summary> </entry> </feed>
