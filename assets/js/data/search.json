[ { "title": "Leetcode - 26. Remove Duplicates from Sorted Array", "url": "/posts/remove-duplicates-from-sorted-array/", "categories": "알고리즘", "tags": "", "date": "2022-11-12 22:50:00 +0900", "snippet": "Link: https://leetcode.com/problems/remove-duplicates-from-sorted-array/Introduction입력으로 받은 배열 안의 중복된 데이터를 in-place로 제거하는 문제이다.중복된 숫자들을 제거하고 앞에서부터 숫자를 채우면 되는데, 뒤쪽에는 어떤 숫자가 위치하든 상관없고, 중복없는 숫자의 갯수 k만 반환하면 된다.Solutionclass Solution: def removeDuplicates(self, nums: List[int]) -&amp;gt; int: if len(nums) &amp;lt; 2: return 1 cursor = 1 for i in range(1, len(nums)): if nums[i-1] != nums[i]: nums[cursor] = nums[i] cursor += 1 return cursorI. 문제 정의O(1)의 extra memory로 풀어야 하는게 문제의 조건이다. 보통 이런 경우는 포인터를 두고 문제를 풀면 된다.II. 포인터를 두고 숫자 채우기class Solution: def removeDuplicates(self, nums: List[int]) -&amp;gt; int: if len(nums) &amp;lt; 2: return 1 cursor = 1 for i in range(1, len(nums)): if nums[i-1] != nums[i]: nums[cursor] = nums[i] cursor += 1 return cursor딱히 길게 적을 것이 없을 것 같다. length가 1 이하인 리스트를 받으면 1을 반환하면 되고,length 2 이상 부터는 cursor를 index=1에 두고 거기서 부터 시작해서 1개씩 순회하면서 이전 숫자와 다르다면 cursor가 있는 자리에 하나씩 차곡차곡 뒤쪽의 숫자를 옮겨서 채워 넣으면 된다.Comment오늘의 Daily Problem을 풀어보려고 하니까 난이도가 hard라 금요일의 문제를 가져왔다.반년 정도 알고리즘 문제 정리를 쉬었더니 뭔가 어색하기도 하고 머리가 굳은 느낌이 없잖아 있어서 재활 느낌으로 쉬운 문제를 골랐다." }, { "title": "(WIP) Algorithm Basic - Dynamic Programming", "url": "/posts/dynamic-programming/", "categories": "알고리즘", "tags": "Dynamic Programming, DP, Knapsack Problem", "date": "2022-06-17 19:52:00 +0900", "snippet": "IntroductionDynamic Programming은 알고리즘 중에서도 딱 하나로 정의가 되지 않는 알고리즘이다.DP와 관련된 내용을 인터넷에서 찾아보면 대부분 어딘가에서 가져와서 돌려쓰는 내용 복붙이 많다. (피보나치 멈춰!)DP를 쓰려면 점화식을 세워야 한단다.“음 그럼 점화식은 어떻게 세우죠? 어떤 규칙이 있나요?”라는 물음에,“이런건 감이다. 익숙해져야 한다. 많이 풀다 보면 패턴이 보인다.”라고 하는 알쏭달쏭한 답만 얻을 수 있었다.(많은 경우 풀이 방법만 있고, 어떻게 그런 결론을 도출하게 되었는지의 과정에 대한 내 작은 두뇌로도 이해할 만큼의 자세한 설명이 없었다.)감이 잘 안 옵니다DP에 대해서 공부하면 공부할수록 저 말이 무슨 말인지 이해가 가는 한 편 진리는 언제나 심플하다고 믿는 나로서는 완벽하게 납득이 가진 않았다.그래서 나도 내 방식대로 정리해봤다.그래서 DP가 뭔데?DP(Dynamic Programming)는 고안자인 벨만이 Dynamic이라는 단어가 멋있어서 이름을 저렇게 지었다고 한다.근데 다들 이 DP를 기억하며 풀기로 바꿔 말하는 것에 대해 동의하는 이유는 DP의 풀이방식에 대한 특징 때문이다.중복된 하위 문제 (Overlapping Subproblems)DP는 복잡한 문제를 풀 수 있는 작은 문제로 분할하여 각각을 해결한 뒤 합치는 분할정복(Divide and Conquer) 알고리즘과 비슷하다.다른 점이 있다면 분할한 작은 문제를 해결한 뒤 그 결과를 저장하고, 다음 단계의 문제를 해결할 때 이전에 해결했던 그 결과값도 같이 이용해서 문제를 해결해 나간다.arr = [1, 2, 3, 4], 0 &amp;lt;= k &amp;lt; len(arr) 일 때,a[0]부터 a[k]까지의 부분합을 구하라는 문제가 있다고 가정해보자.위 문제를 단순하게 풀면sum(a[0:1]) = a[0] = 1sum(a[0:2]) = a[0] + a[1] = 3sum(a[0:3]) = a[0] + a[1] + a[2] = 6sum(a[0:4]) = a[0] + a[1] + a[2] + a[3] = 10 가 되는데,sum(a[0:4])의 경우, a[0] + a[1] + a[2]까지는 이미 sum(a[0:3])에서 구했기 때문에 굳이 저렇게 길게 쓰지 않아도 앞서 구한 결과 값인 k = 2일 때 값인 6을 이용할 수 있다.sum(a[0:4]) = 6 + a[3] = 10즉, 중복된 부분은 이미 전 단계에서 구해놨으니까 같은 거 반복하지 말고 그냥 그거 쓰자는 말이다.최적 부분 구조 (Optimal Substructure)파이썬 알고리즘 인터뷰에서 발췌 -박상길 저-최적 부분 구조는 위의 그림을 보면 단번에 이해 된다.서울에서 부산까지 가기 위해 중간에 대구를 거칠 때 굳이 300km나 250km가 걸리는 길을 선택하지 않고, 가장 빠른 최적인 200km의 길을 선택하고 또 대구에서 부산까지 80km의 가장 최적의 길을 선택하는 것. 이것이 최적 부분 구조이다.부분 부분마다 최적의 값을 선택한다는 이야기다.어떻게 적용하는가?DP는 Tabulation이라고 하는 방식으로 최적의 값을 저장해 나간다.보통 1차원 배열과, 2차원 배열을 사용한다.1차원 배열 - 저장하는 값이 1개2차원 배열 - 저장하는 값이 2개 이상References https://namu.wiki/w/%EB%8F%99%EC%A0%81%20%EA%B3%84%ED%9A%8D%EB%B2%95 https://namu.wiki/w/%EA%B7%B8%EB%A6%AC%EB%94%94%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98#s-2.1" }, { "title": "Leetcode - Logest String Chain", "url": "/posts/longest-string-chain/", "categories": "알고리즘", "tags": "DP", "date": "2022-06-15 19:41:00 +0900", "snippet": "Link: https://leetcode.com/problems/longest-string-chain/IntroductionLeetCode 오늘의 문제로 나오길래 풀어보니 이전에 이미 풀어본적 있는 문제였는데, 그 당시 정답을 보고나서도 이해를 잘 못하고 있었어서 그런지 제대로 기억이 안났다.길이가 더 작은 단어에서 큰 단어로 찾아가면서 이전 값을 사용하는 DP 문제이다.SolutionI. 문제 정의words의 길이가 n, words에 포함된 단어의 길이가 m이라고 하면 n * m만으로도 이미 16,000이므로, O((n * m)^2)으로 풀면 시간초과가 나서 이보다는 더 적은 수행시간 내에 해결해야 한다.II. DPword chain 값을 갱신해나가야 하기 위해 각 word의 word chain 값을 저장할 Dictionary와 answer 변수를 준비한다.class Solution: def longestStrChain(self, words: List[str]) -&amp;gt; int: dp, answer = dict(), 0 # 2-1가장 작은 단어부터 시작해서 word chain 값을 적어나갈 것이므로, words를 단어의 길이의 오름차순으로 정렬해준다.class Solution: def longestStrChain(self, words: List[str]) -&amp;gt; int: dp, answer = dict(), 0 sorted_words = sorted(words, key=len) # 2-2우선 각 글자는 그 자체만으로도 word chain 값 1을 가지므로 dp에 이 값을 먼저 저장해 준다.class Solution: def longestStrChain(self, words: List[str]) -&amp;gt; int: dp, answer = dict(), 0 sorted_words = sorted(words, key=len) for word in sorted_words: dp[word] = 1 # 2-3현재 단어의 word chain을 아는 방법은 현재 단어보다 길이가 하나 작은 단어가 dp에 있는지 체크하고, 있으면 그 단어의 word chain 값 + 1 해주면 된다.예시) [&quot;a&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bc&quot;, &quot;bca&quot;, &quot;bda&quot;, &quot;bdca&quot;]의 경우{&#39;a&#39;: 1, &#39;b&#39;: 1, &#39;ba&#39;: 2, &#39;bc&#39;: 2}인 상태에서,bca의 글자를 하나씩 뺀 [ca, bc, ba]중에, 해당되는 글자인 ba와 bc의 값 + 1이 bca의 word chain 값이 된다.우선 글자를 잘라준다.class Solution: def longestStrChain(self, words: List[str]) -&amp;gt; int: dp, answer = dict(), 0 sorted_words = sorted(words, key=len) for word in sorted_words: dp[word] = 1 for i in range(len(word)): sliced_word = word[:i] + word[i+1:] # 2-4자른 글자가 dp에 없다면 (예시에서는 글자 ca) 넘어간다.class Solution: def longestStrChain(self, words: List[str]) -&amp;gt; int: dp, answer = dict(), 0 sorted_words = sorted(words, key=len) for word in sorted_words: dp[word] = 1 for i in range(len(word)): sliced_word = word[:i] + word[i+1:] if sliced_word not in dp: # 2-5 continue무작정 이전 값 + 1의 값으로 갱신하면 안된다.words =[‘a’, ‘ca’, ‘bda’, ‘dca’, ‘bdca’]의 경우, bdca의 자른 글자의 word chain 값이 bda: 1, dca: 3으로 다르다.따라서, 현재 dp[word]의 값과 찾은 이전 단어의 값 중 더 큰 값을 저장한다.class Solution: def longestStrChain(self, words: List[str]) -&amp;gt; int: dp, answer = dict(), 0 sorted_words = sorted(words, key=len) for word in sorted_words: dp[word] = 1 for i in range(len(word)): sliced_word = word[:i] + word[i+1:] if sliced_word not in dp: continue dp[word] = max(dp[word], dp[sliced_word]+1) # 2-6각 단어의 체크가 끝날 때마다 최대값을 갱신해 주고 마지막에 이 값을 반환한다.class Solution: def longestStrChain(self, words: List[str]) -&amp;gt; int: dp, answer = dict(), 0 sorted_words = sorted(words, key=len) for word in sorted_words: dp[word] = 1 for i in range(len(word)): sliced_word = word[:i] + word[i+1:] if sliced_word not in dp: continue dp[word] = max(dp[word], dp[sliced_word]+1) answer = max(answer, dp[word]) # 2-7 return answerCommentDP 문제는 정말 풀어도 풀어도 적응이 안 된다…뭔가 알 듯 말 듯 하면서도 어떤 방식으로 적용해야 하는지 항상 고민이 된다." }, { "title": "Leetcode - Trapping Rain Water", "url": "/posts/trapping-rain-water/", "categories": "알고리즘", "tags": "투포인터", "date": "2022-06-08 22:15:00 +0900", "snippet": "Link: https://leetcode.com/problems/trapping-rain-water/Introduction그냥 우연히 펼친 파이썬 알고리즘 인터뷰 책에 전에 혼자서는 못 풀고 책에 있는 풀이의 도움을 받아 풀었던 문제가 있어서 다시 풀어보니 기억이 잘 안나서(제대로 이해를 못 했다는 뜻) 정리하게 됐다.SolutionI. 문제 정의n의 최대치가 20,000이기 때문에 O(n^2)으로 풀면 수행횟수가 4억이 되어버리기 때문에 무조건 시간초과가 난다.따라서 그보다는 적은 시간내에 풀 수 있는 방식으로 접근해야 한다.II. 투 포인터left와 right 두 개의 포인터를 두고 left는 오른쪽으로, right는 왼쪽으로 진행시키면서 쌓인 물의 높이를 더해나간다.우선, left 포인터를 기준으로 생각해보자. 편의상 가장 높은 기둥의 오른쪽까지는 날려버리고, left가 체크하는 범위는 시작점 부터 가장 높은 기둥까지로 제한한다. 그 오른쪽 부분은 right 포인터가 체크할 것이다.웅덩이 부분에 들어왔을 때부터 나갈 때까지는 오른쪽에 항상 left가 지나온 기둥보다는 더 높은 기둥이 존재할 것이다.그렇기 때문에 물 웅덩이가 쌓을 수 있는 물의 양은 둘러 싸고 있는 왼쪽 오른쪽 기둥 중 더 작은 높이인 왼쪽의 기둥의 높이 - 현재 위치이다.우선 여기까지를 코드로 구현해보자. water는 물 웅덩이의 양이고, left와 right 포인터를 지정해준다.class Solution: def trap(self, height: List[int]) -&amp;gt; int: water = 0 # 1 left, right = 0, len(height) - 1 # 1right는 신경쓰지 말고 left만 움직여보자.class Solution: def trap(self, height: List[int]) -&amp;gt; int: water = 0 left, right = 0, len(height) - 1 while left &amp;lt; right: left += 1 # 2left가 지나오면서 가장 높았던 기둥의 높이를 기억해두자.class Solution: def trap(self, height: List[int]) -&amp;gt; int: water = 0 left, right = 0, len(height) - 1 left_max = 0 while left &amp;lt; right: left_max = max(left_max, height[left]) # 3 left += 1전술했듯이, 어차피 오른쪽은 더 높은 기둥으로 막혀 있어서 왼쪽 기둥의 높이와 현재 높이 만큼의 차이가 쌓인 물의 양이다.class Solution: def trap(self, height: List[int]) -&amp;gt; int: water = 0 left, right = 0, len(height) - 1 left_max = 0 while left &amp;lt; right: left_max = max(left_max, height[left]) water += left_max - height[left] # 4 left += 1이걸 right도 똑같이 반복한다.class Solution: def trap(self, height: List[int]) -&amp;gt; int: water = 0 left, right = 0, len(height) - 1 left_max, right_max = 0, 0 while left &amp;lt; right: left_max, right_max = max(left_max, height[left]), max(right_max, height[right]) water += left_max - height[left] left += 1 water += right_max - height[right] # 5 right -= 1여기서 똑같이 한 번에 한 칸씩 움직이게 될 경우 한 포인터가 먼저 가장 높은 곳에 도착하게 되면 그 포인터는 더 이상 앞으로 움직이면 안되기에 제한 조건을 걸어줘야한다.한 번에 똑같이 한 칸씩이 아니라 더 낮은 위치에 있는 포인터를 먼저 움직이면서 진행시키면 한 쪽이 가장 높은 기둥에 도착했을 때부터는 다른쪽 포인터가 도착할때까지 기다리게 할 수 있다.class Solution: def trap(self, height: List[int]) -&amp;gt; int: water = 0 left, right = 0, len(height) - 1 left_max, right_max = 0, 0 while left &amp;lt; right: left_max, right_max = max(left_max, height[left]), max(right_max, height[right]) if height[left] &amp;lt; height[right]: # 6 water += left_max - height[left] left += 1 else: water += right_max - height[right] right -= 1 return water이 알고리즘의 시간복잡도는 O(n)이고, 공간복잡도는 O(1)이다.CommentStack을 사용하는 방법이 있는데 아무리 봐도 도저히 이해가 안되서 이해가 되면 다시 이 포스팅을 업데이트 해야겠다. 근데 Stack 방법보다는 이 포인터 방식이 더 직관적이고 마음에 든다." }, { "title": "Leetcode - Implement Trie (Prefix Tree)", "url": "/posts/leetcode-22-06-07/", "categories": "프로그래밍, 자료구조", "tags": "Trie", "date": "2022-06-07 21:14:00 +0900", "snippet": "Link: https://leetcode.com/problems/implement-trie-prefix-treeIntroductionTrie 자료구조는 계속 정리해둬야지 하고 있었는데 마침 Leetcode에서 좋은 문제를 발견했다.arr = [‘A’, ‘to’, ‘tea’, ‘ted’, ‘ten’, ‘t’, ‘in’, ‘inn’]를 Trie에 저장한 상태Trie는 트리 형태의 자료 구조로, Root Node에서 이어지며 문자열의 글자를 하나씩 저장한다. 저장 공간을 많이 차지한다는 단점을 가지지만 문자열 검색에 탁월한 성능을 가진다는 장점이 있다. Insert: O(n) 길이가 n인 문자열 삽입 Search: O(n) 길이가 n인 문자열이 자료구조에 포함되어 있는지 검색 뿐만 아니라, Autocomplete, Spell Check등에도 사용할 수 있다.I. Trie ClassTrie는 노드 클래스를 만들어 연결하는 방식으로 구현해도 되지만, 여기서는 Linked Nodes의 개념만 차용하여 간결하게 Dictionary(Map)로 구현한다.class Trie: def __init__(self): self.root = {} def insert(self, word): pass def search(self, word): pass def startsWith(self, prefix): pass def suggest(self, word): passII. Insertword에서 한 글자 한 글자씩 떼서 Trie에 기록하기 위해 순회한다.class Trie: def __init__(self): self.root = {} def insert(self, word): for ch in word: # 2-1 passRoot Node부터 시작한다. 현재 노드를 가리키는 cur_node에 Root Node를 할당한다.class Trie: def __init__(self): self.root = {} def insert(self, word): cur_node = self.root # 2-2 for ch in word: pass비어 있는 Trie에 trip이라는 단어를 집어넣는다고 생각해보자.여기서는 Dictionary를 사용하므로 Key가 해당 노드의 알파벳이고, Value가 해당 노드에 이어져 있는 다른 노드들의 집합이 된다.‘t’, ‘r’, ‘i’, ‘p’라는 알파벳을 갖고 있는 노드들을 만들어서 이어주어야 하는데, 처음이라 비어있으면 해당 노드를 먼저 만들어줘야한다. 여기서는 해당 노드의 알파벳을 Key로 가지는 집합을 만들어주면 된다.class Trie: def __init__(self): self.root = {} def insert(self, word): cur_node = self.root for ch in word: if ch not in cur_node: cur_node[ch] = {} # 2-3json 형태로 살펴보면 아래와 같은 느낌이다.{ &quot;t&quot;: {}}cur_node에서 cur_node[ch]로 넘어가기 위해 cur_node를 cur_node[ch]로 바꿔주자. (쉽게 생각해서 depth를 늘려서 계속 안쪽으로 들어간다는 뜻)class Trie: def __init__(self): self.root = {} def insert(self, word): cur_node = self.root for ch in word: if ch not in cur_node: cur_node[ch] = {} cur_node = cur_node[ch] # 2-4마지막 알파벳인 p가 쓰여져 있는 노드에는 해당 위치에 단어가 있다는 &#39;*&#39; 표시를 남기고 해당 단어를 넣어둔다.class Trie: def __init__(self): self.root = {} def insert(self, word): cur_node = self.root for ch in word: if ch not in cur_node: cur_node[ch] = {} cur_node = cur_node[ch] cur_node[&#39;*&#39;] = word # 2-5trip, trap라는 단어들을 넣었을 때 trie는 이런 형태가 된다.{ &quot;t&quot;: { &quot;r&quot;: { &quot;i&quot;: { &quot;p&quot;: { &quot;*&quot;: &quot;trip&quot; } }, &quot;a&quot;: { &quot;p&quot;: { &quot;*&quot;: &quot;trap&quot; } } } }}III. Search노드를 계속해서 탐색해가다가 중간에 끊어지면 해당 단어가 Trie에 없다는 뜻이므로 False를 반환한다. 나머지는 Insert랑 똑같이 계속해서 탐색할 노드를 바꿔가며 안으로 들어간다.class Trie: def __init__(self): self.root = {} def search(self, word): cur_node = self.root for ch in word: if ch not in cur_node: # 3-1 return False cur_node = cur_node[ch]word의 글자 수만큼 들어갔을 때까지 끊기지 않았다면 종착지에 Insert 때 해둔 &#39;*&#39; 표시가 해당 노드에 있는지를 판별하고 있으면 True를, 없다면 False를 반환한다.class Trie: def __init__(self): self.root = {} def search(self, word): cur_node = self.root for ch in word: if ch not in cur_node: return False cur_node = cur_node[ch] return &#39;*&#39; in cur_node # 3-2IV. Prefix해당 단어로 시작하는 단어가 Trie에 있는지 찾는 법은 search와 크게 다르지 않다. 마지막 노드에 &#39;*&#39; 표시가 없어도 된다는 것만 다르다.class Trie: def __init__(self): self.root = {} def startsWith(self, prefix: str) -&amp;gt; bool: cur_node = self.root for ch in prefix: if ch not in cur_node: return False cur_node = cur_node[ch] return True # 4-1V. AutocompleteAutocomplete도 입력받은 word의 끝까지 탐색하는 것까지는 같다.class Trie: def __init__(self): self.root = {} def suggest(self, word): cur_node = self.root for ch in word: if ch not in cur_node: return False cur_node = cur_node[ch]여기서 autocomplete에 해당하는 단어들을 담을 result 리스트를 준비해주고 해당 노드 부터 하위 노드들을 모두 탐색해서 단어들을 다 담아 반환해 주면 된다.class Trie: def __init__(self): self.root = {} def suggest(self, word): cur_node = self.root for ch in word: if ch not in cur_node: return False cur_node = cur_node[ch] result = [] self.find_all(cur_node, result) return resultfind_all()를 구현해보자. 우선 현재 노드가 가지고 있는 알파벳(key)과 다음 노드들의 집합(value)을 차례로 순회한다.class Trie: def __init__(self): self.root = {} def find_all(self, node, result): for key, value in node.items(): # 5-1 passkey가 &#39;*&#39;인 경우에는 현재 노드에 후보 단어가 들어 있으므로 result에 담고 넘어간다.class Trie: def __init__(self): self.root = {} def find_all(self, node, result): for key, value in node.items(): if key == &#39;*&#39;: # 5-2 result.append(value) continue그렇지 않은 경우는 해당 노드를 탐색한다.class Trie: def __init__(self): self.root = {} def find_all(self, node, result): for key, value in node.items(): if key == &#39;*&#39;: result.append(value) continue self.find_all(node[key], result) # 5-3아래는 arr = [“test”, “tennis”, “tri”, “trie”, “trip”, “trap”, “time”]을 넣은 Trie의 모습이다.{ &quot;t&quot;: { &quot;e&quot;: { &quot;s&quot;: { &quot;t&quot;: { &quot;*&quot;: &quot;test&quot; } }, &quot;n&quot;: { &quot;n&quot;: { &quot;i&quot;: { &quot;s&quot;: { &quot;*&quot;: &quot;tennis&quot; } } } } }, &quot;r&quot;: { &quot;i&quot;: { &quot;e&quot;: { &quot;*&quot;: &quot;trie&quot; }, &quot;*&quot;: &quot;tri&quot;, &quot;p&quot;: { &quot;*&quot;: &quot;trip&quot; } }, &quot;a&quot;: { &quot;p&quot;: { &quot;*&quot;: &quot;trap&quot; } } }, &quot;i&quot;: { &quot;m&quot;: { &quot;e&quot;: { &quot;*&quot;: &quot;time&quot; } } } }}그리고 “tr”이라는 문자열을 가지고 autocomplete를 실행하면 [&#39;trie&#39;, &#39;tri&#39;, &#39;trip&#39;, &#39;trap&#39;] 가 반환된다.VI. Trie Class (Complete)중복되는 탐색 부분을 find_target_node()로 묶었다.class Trie: def __init__(self): self.root = {} def find_target_node(self, word): cur_node = self.root for ch in word: if ch not in cur_node: return None cur_node = cur_node[ch] return cur_node def find_all(self, node, result): for key, value in node.items(): if key == &#39;*&#39;: result.append(value) continue self.find_all(node[key], result) def insert(self, word): cur_node = self.root for ch in word: if ch not in cur_node: cur_node[ch] = {} cur_node = cur_node[ch] cur_node[&#39;*&#39;] = word def search(self, word): target_node = self.find_target_node(word) return target_node is not None and &#39;*&#39; in target_node def startsWith(self, prefix: str) -&amp;gt; bool: target_node = self.find_target_node(prefix) return target_node is not None def suggest(self, word): target_node = self.find_target_node(word) result = [] self.find_all(target_node, result) return resultReferences https://en.wikipedia.org/wiki/Trie" }, { "title": "Backtracking Basic - Combinations", "url": "/posts/backtracking-basic/", "categories": "프로그래밍, 기초", "tags": "백트래킹, 조합", "date": "2022-06-03 21:18:00 +0900", "snippet": "Combinations조합을 만드는 코드가 매번 짤 때마다 헷갈려서 그냥 한 번 정리해두기로 했다.조합할 대상 iterables와 n을 인자로 받은 get_combinations()에서 사용하는 helper 함수에 들어 갈 것은 아래와 같다. iterables 조합할 대상 n 조합될 결과물의 길이 result 조합된 결과물들이 들어있는 결과물 리스트 arr 조합된 결과물을 잠시 담고 있을 그릇 used iterables 중에 한 번 사용된 것은 다시 사용하지 않기 위해 체크해두는 리스트. 중복 허용이면 필요 없음 def get_combinations(iterables, n): result, arr, used = [], [], [False for _ in iterables] helper(iterables, n, result, arr, used) return resulthelper()의 내용. base_condition arr.length == n일 때는 arr의 값을 result에 포함시킨다. iterables를 순회하며 사용하지 않은 item을 arr에 넣고 재귀호출한다.def helper(iterables, n, result, arr, used): if len(arr) == n: result.append([_ for _ in arr]) return for i, item in enumerate(iterables): if not used[i]: used[i] = True arr.append(item) helper(iterables, n, result, arr, used) used[i] = False arr.pop()전체 코드def helper(iterables, n, result, arr, used): if len(arr) == n: result.append([_ for _ in arr]) return for i, item in enumerate(iterables): if not used[i]: used[i] = True arr.append(item) helper(iterables, n, result, arr, used) used[i] = False arr.pop()def get_combinations(iterables, n): result, arr, used = [], [], [False for _ in iterables] helper(iterables, n, result, arr, used) return result" }, { "title": "Leetcode - Check If a String Contains All Binary Codes of Size K", "url": "/posts/leetcode-22-05-31/", "categories": "알고리즘, leetcode", "tags": "알고리즘, leetcode", "date": "2022-05-31 15:54:00 +0900", "snippet": "Link: https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/I. 문제 정의Binary String인 s와 정수 k가 주어진다.k길이 만큼의 모든 binary code 조합의 리스트(ex: [‘00’, ‘10’, ‘01’, ‘11’] when k = 2)의 모든 원소가 s의 substring으로 존재하는지를 체크하는 문제이다.II. 내 맘대로 풀이s의 길이의 최대치는 500,000로 시간복잡도가 O(n)이 아니면 시간초과가 날 것이 뻔하지만 문제를 보자마자 해보고 싶었던 풀이가 있어서 속행1, 우선 k를 넣어주면 그 길이 만큼의 모든 binary string가 담긴 set이 반환되는 함수를 정의한다.class Solution: def hasAllCodes(self, s: str, k: int) -&amp;gt; bool: bin_set = self.get_bin_list(k) # 12, 포인터 두 개 head, tail을 두고 이 tail을 s의 끝까지 이동시킨다.class Solution: def hasAllCodes(self, s: str, k: int) -&amp;gt; bool: bin_set = self.get_bin_list(k) head, tail = 0, k while tail &amp;lt;= len(s): # 2 head += 1 tail += 13, head와 tail로 s를 슬라이싱하면 딱 k 길이만큼의 substring이 완성되는데 bin_set에서 이 substring이 있으면 제거해준다.class Solution: def hasAllCodes(self, s: str, k: int) -&amp;gt; bool: bin_set = self.get_bin_list(k) head, tail = 0, k while tail &amp;lt;= len(s): if s[head:tail] in bin_set: bin_set.remove(s[head:tail]) # 3 head += 1 tail += 14, 만약 bin_set이 비게 되면 모든 binary string을 체크한 것이므로 True를 반환하고 종료. while문이 끝날 때까지 bin_set에 체크되지 않은 binary string이 있다면 False를 반환class Solution: def hasAllCodes(self, s: str, k: int) -&amp;gt; bool: bin_set = self.get_bin_set(k) head, tail = 0, k while tail &amp;lt;= len(s): if s[head:tail] in bin_set: bin_set.remove(s[head:tail]) if not bin_set: # 4 return True head += 1 tail += 1 return False일단 hasAllCodes()의 while문 부분만 봐서는 최악의 경우엔 O(n)으로 동작하고 k의 길이가 길어질수록 이 시간은 줄어든다.그럼 get_bin_set()을 구현해본다.5, result set을 준비하고 이 result를 채워줄 helper 함수를 정의한다. 이 함수에는 result와, result를 채울 때 쓸 배열 하나와 조합할 숫자 1과 0을 담은 string(리스트라도 상관없음), 그리고 k를 넣어준다.class Solution: def get_bin_set(self, k): result = set() self.helper(result, [], &#39;10&#39;, k) # 5 return result6, 백트래킹으로 result를 채울 helper를 구현한다. 우선 base condition은 arr.length가 k일 때이고, 이 때 arr에 담긴 binary string들을 하나의 string으로 합쳐 result에 추가한다.class Solution: def helper(self, result, arr, iterable, k): if len(arr) == k: # 6 result.add(&#39;&#39;.join([_ for _ in arr])) return7, iterable(0과 1이 담긴 string)을 순회하면서 하나씩 arr에 담고 재귀호출한다. 재귀호출이 끝났을 때 해당 숫자를 제거해준다.class Solution: def helper(self, result, arr, iterable, k): if len(arr) == k: result.add(&#39;&#39;.join([_ for _ in arr])) return for i, item in enumerate(iterable): # 7 arr.append(iterable[i]) self.helper(result, arr, iterable, k) arr.pop()전체코드는 아래와 같지만 당연하게도 시간초과가 난다.class Solution: def helper(self, result, arr, iterable, k): if len(arr) == k: result.add(&#39;&#39;.join([_ for _ in arr])) return for i, item in enumerate(iterable): arr.append(iterable[i]) self.helper(result, arr, iterable, k) arr.pop() def get_bin_set(self, k): result = set() self.helper(result, [], &#39;10&#39;, k) return result def hasAllCodes(self, s: str, k: int) -&amp;gt; bool: bin_set = self.get_bin_set(k) head, tail = 0, k while tail &amp;lt;= len(s): if s[head:tail] in bin_set: bin_set.remove(s[head:tail]) if not bin_set: return True head += 1 tail += 1 return False 시간복잡도는 O(2^k) bin_set을 만들 때 2^k만큼 시간이 들어가고 while문을 돌 때 O(k)만큼 시간이 들어간다. -&amp;gt; O((2^k) + k) -&amp;gt; O(2^k) 공간복잡도는 O(2^k) arr.length가 k가 될 때까지 helper의 콜스택 O(k) 만큼 쌓이고, bin_set에 O(2^k)만큼 쌓인다. 세상에. 내가 이걸 왜 했지? 그동안 쌓인 스트레스 분출 같은건가?II. Set을 사용한 정석 풀이1, 출제자의 의도에 맞춰 O(n)으로 풀어본다. bin_set과 head, tail을 두고 체크하는 것은 같다.class Solution: def hasAllCodes(self, s: str, k: int) -&amp;gt; bool: bin_set = set() head, tail = 0, k while tail &amp;lt;= len(s): # 2-1 head += 1 tail += 12, 이번에는 반대로 substring들을 set에 저장한다. 중복된 경우라면 저장되지 않고 넘어갈 것이다.class Solution: def hasAllCodes(self, s: str, k: int) -&amp;gt; bool: bin_set = set() head, tail = 0, k while tail &amp;lt;= len(s): bin_set.add(s[head:tail]) # 2-2 head += 1 tail += 1binary string들의 조합은 k^2만큼씩 늘어난다.when k = 1, [‘0’, ‘1’], length = 2 = 2^1when k = 2, [‘00’, ‘10’, ‘01’, ‘11’], length = 4 = 2^2when k = 3, [‘000’, ‘001’, ‘111’, ‘010’, ‘011’, ‘100’, ‘110’, ‘111’], length = 8 = 2^3…그럼 bin_set의 길이가 2^k, 즉 1 &amp;lt;&amp;lt; k이 되면 모든 substring을 체크한 것이 된다. 만약 충족하지 못하면 False를 반환한다.class Solution: def hasAllCodes(self, s: str, k: int) -&amp;gt; bool: bin_set = set() head, tail = 0, k while tail &amp;lt;= len(s): bin_set.add(s[head:tail]) if len(bin_set) == 1 &amp;lt;&amp;lt; k: # 2-3 return True head += 1 tail += 1 return False 시간복잡도는 O(sk) s.length와 k에 따라 비례적으로 시간이 증가한다. 공간복잡도는 O(2^k) bin_set에는 2^k개 만큼 쌓인다. " }, { "title": "(5/23) Leetcode - 알고리즘 면접 준비", "url": "/posts/leetcode-05-23/", "categories": "알고리즘, leetcode", "tags": "알고리즘, leetcode", "date": "2022-05-27 11:55:00 +0900", "snippet": "121. Best Time to Buy and Sell StockLink: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/class Solution: def maxProfit(self, prices: List[int]) -&amp;gt; int: answer, min_val = 0, float(&#39;inf&#39;) for price in prices: if price &amp;lt; min_val: min_val = price answer = max(answer, price - min_val) return answerFeedback 이정도는 보자마자 바로 구현을 할 수 있어야 함 문제를 어떻게 풀지 문제를 보고 카테고리(풀이법)를 생각해볼 것Description 저가~고가 사이의 차익을 몇 구간씩 나눠서 기록해두며 최대 차익을 갱신해 나간다. (구간을 나누는 기준은 저가) 시간복잡도는 O(n): n에 비례해서 모든 과정의 시간이 증가한다. 공간복잡도는 O(1): answer와 min_val만 있으면 되므로268. Missing NumberLink: https://leetcode.com/problems/missing-number/class Solution: def missingNumber(self, nums: List[int]) -&amp;gt; int: n = len(nums) _sum = (n * (n + 1)) // 2 for no in nums: _sum -= no return _sumFeedback 처음에 _sum을 구할 때 sum([no for no in range(n+1)])로 구했는데 이런건 공식을 찾아서 O(1)로 계산할 수 있도록 하기Description 시간복잡도는 O(n): n에 비례해서 전체적인 시간이 증가한다. 공간복잡도는 O(1): n과 _sum만 있으면 되므로139. Word BreakLink: https://leetcode.com/problems/word-break/class Solution: def wordBreak(self, s: str, wordDict: List[str]) -&amp;gt; bool: word_set = set(wordDict) f = [False] * (len(s)+1) f[0] = True for tail in range(1, len(s)+1): for head in range(tail): if f[head] and s[head:tail] in word_set: f[tail] = True break return f[len(s)]Description 1 ~ s.length까지 움직이는 tail이라는 포인터와, s의 head부터 tail까지의 substring를 사용하여 체크해나간다. f[head]는 현재 체크하려는 s[head:tail] 이전까지의 substring이 체크가 되었는지 여부를 나타낸다. 시간복잡도는 O(m*n*n) wordDict만큼 O(m), s의 길이의 제곱만큼 O(n^2), 따라서 O(m*n*n)인데, wordDict의 길이가 길어질수록 O(n^3)에 가까워진다. 공간복잡도는 O(m*n) wordDict만큼 O(m), s의 길이에 따라 생성된 f의 길이만큼 O(n), 따라서 O(m*n)인데, wordDict의 길이가 길어질수록 O(n^2)에 가까워진다. Note 시간복잡도를 말할 때는 보통 최악의 경우를 생각해서 말할 것 최악의 경우에는 O(n)이지만 감소하는 경우에는 그것에 따라 다르다고 말하면 됨 랜덤으로 주어졌을 때도 n에 비례해서 증가하기 때문에 O(n)이라고 말해야 함 지금 짠 알고리즘이 무엇에 비례해서 증가하는지가 중요하다. (입력 값의 길이 n) O(n)에서는 소요시간이 n에 비례해서 증가한다 n이 1증가 했을 때 시간이 10시간이 증가함 n이 2증가 했을 때 시간이 20시간이 증가함 같은 시간 복잡도라도 더 보기 쉬운 코드가 더 좋고, 더 깔끔한 코드에 점수를 더 준다. 코딩테스트에서는 문제를 정의하는 과정도 평가에 포함되므로, 제약사항도 꼼꼼히 체크할 것" }, { "title": "(5/18) Leetcode - 알고리즘 면접 준비", "url": "/posts/leetcode-05-18/", "categories": "알고리즘, leetcode", "tags": "알고리즘, leetcode", "date": "2022-05-26 18:14:00 +0900", "snippet": "Introduction알고리즘 면접 준비를 하게 되면서 풀게 된 문제를 정리한다.우선은 쉬운 문제들 부터 시작하는데 문제를 푸는 것만이 중요한게 아니라 논리적으로 납득할 만한 설명과 시간복잡도, 공간복잡도를 설명하는 것이 중요하다는 점을 배우게 됐다.70. Climbing StairsLink: https://leetcode.com/problems/climbing-stairs/class Solution: memo = {} def climbStairs(self, n: int) -&amp;gt; int: if n &amp;lt; 0: return 0 elif n == 0: return 1 elif n not in self.memo: self.memo[n] = self.climbStairs(n-1) + self.climbStairs(n-2) return self.memo[n]Feedback 설명이 부족했음 f(k) → k 스텝까지 갈 수 있는 방법의 수 k 스텝까지 갈 수 있는 2가지 방법이 있다. k-1 칸까지 간 다음에 한 칸 점프 k-2 칸까지 간 다음에 두 칸 점프 이제 f(1)을 구하기만 하면 거기서부터 재귀적으로 f(k-1) 또는 f(k-2)까지 구할 수 있게 된다. Description memoization을 사용하지 않는다면 시간복잡도는 O(2^n) 함수 두 개를 n번씩 반복해서 들어가기 때문에 공간복잡도는 O(n) 함수 콜스택 만큼 쌓인다. memoization을 사용하면 시간복잡도는 O(n) 이미 연산한 결과에 대해서는 연산하지 않기 때문에 O(n) 공간복잡도는 O(n) 함수 콜스택과 메모의 공간만큼 쌓이므로 O(2n) -&amp;gt; O(n) 338. Counting BitsLink: https://leetcode.com/problems/counting-bits/class Solution: memo = {} def helper(self, k: int) -&amp;gt; int: if k == 0: return 0 elif k not in self.memo: self.memo[k] = self.helper(k &amp;gt;&amp;gt; 1) + (k &amp;amp; 1) return self.memo[k] def countBits(self, n: int) -&amp;gt; List[int]: answer = [] for k in range(n+1): answer.append(self.helper(k)) return answerDescription 시간복잡도는 O(n) O(1)까지 내려가서 연산해 가져오는데, 결과 값이 이미 있는 경우 memo에서 가져오기 때문에 불필요한 중복과정은 제거되므로 O(n) 공간복잡도는 O(n) 함수 콜스택과 메모의 공간만큼 쌓이므로 O(2n) -&amp;gt; O(n) " }, { "title": "Leetcode - Longest Substring Without Repeating Characters", "url": "/posts/longest-substring-without-repeating-characters/", "categories": "알고리즘, leetcode", "tags": "알고리즘, leetcode, 슬라이딩 윈도우", "date": "2022-04-13 14:50:00 +0900", "snippet": "Link https://leetcode.com/problems/longest-substring-without-repeating-characters/Introduction주어진 문자열 s에서 반복되는 문자가 없는 가장 긴 부분 문자열을 찾는 문제이다.Note Index Out of Range 에러에 주의Solutionclass Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: answer, ch_set = 0, set() left, right = 0, 0 while right &amp;lt; len(s): if s[right] in ch_set: answer = max(answer, len(s[left:right])) while left &amp;lt; right and s[right] in ch_set: ch_set.remove(s[left]) left += 1 ch_set.add(s[right]) right += 1 return max(answer, len(s[left:right]))I. 필요한 변수 준비정답을 담을 변수 answer와 중복된 문자를 체크하기 위한 ch_set 변수, 그리고 슬라이딩 윈도우 알고리즘을 사용해서 풀 것이기 떄문에 left, right 포인터 변수를 준비한다.class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: answer, ch_set = 0, set() left, right = 0, 0II. Sliding Windowright를 0부터 s의 문자열 끝까지 전진시킨다.class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: answer, ch_set = 0, set() left, right = 0, 0 while right &amp;lt; len(s): right += 1 # 2-1전진시키면서 오른쪽 포인터가 가리키는 문자를 ch_set에 넣는다.class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: answer, ch_set = 0, set() left, right = 0, 0 while right &amp;lt; len(s): ch_set.add(s[right]) # 2-2 right += 1right 포인터가 가리키는 문자열이 중복되는 경우 해당 문자 이전까지의 substring의 길이값을 최대값과 비교하여 갱신한다.class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: answer, ch_set = 0, set() left, right = 0, 0 while right &amp;lt; len(s): if s[right] in ch_set: answer = max(answer, len(s[left:right])) # 2-3 ch_set.add(s[right]) right += 1갱신 후에는 left 포인터의 위치를 중복이 안되는 문자가 들어가는 지점까지 옮겨줘야 한다. left는 당연히 right보다 크면 안된다. right 포인터가 위치한 문자가 ch_set에 포함되면 안된다.class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: answer, ch_set = 0, set() left, right = 0, 0 while right &amp;lt; len(s): if s[right] in ch_set: answer = max(answer, len(s[left:right])) while left &amp;lt; right and s[right] in ch_set: # 2-4 ch_set.remove(s[left]) left += 1 ch_set.add(s[right]) right += 1입력 예 “dvdf”와 같이 right 포인터가 문자열에 끝에 들어갈 때까지 if s[right] in ch_set 조건에 걸리지 않는 경우가 있다. (중복되는 문자를 끝까지 못 찾을 경우)이 경우를 생각해서 마지막에 문자열의 길이를 최대값이랑 비교한 후 결과값을 반환해 준다.class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: answer, ch_set = 0, set() left, right = 0, 0 while right &amp;lt; len(s): if s[right] in ch_set: answer = max(answer, len(s[left:right])) while left &amp;lt; right and s[right] in ch_set: ch_set.remove(s[left]) left += 1 ch_set.add(s[right]) right += 1 return max(answer, len(s[left:right])) # 2-5Comment문제를 보자마자 어떻게 해결해야 할지 바로 떠올랐지만 포인터가 어긋나는거 때문에 실수를 좀 많이 했다.근데 역시 더 깔끔하게 푼 코드들 보면 뭔가 자괴감이 들기도…// by jeantimexpublic int lengthOfLongestSubstring(String s) { int i = 0, j = 0, max = 0; Set&amp;lt;Character&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); while (j &amp;lt; s.length()) { if (!set.contains(s.charAt(j))) { set.add(s.charAt(j++)); max = Math.max(max, set.size()); } else { set.remove(s.charAt(i++)); } } return max;}" }, { "title": "(프로그래머스) 연습 문제 - 여행경로", "url": "/posts/travel-path/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, DFS, BFS", "date": "2022-04-12 11:30:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/43164Introduction탐색 문제는 어떻게 하면 탐색을 덜 하고 정답을 찾을 것인지가 중요하다.처음 이 문제를 풀 때는 n이 10,000으로 작아서 무슨 짓을 해도 통과가 될 것 같아 백트래킹으로 풀어버렸지만, 백트래킹은 잘못 사용하면 콜 스택 초과나 불필요하게 수행시간이 늘어나기 때문에 다른 방식의 풀이도 정리하게 됐다.Note 이어져 있는 길들을 전부 탐색하되, 남는 경로가 없도록 탐색한 경로들을 이어 붙인다.Solutionimport heapqfrom collections import deque, defaultdictdef solution(tickets): graph = defaultdict(list) for _from, _to in tickets: heapq.heappush(graph[_from], _to) stack, path = [&quot;ICN&quot;], deque() while stack: _from = stack[-1] if graph[_from]: stack.append(heapq.heappop(graph[_from])) else: path.appendleft(stack.pop()) return list(path)I. 그래프 생성우선 각 공항에서 어떤 공항으로 이어져 있는지를 파악하기 위해 아래와 같은 티켓 경로 그래프를 만들어준다.{ &quot;ICN&quot;: [&quot;ATL&quot;, &quot;SFO&quot;], &quot;SFO&quot;: [&quot;ATL&quot;], &quot;ATL&quot;: [&quot;ICN&quot;, &quot;SFO&quot;]}from collections import defaultdictdef solution(tickets): graph = defaultdict(list) # 1-1조건 중에는 만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 한다라는 조건이 있다. 따라서, 처음부터 알파벳 순으로 정렬시키기 위해 heapq를 사용하여 정렬된 상태로 graph의 리스트에 넣어준다.import heapqfrom collections import defaultdictdef solution(tickets): graph = defaultdict(list) for _from, _to in tickets: heapq.heappush(graph[_from], _to) # 1-2II. 탐색예를 들어, 이런 형태의 공항을 생각해보자.tickets = [[&quot;ICN&quot;, &quot;B&quot;], [&quot;B&quot;, &quot;ICN&quot;], [&quot;ICN&quot;, &quot;A&quot;], [&quot;A&quot;, &quot;D&quot;], [&quot;D&quot;, &quot;A&quot;]]이 공항을 그래프로 변환하면 다음과 같다.{ &quot;ICN&quot;: [&quot;A&quot;, &quot;B&quot;], &quot;B&quot;: [&quot;ICN&quot;], &quot;A&quot;: [&quot;D&quot;], &quot;D&quot;: [&quot;A&quot;]}“ICN”에서 시작할 때,&quot;ICN&quot;-&amp;gt;&quot;A&quot;-&amp;gt;&quot;D&quot;-&amp;gt;&quot;A&quot;로 티켓을 써서 A에 도착하고 나면 티켓 경로 그래프는 아래와 같이 바뀐다.{ &quot;ICN&quot;: [&quot;B&quot;], &quot;B&quot;: [&quot;ICN&quot;], &quot;A&quot;: [], &quot;D&quot;: []}티켓이 남아버린다. 남는 경로는 &quot;ICN&quot;-&amp;gt;&quot;B&quot;-&amp;gt;&quot;ICN&quot;이다.이 &quot;ICN&quot;-&amp;gt;&quot;A&quot;-&amp;gt;&quot;D&quot;-&amp;gt;&quot;A&quot; 경로가 분명 틀린 경로는 아니지만 이렇게 가면 모든 티켓을 사용하지 못하기 때문에 이 경우 해당 경로 트래킹 결과를 저장해 둘 필요가 있다.&quot;ICN&quot;-&amp;gt;&quot;A&quot;-&amp;gt;&quot;D&quot;-&amp;gt;&quot;A&quot;의 경로의 앞에시작점인 “ICN”으로 다시 돌아올 수 있는 &quot;ICN&quot;-&amp;gt;&quot;B&quot;-&amp;gt;&quot;ICN&quot; 경로를 붙이는 것이다.&quot;ICN&quot;-&amp;gt;&quot;B&quot;-&amp;gt;&quot;ICN&quot;-&amp;gt;&quot;A&quot;-&amp;gt;&quot;D&quot;-&amp;gt;&quot;A&quot;이를 구현하기 위해 stack과 path(deque)를 준비한다. 항상 “ICN” 공항에서 출발하므로 stack에는 “ICN”을 넣어준다.import heapqfrom collections import deque, defaultdictdef solution(tickets): graph = defaultdict(list) for _from, _to in tickets: heapq.heappush(graph[_from], _to) stack, path = [&quot;ICN&quot;], deque()아래와 같은 과정을 따른다.1, 스택의 가장 위에 있는 공항에서 다른 공항으로 갈 수 있는 티켓이 있는 경우 그 공항을 stack에 넣어 준다.import heapqfrom collections import deque, defaultdictdef solution(tickets): graph = defaultdict(list) for _from, _to in tickets: heapq.heappush(graph[_from], _to) stack, path = [&quot;ICN&quot;], deque() while stack: _from = stack[-1] if graph[_from]: stack.append(heapq.heappop(graph[_from])) # 2-12, 아까와 같이 더 이상 갈 곳이 없는 경우 (“ICN”-&amp;gt;”A”-&amp;gt;”D”-&amp;gt;”A”) 해당 경로들을 path 큐에 차례로 집어넣는다. (이 때, 시작점 “ICN”에는 아직 갈 수 있는 경로가 남아있으므로 path에는 “A”-&amp;gt;”D”-&amp;gt;”A” 까지만 담긴다.)import heapqfrom collections import deque, defaultdictdef solution(tickets): graph = defaultdict(list) for _from, _to in tickets: heapq.heappush(graph[_from], _to) stack, path = [&quot;ICN&quot;], deque() while stack: _from = stack[-1] if graph[_from]: stack.append(heapq.heappop(graph[_from])) else: path.appendleft(stack.pop()) # 2-2이 과정을 반복하면 “ICN”에서 갈 수 있는 곳이 없어질 때까지 stack에 “ICN”에서 부터 갈 수 있는 공항 싸이클을 저장해뒀다가 path 큐에 넣는 작업을 오른쪽에서 부터 붙여나가 경로를 완성 시킬 수 있다.1. path: &quot;A&quot;-&amp;gt;&quot;D&quot;-&amp;gt;&quot;A&quot;2. path: &quot;ICN&quot;-&amp;gt;&quot;B&quot;-&amp;gt;&quot;ICN&quot;-&amp;gt;&quot;A&quot;-&amp;gt;&quot;D&quot;-&amp;gt;&quot;A&quot;queue는 리스트가 아니므로 list로 변환해서 반환한다.import heapqfrom collections import deque, defaultdictdef solution(tickets): graph = defaultdict(list) for _from, _to in tickets: heapq.heappush(graph[_from], _to) stack, path = [&quot;ICN&quot;], deque() while stack: _from = stack[-1] if graph[_from]: stack.append(heapq.heappop(graph[_from])) else: path.appendleft(stack.pop()) return list(path)Comment풀어놓고 보니 힙, 스택, 큐를 전부 다 사용한 풀이가 됐다.근데 풀면서 느낀거지만 틈만 나면 백트래킹이나 재귀로 문제를 해결하려고 하는 버릇을 고쳐야겠다. 그런 코드가 이해하기 쉬울지는 모르겠지만 수행시간이 너무 길어지고, 결국엔 콜스택을 쌓는 것이기 때문에 부담이 된다.solution의 풀이는 0.03ms정도로 굉장히 빠르고 메모리도 10MB밖에 안쓰는데, 무지성 백트래킹으로 푸니까 더 시간도 많이 걸리고 메모리도 많이 썼다처음에 풀었던 풀이 (330ms, 15MB)def f(tickets, visited, arr, answer, index): if len(arr) == len(tickets)+1: answer.append([_ for _ in arr]) return for i, ticket in enumerate(tickets): if visited[i]: continue elif ticket[0] == tickets[index][1]: arr.append(ticket[1]) visited[i] = True f(tickets, visited, arr, answer, i) arr.pop() visited[i] = Falsedef solution(tickets): answer = [] for i, ticket in enumerate(tickets): if ticket[0] == &#39;ICN&#39;: arr, visited = [ticket[0]], [False for _ in tickets] arr.append(ticket[1]) visited[i] = True f(tickets, visited, arr, answer, i) return sorted(answer)[0]" }, { "title": "2020 카카오 인턴십 - 수식 최대화", "url": "/posts/maximize-expression/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2020, 카카오, 인턴십, 스택, 후위표기법", "date": "2022-04-11 23:29:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/67257Introduction우리가 사용하는 일반적인 수식은 모두 중위 표기법으로 표기되어 있는데, 이것이 사람이 이해하기 쉬운 표기법이라면 후위 표기법은 컴퓨터가 연산을 하기 쉽게 표현하는 표기법이다.중위 표기법을 후위 표기법으로 바꿀 때 연산자의 우선 순위에 따라 어떤 연산자가 먼저 놓여 계산될지 정해지는데, 이를 이용하여 문제를 풀 수 있다.Note 후위 표기법을 이용하여 연산자 우선순위를 바꾸어 변환한뒤 계산한다.Solutionimport reOP_ORDER = [ &quot;+-*&quot;, &quot;+*-&quot;, &quot;-+*&quot;, &quot;-*+&quot;, &quot;*+-&quot;, &quot;*-+&quot;]def calculate(expression): stack = [] for exp in expression: if exp.isnumeric(): stack.append(int(exp)) else: b = stack.pop() a = stack.pop() if exp == &#39;*&#39;: stack.append(a*b) elif exp == &#39;+&#39;: stack.append(a+b) elif exp == &#39;-&#39;: stack.append(a-b) return stack[-1]def convert(expression, operators): result, stack = [], [] for exp in expression: if exp.isnumeric(): result.append(exp) elif not stack: stack.append(exp) else: while stack and operators.index(stack[-1]) &amp;lt;= operators.index(exp): result.append(stack.pop()) stack.append(exp) while stack: result.append(stack.pop()) return resultdef split(expression): return re.findall(r&#39;\\d+|[^0-9]&#39;, expression)def solution(expression): answer = 0 split_exp = split(expression) for op in OP_ORDER: exp = convert(split_exp, op) result = calculate(exp) answer = max(answer, abs(result)) return answerI. 필요한 함수 정의우선 주어진 수식 문자열을 다루기 쉽게 숫자와 연산자로 분리된 리스트로 만들어 줄 함수를 정의한다.def split(expression): passdef solution(expression): answer = 0 split_exp = split(expression) # 1-1 return answer다음으로 분리된 식과 우선순위 순으로 나열된 연산자 문자열을 넣어주면 해당 식을 후위표기법으로 변형시켜주는 함수를 정의한다.OP_ORDER = [ &quot;+-*&quot;, &quot;+*-&quot;, &quot;-+*&quot;, &quot;-*+&quot;, &quot;*+-&quot;, &quot;*-+&quot; # 1-2]def convert(expression, operators): passdef split(expression): passdef solution(expression): answer = 0 split_exp = split(expression) for op in OP_ORDER: exp = convert(split_exp, op) # 1-2 return answer변환한 수식을 계산하는 함수를 정의한다.OP_ORDER = [ &quot;+-*&quot;, &quot;+*-&quot;, &quot;-+*&quot;, &quot;-*+&quot;, &quot;*+-&quot;, &quot;*-+&quot;]def calculate(expression): passdef convert(expression, operators): passdef split(expression): passdef solution(expression): answer = 0 split_exp = split(expression) for op in OP_ORDER: exp = convert(split_exp, op) result = calculate(exp) # 1-3 return answer결과값의 절대값과 최대값을 비교하여 더 크면 갱신해 준다.OP_ORDER = [ &quot;+-*&quot;, &quot;+*-&quot;, &quot;-+*&quot;, &quot;-*+&quot;, &quot;*+-&quot;, &quot;*-+&quot;]def calculate(expression): passdef convert(expression, operators): passdef split(expression): passdef solution(expression): answer = 0 split_exp = split(expression) for op in OP_ORDER: exp = convert(split_exp, op) result = calculate(exp) answer = max(answer, abs(result)) # 1-4 return answerII. 함수구현 - 수식 분리수식은 1자리 이상의 숫자거나\\d+, 숫자가 아닌 모든 문자[^0-9]를 기준으로 자른다.import redef split(expression): return re.findall(r&#39;\\d+|[^0-9]&#39;, expression) # 2-1이 함수를 사용하면 아래와 같이 숫자와 연산자를 분리할 수 있다.&quot;100-2145*458+12&quot; -&amp;gt; [&quot;100&quot;, &quot;-&quot;, &quot;2145&quot;, &quot;*&quot;, &quot;458&quot;, &quot;+&quot;, &quot;12&quot;]III. 함수구현 - 수식 변환아래의 과정을 통해 중위 표기식을 후위 표기법으로 변환한다.1, 숫자는 바로 result에 넣는다.def convert(expression, operators): result, stack = [], [] for exp in expression: if exp.isnumeric(): # 3-1 result.append(exp)2, 연산자는 스택이 비었으면 스택에 넣는다.def convert(expression, operators): result, stack = [], [] for exp in expression: if exp.isnumeric(): result.append(exp) elif not stack: # 3-2 stack.append(exp)3, 스택이 비어있지 않다면 스택의 가장 위에 있는 연산자가 현재 연산자의 우선순위보다 낮아질 때까지 스택에서 연산자를 계속 꺼내 result에 더하고, 마지막에 현재 연산자를 result에 더해준다.def convert(expression, operators): result, stack = [], [] for exp in expression: if exp.isnumeric(): result.append(exp) elif not stack: stack.append(exp) else: while stack and operators.index(stack[-1]) &amp;lt;= operators.index(exp): result.append(stack.pop()) # 3-3 stack.append(exp) # 3-34, 마지막으로 스택에 남아있는 모든 것을 result에 넣어주고 result를 반환한다.def convert(expression, operators): result, stack = [], [] for exp in expression: if exp.isnumeric(): result.append(exp) elif not stack: stack.append(exp) else: while stack and operators.index(stack[-1]) &amp;lt;= operators.index(exp): result.append(stack.pop()) stack.append(exp) while stack: result.append(stack.pop()) # 3-4 return resultIV. 함수구현 - 수식 계산후위 표기법으로 변환된 수식은 다음과 같은 과정을 거쳐 계산한다.1, 숫자면 스택에 넣는다.def calculate(expression): stack = [] for exp in expression: if exp.isnumeric(): stack.append(int(exp)) # 4-12, 연산자의 경우 스택에서 숫자를 2개 빼온다. (순서에 주의)def calculate(expression): stack = [] for exp in expression: if exp.isnumeric(): stack.append(int(exp)) else: b = stack.pop() # 4-2 a = stack.pop() # 4-23, 해당 연산자로 연산을 한 뒤 스택에 다시 넣어준다.def calculate(expression): stack = [] for exp in expression: if exp.isnumeric(): stack.append(int(exp)) else: b = stack.pop() a = stack.pop() if exp == &#39;*&#39;: stack.append(a*b) # 4-3 elif exp == &#39;+&#39;: stack.append(a+b) # 4-3 elif exp == &#39;-&#39;: stack.append(a-b) # 4-34, 모든 처리가 끝나면 스택에 담긴 숫자를 반환한다.def calculate(expression): stack = [] for exp in expression: if exp.isnumeric(): stack.append(int(exp)) else: b = stack.pop() a = stack.pop() if exp == &#39;*&#39;: stack.append(a*b) elif exp == &#39;+&#39;: stack.append(a+b) elif exp == &#39;-&#39;: stack.append(a-b) return stack[-1] # 4-4Comment후위 표기법은 이상하리 만큼 구현하는 법이 안 외워졌었는데, 이번 문제를 정리하면서 머릿속에 제대로 넣을 수 있게 된 것 같다." }, { "title": "2021 카카오 채용연계형 인턴십 - 거리두기 확인하기", "url": "/posts/check-distances/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2021, 카카오", "date": "2022-03-24 20:30:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/81302Introduction거리두기가 코딩 테스트 문제의 주제로 까지 나오는 것 보면 코로나는 우리의 삶을 너무나도 크게 바꿔 놓은 것 같다. 설마 이 전염병이 이토록 길게 사람들을 고통스럽게 할 줄이야..완전 탐색문제이다.Note 기준점에서 1~2 거리에 있는 지점들을 모두 체크SolutionDX = [ 0, -1, 0, 1, -2, -1, 1, 2, -1, 0, 1, 0]DY = [-2, -1, -1, -1, 0, 0, 0, 0, 1, 1, 1, 2]def check_seats(place, x1, y1, x2, y2): if x1 == x2: return place[abs(y1+y2)//2][x1] == &#39;X&#39; elif y1 == y2: return place[y1][abs(x1+x2)//2] == &#39;X&#39; else: return place[y1][x2] == &#39;X&#39; and place[y2][x1] == &#39;X&#39;def check_place(place): for y in range(len(place)): for x in range(len(place[0])): for i in range(len(DX)): x2, y2 = x + DX[i], y + DY[i] if not 0 &amp;lt;= x2 &amp;lt; len(place[0]) or not 0 &amp;lt;= y2 &amp;lt; len(place) or \\ place[y][x] != &#39;P&#39; or place[y2][x2] != &#39;P&#39;: continue okay = check_seats(place, x, y, x2, y2) if not okay: return 0 return 1def solution(places): answer = [] for place in places: result = check_place(place) answer.append(result) return answerI. 필요한 함수 정의구현할 내용은 간단하다. places에서 place를 하나씩 꺼내서 체크하고 결과 값을 정답리스트에 넣어준다.def check_place(place): passdef solution(places): answer = [] for place in places result = check_place(place) # 1-1 answer.append(result) return answer대기실을 체크를 하는 과정에서 두 좌석의 좌표를 주고 해당 좌석 두 개가 거리두기가 지켜졌는지를 체크하기 위한 함수 또한 정의해 준다.def check_seats(place, x1, y1, x2, y2): passdef check_place(place): passdef solution(places): answer = [] for place in places result = check_place(place) # 1-1 answer.append(result) return answerII. 함수구현 - 대기실 체크대기실의 모든 칸을 순회한다.def check_place(place): for y in range(len(place)): # 2-1 for x in range(len(place[0])): # 2-1 pass return 1모든 칸을 순회하면서 현재 칸(x,y)의 근처의 거리 1~2 정도 떨어져 있는 모든 칸(x2, y2)을 체크 할 건데, (DX, DY)를 그림으로 표현하면 이런 느낌이다.DX = [ 0, -1, 0, 1, -2, -1, 1, 2, -1, 0, 1, 0] # 2-2DY = [-2, -1, -1, -1, 0, 0, 0, 0, 1, 1, 1, 2] # 2-2def check_place(place): for y in range(len(place)): for x in range(len(place[0])): for i in range(len(DX)): x2, y2 = x + DX[i], y + DY[i] # 2-2 return 1x2, y2가 대기실 칸의 범위에서 벗어나 있거나, 체크하려는 칸 둘 중 하나라도 응시자가 앉아있는 자리가 아니면 넘어간다.DX = [ 0, -1, 0, 1, -2, -1, 1, 2, -1, 0, 1, 0]DY = [-2, -1, -1, -1, 0, 0, 0, 0, 1, 1, 1, 2]def check_place(place): for y in range(len(place)): for x in range(len(place[0])): for i in range(len(DX)): x2, y2 = x + DX[i], y + DY[i] if not 0 &amp;lt;= x2 &amp;lt; len(place[0]) or not 0 &amp;lt;= y2 &amp;lt; len(place) or \\ place[y][x] != &#39;P&#39; or place[y2][x2] != &#39;P&#39;: # 2-3 continue return 1두 좌석을 체크하고 거리두기가 지켜져 있지 않으면 0을 반환한다.DX = [ 0, -1, 0, 1, -2, -1, 1, 2, -1, 0, 1, 0]DY = [-2, -1, -1, -1, 0, 0, 0, 0, 1, 1, 1, 2]def check_place(place): for y in range(len(place)): for x in range(len(place[0])): for i in range(len(DX)): x2, y2 = x + DX[i], y + DY[i] if not 0 &amp;lt;= x2 &amp;lt; len(place[0]) or not 0 &amp;lt;= y2 &amp;lt; len(place) or \\ place[y][x] != &#39;P&#39; or place[y2][x2] != &#39;P&#39;: continue okay = check_seats(place, x, y, x2, y2) # 2-4 if not okay: # 2-4 return 0 return 1III. 함수구현 - 좌석 체크두 지점을 잡고 이 지점 두개가 유효한지를 판단하려면 아래의 조건을 체크 하면 된다. 둘 다 x값이 같은 경우, 그 사이 칸에 파티션이 있는지 체크한다. 둘 다 y값이 같은 경우, 그 사이 칸에 파티션이 있는지 체크한다. 나머지 경우엔 사이에 파티션이 모두 있는지 체크한다. 각 경우에 따른 파티션 ‘X’를 체크해준다.def check_seats(place, x1, y1, x2, y2): if x1 == x2: return place[(y1+y2)//2][x1] == &#39;X&#39; # 3-1 elif y1 == y2: return place[y1][(x1+x2)//2] == &#39;X&#39; # 3-2 else: return place[y1][x2] == &#39;X&#39; and place[y2][x1] == &#39;X&#39; # 3-3Comment탐색 문제는 과정이 머릿속에서 그려지기 때문에 재미있게 풀 수 있는 문제인 것 같다" }, { "title": "2021 KAKAO BLIND RECRUITMENT - 순위 검색", "url": "/posts/rank-search/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2021, 카카오, 블라인드, Binary Search", "date": "2022-03-22 18:18:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/72412Introduction푸는 데 몇 일씩 걸렸던 문제였다. 풀다 안풀려서 다른 문제 풀고 틈틈이 한 번씩 다시 시도해보고, 안되서 포기하고 다른 문제 풀러가고…처음에는 info에 tag를 붙이는 방식으로 구현했는데 태깅한 info의 인덱스가 저장된 set를 읽어들이는데 시간이 많이 걸려서 정확성은 문제 없었는데 효율성에서 실패 했었다.from collections import defaultdictdef parse_query(query): q = query.split() return [q[0], q[2], q[4], q[6], q[7]]def attach_tag(info): info_dic = defaultdict(set) for index, inf in enumerate(info): information = inf.split() for j in range(4): tag = information[j] info_dic[tag].add(index) return info_dicdef solution(info, query): answer = [0] * len(query) info_dic = attach_tag(info) for i, q in enumerate(query): result_set = {j for j in range(len(info))} conditions = parse_query(q) for condition in conditions: if not condition.isalpha() or condition == &#39;-&#39;: continue result_set &amp;amp;= info_dic[condition] score_cut = int(conditions[-1]) for result in result_set: score = int(info[result].split()[-1]) if score &amp;gt;= score_cut: answer[i] += 1 return answer27번 라인의 result_set &amp;amp;= info_dic[condition] 이게 시간이 엄청 많이 걸려서 효율성을 통과하지 못했다. (이게 왜 통과할거라고 생각했는지는 아직도 의문이다.)결국 혼자 힘으로 못 풀고 카카오 코테 해설을 봤다. (https://tech.kakao.com/2021/01/25/2021-kakao-recruitment-round-1/)Note 와일드 카드 (-)를 포함해서 검색어 조건의 모든 조합을 만들고 그루핑한다. score를 찾을 때 조차도 이진 탐색으로 찾지 않으면 시간초과가 난다.Solutionfrom bisect import bisect_leftfrom itertools import combinationsfrom collections import defaultdictdef search(query, info_dic): key, score = &#39;&#39;.join(query[:-1]), int(query[-1]) scores = info_dic[key] return len(scores) - bisect_left(scores, score)def parse(query): return [q for q in query.split() if q != &#39;and&#39;]def group(info): info_dic = defaultdict(list) for i in info: conditions = i.split() score = int(conditions[-1]) for n in range(len(conditions)): for comb in combinations([0, 1, 2, 3], n): con = conditions[:-1] for index in comb: con[index] = &#39;-&#39; key = &#39;&#39;.join(con) info_dic[key].append(score) for scores in info_dic.values(): scores.sort() return info_dicdef solution(info, query): answer = [] info_dic = group(info) for q in query: parsed_query = parse(q) result = search(parsed_query, info_dic) answer.append(result) return answerI. 필요한 함수 정의우선 정답리스트와 함께 info를 넣어주면 key:value가 조건묶음:점수리스트로 그루핑된 Dictionary를 반환하는 함수를 정의한다.{ &quot;javabackendjuniorpizza&quot;: [150], &quot;-backendjuniorpizza&quot;: [150], &quot;java-juniorpizza&quot;: [150], &quot;javabackend-pizza&quot;: [150], &quot;javabackendjunior-&quot;: [80, 150], &quot;pythonfrontendsenior-&quot;: [150, 210], &quot;----&quot;: [50, 80, 150, 150, 210, 260]}def group(info): passdef solution(info, query): answer = [] info_dic = group(info) # 1-1 return answer쿼리를 순회하면서 사용하기 편하게 파싱해줄 함수를 정의한다.def parse(query): passdef group(info): passdef solution(info, query): answer = [] info_dic = group(info) for q in query: parsed_query = parse(query) # 1-2 return answer파싱된 query와 info dictionary를 넣어주면 조건에 해당하는 지원자가 몇 명인지 반환하는 함수를 정의하고, 이 결과값을 정답리스트에 넣는다.def search(query, info_dic): passdef parse(query): passdef group(info): passdef solution(info, query): answer = [] info_dic = group(info) for q in query: parsed_query = parse(query) result = search(parsed_query, info_dic) # 1-3 answer.append(result) return answerII. 함수구현 - 그루핑우선 value가 list인 dictionary를 준비한다.from collections import defaultdictdef group(info): info_dic = defaultdict(list) # 2-1 return info_dictinfo를 순회하면서 conditions와 score를 정리해놓는다.from collections import defaultdictdef group(info): info_dic = defaultdict(list) for i in info: conditions = i.split() # 2-2 score = int(conditions[-1]) # 2-2 return info_dictconditions 중에서 n개 만큼 와일드카드(-)를 넣기 위해 n번 순회한다.from collections import defaultdictdef group(info): info_dic = defaultdict(list) for i in info: conditions = i.split() score = int(conditions[-1]) for n in range(len(conditions)): # 2-3 pass return info_dictconditions는 순서대로 언어[0], 직군[1], 경력[2], 소울푸드[3], 점수[4]의 순서대로 이루어져 있다.key에 인덱스 0~3번까지의 조건을 조합하고, value에 인덱스 4인 점수를 저장할 것이므로, [0, 1, 2, 3] 리스트에서 n개를 뽑아 조합을 만든다.from itertools import combinationsfrom collections import defaultdictdef group(info): info_dic = defaultdict(list) for i in info: conditions = i.split() score = int(conditions[-1]) for n in range(len(conditions)): for comb in combinations([0, 1, 2, 3], n): # 2-4 pass return info_dict마지막 인덱스에 있는 점수만 빼고 자를 conditions를 새 리스트에 담고, 이 conditions에 조합된 와일드 카드를 집어넣어 바꿔준다.from itertools import combinationsfrom collections import defaultdictdef group(info): info_dic = defaultdict(list) for i in info: conditions = i.split() score = int(conditions[-1]) for n in range(len(conditions)): for comb in combinations([0, 1, 2, 3], n): con = conditions[:-1] # 2-5 for index in comb: # 2-5 con[index] = &#39;-&#39; return info_dict준비된 리스트를 string 형태로 이어 붙인 뒤, info_dic에 key로, value 점수 리스트에는 현재 점수를 추가해준다.from itertools import combinationsfrom collections import defaultdictdef group(info): info_dic = defaultdict(list) for i in info: conditions = i.split() score = int(conditions[-1]) for n in range(len(conditions)): for comb in combinations([0, 1, 2, 3], n): con = conditions[:-1] for index in comb: con[index] = &#39;-&#39; key = &#39;&#39;.join(con) info_dic[key].append(score) # 2-6 return info_dict점수를 찾기 좋게 info_dic을 순회하면서 점수를 오름차순으로 정렬해준다.from itertools import combinationsfrom collections import defaultdictdef group(info): info_dic = defaultdict(list) for i in info: conditions = i.split() score = int(conditions[-1]) for n in range(len(conditions)): for comb in combinations([0, 1, 2, 3], n): con = conditions[:-1] for index in comb: con[index] = &#39;-&#39; key = &#39;&#39;.join(con) info_dic[key].append(score) for scores in info_dic.values(): # 2-7 scores.sort() return info_dictIII. 함수구현 - 파싱쿼리가 들어오면 split()을 통해 자르고, and를 제외한 모든 조건을 리스트에 넣어 반환한다.def parse(query): return [q for q in query.split() if q != &#39;and&#39;] # 3-1IV. 함수구현 - 탐색우선 쿼리에서 조건 키와 점수를 나눈다.def search(query, info_dic): key, score = &#39;&#39;.join(query[:-1]), int(query[-1]) # 4-1info_dic에서 scores 리스트를 가져온다.def search(query, info_dic): key, score = &#39;&#39;.join(query[:-1]), int(query[-1]) scores = info_dic[key] # 4-2카카오 코테 해설에는 이런 말이 있다....이때, X점 이상 맞은 지원자를 찾기 위해 해당 그룹의 최저점, 혹은 최고점부터 순차적으로 검색한다면 여전히 오랜 시간이 걸리게 됩니다. 이때, 숫자가 오름차순으로 정렬된 배열에서 X라는 숫자를 찾는 효율적인 방법으로 binary search를 사용할 수 있습니다. 이때, 배열에 X가 없을 수도 있으므로, 배열에서 X보다 크거나 같은 숫자가 처음 나타나는 위치를 찾아야 하며, 이는 lower bound를 이용하면 됩니다....파이썬에는 이 lower bound의 binary search를 제공하는 라이브러리가 있다.bisect_left()는 첫 번째 인자로 찾을 리스트를, 두 번째 인자로 받은 숫자 이상의 첫 번째 순서의 숫자의 인덱스를 반환한다.a = [1, 2, 3, 5, 7, 10]bisect.bisect_left(a, 4) # output: 3즉 위 예제에서 4보다 큰 숫자의 갯수를 구하려면 a의 길이 - bisect_left()로 얻은 인덱스의 값을 구하면 된다.def search(query, info_dic): key, score = &#39;&#39;.join(query[:-1]), int(query[-1]) scores = info_dic[key] return len(scores) - bisect_left(scores, score) # 4-3Comment정말 극한으로 효율성을 신경써야지 통과할 수 있는 문제였다.처음에 생각했던 태깅하는 방식은 진짜 만들어 놓고 “아 이런 참신한 생각은 아무도 못했겠지? 역시 난 멋져”하고 자뻑하고 있었는데 효율성에 걸릴 줄이야…" }, { "title": "2021 KAKAO BLIND RECRUITMENT - 메뉴 리뉴얼", "url": "/posts/menu-renewal/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2021, 카카오, 블라인드", "date": "2022-03-21 22:48:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/72411Introduction주문된 요리들을 가지고 만들 수 있는 메뉴 조합을 전부 생각한 뒤 그 중에 2명 이상의 주문한 같은 메뉴의 조합을 골라서 반환하면 되는 문제이다.Note orders의 메뉴가 정렬되어 있지 않다는 점에 주의Solutionfrom itertools import combinationsfrom collections import defaultdictdef pick_menu(candidates): result = [] for menu in candidates.values(): for m, count in menu: result.append(m) return resultdef create_menu_candidates(ordered_menu): candidates = defaultdict(list) for menu, count in ordered_menu.items(): if count == 1: continue course_length = len(menu) if course_length not in candidates: pass elif count &amp;lt; candidates[course_length][0][1]: continue elif count &amp;gt; candidates[course_length][0][1]: candidates[course_length] = [] candidates[course_length].append((menu, count)) return candidatesdef count_orders(orders, course): ordered_menu = defaultdict(int) for order in orders: for c in course: for o in combinations(sorted(order), c): menu = &#39;&#39;.join(o) ordered_menu[menu] += 1 return ordered_menudef solution(orders, course): ordered_menu = count_orders(orders, course) candidates = create_menu_candidates(ordered_menu) course_menu = pick_menu(candidates) return sorted(course_menu)I. 필요한 함수 정의우선 orders와 course를 넣어주면 아래와 같이 key:value가 메뉴조합:주문량인 ordered_menu를 반환하는 함수를 정의한다.{ &quot;AB&quot;: 1, &quot;AC&quot;: 4, &quot;CDE&quot;: 3, &quot;BCFG&quot;: 2}def count_orders(orders, course): passdef solution(orders, course): ordered_menu = count_orders(orders, course) # 1-1그리고, 이 ordered_menu를 넣으면 아래와 같이 key:value가 코스메뉴개수:[메뉴, 주문량]인 candidates를 반환하는 함수를 정의한다.{ &quot;2&quot;: [[&quot;AC&quot;, 4]], &quot;3&quot;: [[&quot;CDE&quot;, 3]], &quot;4&quot;: [ [&quot;BCFG&quot;, 2], [&quot;ACDE&quot;, 2] ]}def create_menu_candidates(ordered_menu): passdef count_orders(orders, course): passdef solution(orders, course): ordered_menu = count_orders(orders, course) candidates = create_menu_candidates(ordered_menu) # 1-2이 메뉴 후보들을 적절한 1차원 리스트로 바꿔주는 함수를 정의하고, 이 리스트를 알파벳 오름차순으로 정렬한 뒤 반환한다.def pick_menu(candidates): passdef create_menu_candidates(ordered_menu): passdef count_orders(orders, course): passdef solution(orders, course): ordered_menu = count_orders(orders, course) candidates = create_menu_candidates(ordered_menu) course_menu = pick_menu(candidates) # 1-3 return sorted(course_menu)II. 함수구현 - 주문 세기우선 ordered_menu를 준비한다.from collections import defaultdictdef count_orders(orders, course): ordered_menu = defaultdict(int) # 2-1 return ordered_menuorders에 있는 order를 하나씩 꺼내서 (2-2)course별로 (2-3)메뉴 조합을 만든 뒤 (2-4)이 메뉴 조합의 개수를 세준다. (2-5)from collections import defaultdictdef count_orders(orders, course): ordered_menu = defaultdict(int) for order in orders: # 2-2 for c in course: # 2-3 for o in combinations(sorted(order), c): # 2-4 menu = &#39;&#39;.join(o) ordered_menu[menu] += 1 # 2-5 return ordered_menuIII. 함수구현 - 메뉴 후보 생성메뉴 조합 중에서도 2명 이상이 시킨 메뉴 조합 중 가장 인기 있는 메뉴 조합만 유효하므로 모든 메뉴 조합에서 유효한 메뉴조합만 필터링해준다.from collections import defaultdictdef create_menu_candidates(ordered_menu): candidates = defaultdict(list) for menu, count in ordered_menu.items(): if count == 1: continue course_length = len(menu) if course_length not in candidates: pass elif count &amp;lt; candidates[course_length][0][1]: continue elif count &amp;gt; candidates[course_length][0][1]: candidates[course_length] = [] candidates[course_length].append((menu, count)) return candidates우선 value를 list로 갖는 candidates 딕셔너리를 준비한다.from collections import defaultdictdef create_menu_candidates(ordered_menu): candidates = defaultdict(list) # 3-1 return candidatesordered_menu를 순회할 건데, 1번 밖에 주문 안된 메뉴들은 다 걸러준다.from collections import defaultdictdef create_menu_candidates(ordered_menu): candidates = defaultdict(list) for menu, count in ordered_menu.items(): if count == 1: # 3-2 continue return candidates아래의 기준에 따라 처리한다.3-3. 후보에 없는 코스 메뉴면 넣어준다.3-4. 후보에 있는 코스 메뉴의 주문량이 현재 메뉴의 주문량보다 많으면 넘어간다.3-5. 후보에 있는 코스 메뉴의 주문량이 현재 메뉴의 주문량보다 적으면 코스 메뉴에 담겨 있던 메뉴들을 다 없앤다.3-6. 마지막에는 현재 코스 메뉴를 후보에 넣어준다.from collections import defaultdictdef create_menu_candidates(ordered_menu): candidates = defaultdict(list) for menu, count in ordered_menu.items(): if count == 1: continue course_length = len(menu) if course_length not in candidates: # 3-3 pass elif count &amp;lt; candidates[course_length][0][1]: # 3-4 continue elif count &amp;gt; candidates[course_length][0][1]: # 3-5 candidates[course_length] = [] candidates[course_length].append((menu, count)) # 3-6 return candidatesIV. 함수구현 - 메뉴 가공코스 메뉴 후보의 Dictionary에서 메뉴만 빼서 1차원 배열에 담아주면 된다.def pick_menu(candidates): result = [] for menu in candidates.values(): for m, count in menu: result.append(m) return resultComment뭔가 풀긴 풀었는데 피로가 쌓인 상태에서 풀어서 그런지 생각했던 것보다 횡설수설하고 코드도 깔끔하지 않은 이상한 풀이가 된 것 같다.이건 나중에 다시 풀어봐야지" }, { "title": "(프로그래머스) 연습 문제 - 입국심사", "url": "/posts/immigration/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, Binary Search", "date": "2022-03-18 15:43:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/43238Introduction여기에 칼이 있다. 이것을 보고 어떤 사람들은 아래와 같은 일식 요리사를 떠올린다.혹은, 다른 무언가를 떠올릴수도 있을 것이다. 아마도 입에 담기에는 조금 거부감이 들 수 있는 무언가.전자인 요리사가 사용하는 칼과 후자의 상상은 날카로운 물건을 사용하여 무언가를 잘라낸다라는 행위는 같지만, 이것을 어떤 용도로 사용할지, 어떻게 해석할지는 온전히 칼을 쥔 사람의 몫이다. [알고리즘 문제] 다음의 정렬된 배열에서 25라는 숫자를 찾아보세요 (4점)[1, 4, 10, 13, 25, 28, 37, 48, 50, 51, 60, 71, 88, 90, 100]이것이 내가 알고 있는 이진탐색의 사용법이자. 가장 먼저 떠오르는 예제이다.나에게 있어서 이진탐색 = 데이터 안에서 특정 수를 O(logN)으로 빠르게 찾는 방법 딱 거기 까지의 의미를 가지고 있었다.def 이진탐색(대충_저런_배열): ... return 결과값이진탐색()이라는 것은 딱 저러한 형태의 배열을 파라미터로 넣어주면 원하는 값을 찾아 주는 그런 정형화된 알고리즘이었다. 이 문제를 만나기 전까진.Note 이진탐색을 통해 나올 수 있는 최대 결과값을 원하는 값의 방향으로 빠르게 수렴시킨다.Solutiondef solution(n, times): answer, low, high = 0, 1, n * max(times) while low &amp;lt;= high: total, mid = 0, (low + high) // 2 for time in times: total += mid // time if total &amp;lt; n: low = mid + 1 else: high = mid - 1 answer = mid return answer1. 최대값 책정이걸 정말 단순하게 한 명 한 명 돌아가면서 심사받고 걸린 시간 체크하는 시뮬레이션 방식으로 구현하면 무조건 시간초과가 난다.따라서 접근방법을 바꿔서, 몇 명이 심사를 받던지 간에 소요시간 0초 ~ max초 사이에서 이진탐색을 통해 정답 소요시간 ?초를 찾아내는 방법으로 해결한다.우선 가장 시간이 많이 걸리는 경우를 생각해보자. 입출력 예에서 나오는 7분짜리 심사대와 10분짜리 심사대가 있는 경우, 6명의 사람이 10분짜리 심사대에서만 줄을 서서 심사를 받으면 6명 * 10분 = 60분만큼 시간이 걸린다.def solution(n, times): high = n * max(times) # 1-12. 이진탐색그러면 소요시간 최대값 60분을 기준으로 0~30분과 30분~60분, 이 두 구간 중에 정답이 어디에 있는지를 찾아보기 위해 가운데 값인 30분 안에 심사를 받을 수 있는 최대한 많은 사람 수를 세보자.(소수점 버림)30분 / 7분 = 4명30분 / 10분 = 3명4명 + 3명 = 7명합계 7명으로 6명 보다 많다. 이 경우 정답은 0~30분 구간에 있다. (0~15~30)위의 과정을 한 번 더 반복한다. 이번엔 절반 값인 15분을 살펴보자15분 / 7분 = 2명15분 / 10분 = 1명2명 + 1명 = 3명합계 3명으로 6명 보다 적다. 이 경우 정답은 15~30분 구간에 있다. 이 과정을 반복한다.3. 구현우선 이진 탐색을 위해 최소값과 최대값을 지정해준다.def solution(n, times): answer, low, high = 0, 0, n * max(times) # 3-1low와 high의 중간 값 mid를 얻고 low나 high를 mid의 위치로 옮겨주는 것을 두 지점이 만날 때까지 반복한다.우선, 소요시간의 중간 값 mid와 합계를 담을 변수 total을 선언해준다.def solution(n, times): answer, low, high = 0, 0, n * max(times) while low &amp;lt;= high: total, mid = 0, (low + high) // 2 # 3-2중간 값의 소요시간 안에 최대한 많은 심사를 받을 수 있는 사람 수 합계를 구한다.def solution(n, times): answer, low, high = 0, 0, n * max(times) while low &amp;lt;= high: total, mid = 0, (low + high) // 2 for time in times: # 3-3 total += mid // time 이 합계가 n보다 작으면 절반 중 뒤의 구간을 선택 (low – current – mid – answer – high) 크거나 같으면 절반 중 앞의 구간을 선택 (low – answer – mid – current – high) def solution(n, times): answer, low, high = 0, 0, n * max(times) while low &amp;lt;= high: total, mid = 0, (low + high) // 2 for time in times: total += mid // time if total &amp;lt; n: # 3-4 low = mid + 1 else: high = mid - 1total과 n이 같은 경우는 정답을 찾은 상태고 else문으로 들어가니 answer에 현재 소요시간을 넣어주고 이 값을 반환한다.def solution(n, times): answer, low, high = 0, 0, n * max(times) while low &amp;lt;= high: total, mid = 0, (low + high) // 2 for time in times: total += mid // time if total &amp;lt; n: low = mid + 1 else: high = mid - 1 answer = mid # 3-5 return answerComment이진 탐색은 A라는 값을 B라는 값의 방향으로 빠르게 수렴시킨다는 특성을 가지고 있다. (배열에서 특정 값 찾기만 해도 처음에 내가 얻게 되는 가장 중간에 있는 값을 B라는 값으로 수렴시킨다는 것을 알 수 있다.)이름이 탐색이라서, 이 특성에 대해서 눈치채지 못할 수도 있는데 이 문제는 나의 그 고정관념을 부술 수 있었던 좋은 문제였던 것 같다." }, { "title": "(프로그래머스) 연습 문제 - N-Queen", "url": "/posts/n-queen/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 백트래킹", "date": "2022-03-17 19:13:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/12911IntroductionDFS, BFS 하면 가장 먼저 떠오르는 문제가 미로찾기라고 한다면 백트래킹의 대표적인 문제는 N-Queen 이다.모든 엔딩을 보기 위해 모든 선택지를 다 골라본다.백트래킹은 검사를 하다가 현재의 선택지가 틀렸다는 걸 알게 되면 그 선택을 취소하고 그 선택지 대신 다른 선택지를 골라가며 탐색한다는 점에서 재미있는 알고리즘이다.2022 KAKAO BLIND RECRUITMENT 양궁대회에서도 백트래킹을 사용하였는데, 정리해야지 정리해야지 하고 미루다가 이제야 정리를 하게 됐다.Note 같은 그룹 라인에 퀸을 놓지 않아야 한다.Solutionanswer = 0def f(x, n, group1, group2, group3): global answer if x == n: answer += 1 return for y in range(n): if group1[x-y] or group2[y] or group3[x+y-n+1]: continue group1[x-y], group2[y], group3[x+y-n+1] = 1, 1, 1 f(x+1, n, group1, group2, group3) group1[x-y], group2[y], group3[x+y-n+1] = 0, 0, 0def solution(n): global answer group1 = [0 for _ in range(1 + 2*(n-1))] group2 = [0 for _ in range(n)] group3 = [0 for _ in range(1 + 2*(n-1))] f(0, n, group1, group2, group3) return answer1. 퀸의 특성 파악시작하기에 앞서, 퀸에 대해서 생각해보자.퀸은 그림 처럼 8방향, 4개의 축 안에서 이동이 가능하다. 퀸을 어디에 놓던지, 이 4개의 축 안에 서로의 퀸이 놓이면 안 된다.퀸을 x방향으로 1개씩 놓아나간다고 하고, 4번의 경우는 제외한 채 1, 2, 3번 라인을 생각해보자.우선 가장 간단한 2번 라인부터 생각해보자면, y 값이 같지 않으면 된다. n = 4 기준으로 이 y라인 그룹은 4개가 생긴다.대각선을 살펴보자. 퀸을 (3, 3)에 놓은 아래의 그림을 보면 규칙을 발견할 수 있다. 1번 라인은 모두 x-y=0로 값이 같다. 3번 라인의 경우 모두 x+y=n-1를 따르므로, x+y-n+1=0로 값이 모두 같다. 그럼 대각선 라인의 개수는 어떻게 알 수 있을까?1 + 2*(n-1)개씩 대각선 라인이 늘어난다는 규칙을 발견할 수 있다.2. solution() 구현우선 1, 2, 3번 그룹을 각 개수만큼 만들어주자def solution(n): group1 = [0 for _ in range(1 + 2*(n-1))] # 2-1 group2 = [0 for _ in range(n)] # 2-1 group3 = [0 for _ in range(1 + 2*(n-1))] # 2-1파이썬에는 포인터가 없어 number 타입의 변수 값을 함수 안에서 수정할 수 없으므로 글로벌 변수 answer를 만들고 f()를 실행하면 answer의 값을 변경할 수 있게 글로벌 변수로 answer를 정의한다.체크하는 방향은 x방향이고, 0~n 사이를 체크한다.answer = 0 # 2-2def f(x, n, group1, group2, group3): # 2-2 passdef solution(n): global answer # 2-2 group1 = [0 for _ in range(1 + 2*(n-1))] group2 = [0 for _ in range(n)] group3 = [0 for _ in range(1 + 2*(n-1))] f(0, n, group1, group2, group3) # 2-2 return answer3. 함수 f() 구현백트래킹의 기본은 다음과 같다. 마지막 선택지에 도달하면(base condition) 결과 값을 기록해둔다. 모든 선택지 중 선택할 수 있는(보통은 이미 선택하지 않은) 선택지를 선택 상태로 만들고 재귀호출한다. 재귀호출이 끝나면 방금 선택지를 초기화한다.우선 base condition일 때 결과를 카운트 한다.answer = 0def f(x, n, group1, group2, group3): global answer if x == n: # 3-1 answer += 1 return모든 y축에 있는 칸에 Q를 하나씩 놓아볼 건데, 이미 같은 그룹라인에 퀸이 점유하고 있는 경우는 패스한다.answer = 0def f(x, n, group1, group2, group3): global answer if x == n: answer += 1 return for y in range(n): if group1[x-y] or group2[y] or group3[x+y-n+1]: # 3-2 continue어딘가에 Q를 놓았다면 Q가 놓인 자리에 해당하는 그룹들은 점유상태로 바꿔주고, 다음 x축의 칸으로 넘어간다.answer = 0def f(x, n, group1, group2, group3): global answer if x == n: answer += 1 return for y in range(n): if group1[x-y] or group2[y] or group3[x+y-n+1]: continue group1[x-y], group2[y], group3[x+y-n+1] = 1, 1, 1 # 3-3 f(x+1, n, group1, group2, group3) # 3-3해당 선택지를 선택하지 않음 상태로 바꿔준다.answer = 0def f(x, n, group1, group2, group3): global answer if x == n: answer += 1 return for y in range(n): if group1[x-y] or group2[y] or group3[x+y-n+1]: continue group1[x-y], group2[y], group3[x+y-n+1] = 1, 1, 1 f(x+1, n, group1, group2, group3) group1[x-y], group2[y], group3[x+y-n+1] = 0, 0, 0 # 3-44. 조금 더 깔끔한 코드아래의 코드는 좀 더 깔끔하긴 하지만 직관적이지 못해서 아래의 코드를 채택하지는 않았다.방식은 비슷한데 글로벌 변수 answer를 사용하지 않는 방법이다.def f(x, n, group1, group2, group3): result = 0 if x == n: return 1 for y in range(n): if group1[x-y] or group2[y] or group3[x+y-n+1]: continue group1[x-y], group2[y], group3[x+y-n+1] = 1, 1, 1 result += f(x+1, n, group1, group2, group3) group1[x-y], group2[y], group3[x+y-n+1] = 0, 0, 0 return resultdef solution(n): group1 = [0 for _ in range(1 + 2*(n-1))] group2 = [0 for _ in range(n)] group3 = [0 for _ in range(1 + 2*(n-1))] return f(0, n, group1, group2, group3)번외. 빌런세상에…Comment백트래킹을 처음 접할 때의 혼란함은 재귀함수를 처음 접했을 때와 비슷했던 것 같다. 개념 자체는 어렵지 않지만 구현이 좀 헷갈리는 케이스." }, { "title": "(프로그래머스) 연습 문제 - 다음 큰 숫자", "url": "/posts/next-bigger-no/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스", "date": "2022-03-16 20:26:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/12911Introduction비트 연산 문제가 또 있길래 가져와서 정리해봤다. 뭔가 2개 이하로 다른 비트보다 좀 더 까다로운 느낌이다.Note 홀수와 짝수의 경우로 나누어 생각한다.Solutiondef solution(n): if n % 2 == 1: rightmost_zero = (n+1) &amp;amp; ~n next_one = rightmost_zero &amp;gt;&amp;gt; 1 return n ^ rightmost_zero ^ next_one else: rightmost_one = n &amp;amp; ~(n-1) converted_no = n + rightmost_one diff = bin(n).count(&#39;1&#39;) - bin(converted_no).count(&#39;1&#39;) return converted_no | (1 &amp;lt;&amp;lt; diff)-11. 홀수의 경우우선 홀수부터 보자. 예시에 나와 있는 15를 변환하면 23이 된다고 한다.15와 23의 이진수를 살펴보자15 -&amp;gt; 01111(2)23 -&amp;gt; 10111(2)Hoxy..시험삼아 적당히 151이란 숫자를 선택해 1씩 더하면서 이진수를 살펴보자151 -&amp;gt; 10010111(2) (1이 5개)152 -&amp;gt; 10011000(2) (1이 3개)153 -&amp;gt; 10011001(2) (1이 4개)154 -&amp;gt; 10011010(2) (1이 4개)155 -&amp;gt; 10011011(2) (1이 5개)자세히보니 홀수일 때의 규칙은 가장 오른쪽의 0과 그 다음 1을 토글해주면 된다.151 -&amp;gt; 10010111(2) 155 -&amp;gt; 10011011(2)def solution(n): if n % 2 == 1: rightmost_zero = (n+1) &amp;amp; ~n next_one = rightmost_zero &amp;gt;&amp;gt; 1 return n ^ rightmost_zero ^ next_one return -1해당 내용은 2개 이하로 다른 비트에서도 유사한 케이스를 다루었기 때문에 자세한 설명은 생략한다.2. 짝수의 경우78과 83의 이진수를 살펴보자78 -&amp;gt; 1001110(2)83 -&amp;gt; 1010011(2)음…그냥 봐선 모르겠는데? 한 번 78부터 1씩 더하면서 규칙을 찾아보자78 -&amp;gt; 1001110(2) (1이 4개)79 -&amp;gt; 1001111(2) (1이 5개)80 -&amp;gt; 1010000(2) (1이 2개)81 -&amp;gt; 1010001(2) (1이 3개)82 -&amp;gt; 1010010(2) (1이 3개)83 -&amp;gt; 1010011(2) (1이 4개)79부터 80으로 넘어가는 순간, 그러니까 78일 때 가장 오른쪽에 있었던 1에(1001110) 1이 더해지는 순간을 보자80의 2번째 1의(1010000) 뒤로는 전부 0으로 채워지는 순간부터는 그 뒤에 1이 몇개 채워지느냐로 총 1의 개수를 맞춘다.정리하자면 짝수일 때는, n의 가장 오른쪽에 있는 1에 1을 더해서 올린다. 그 수에 n의 1의 개수와 똑같아 지도록 뒤에서부터 1을 채워준다.우선 가장 오른쪽에 있는 1을 찾아준다.def solution(n): if n % 2 == 1: rightmost_zero = (n+1) &amp;amp; ~n next_one = rightmost_zero &amp;gt;&amp;gt; 1 return n ^ rightmost_zero ^ next_one else: rightmost_one = n &amp;amp; ~(n-1) # 2-1원래 숫자인 n에 아까 찾은 가장 오른쪽의 1의 자리에다 1을 더해 숫자를 바꿔준다.ex) 78의 경우: 78 -&amp;gt; 1001110(2), rightmost_one = 10(2)def solution(n): if n % 2 == 1: rightmost_zero = (n+1) &amp;amp; ~n next_one = rightmost_zero &amp;gt;&amp;gt; 1 return n ^ rightmost_zero ^ next_one else: rightmost_one = n &amp;amp; ~(n-1) converted_no = n + rightmost_one # 2-278 = 1001110(2)의 경우 가장 오른쪽의 1에 1을 더해서 80 = 1010000(2)로 만든 후 1을 2개 더 채워주기 위해 011(2)를 만들어 준 후 OR 연산을 한다.이를 위해 우선 원래 n이 가지고 있던 1의 개수에서 바뀐 숫자의 1의 개수의 차이를 구한다.def solution(n): if n % 2 == 1: rightmost_zero = (n+1) &amp;amp; ~n next_one = rightmost_zero &amp;gt;&amp;gt; 1 return n ^ rightmost_zero ^ next_one else: rightmost_one = n &amp;amp; ~(n-1) converted_no = n + rightmost_one diff = bin(n).count(&#39;1&#39;) - bin(converted_no).count(&#39;1&#39;) # 2-3011(2)는 100(2)를 만들어 준 후 1을 빼면 된다. 100(2)는 아까 구해놨던 1의 개수의 차이만큼 1이라는 숫자의 비트를 왼쪽으로 밀어주면 된다. 이걸 바뀐 숫자와 OR 연산해준다.def solution(n): if n % 2 == 1: rightmost_zero = (n+1) &amp;amp; ~n next_one = rightmost_zero &amp;gt;&amp;gt; 1 return n ^ rightmost_zero ^ next_one else: rightmost_one = n &amp;amp; ~(n-1) converted_no = n + rightmost_one diff = bin(n).count(&#39;1&#39;) - bin(converted_no).count(&#39;1&#39;) return converted_no | (1 &amp;lt;&amp;lt; diff)-1 # 2-4Comment어째 푸는 시간보다 정리하는 시간이 더 오래 걸리는 것 같다..이게 맞나?" }, { "title": "(프로그래머스) 연습 문제 - 전화번호 목록", "url": "/posts/phone-book/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 해시", "date": "2022-03-15 15:23:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/42577Introduction원래 예전에 풀었었던 문제였는데 테스트 케이스가 변경되고 이전 풀이로는 못 넘어간다길래 다시 풀어봤다.다시 풀어놓고 보니 절대 좋은 풀이는 아니다. (n이 백만이라 그런지 수행시간이 미쳐날뛴다.)하지만, 다른 사람이 Dictionary(Hash Map)를 사용해 문제를 푼 것을 보고 해시라는 키워드를 보고 각자 떠올리는게 다르구나 하는 생각을 했다. (나는 Hash Set을 떠올렸다.)그리고 이걸 기록으로 남겨두고 싶었다.내가 작성하는 어떠한 형태의 글도 읽는 사람에 따라서는 다르게 해석할 수 있다는 것을 되새기고 싶었고, 그렇다면 나의 생각과 의도를 더욱 정확하게 전달하기 위해서 어떤 식으로 글을 쓰고(코딩을 하고) 단어 선택(변수 지정)을 해야 할 것인가에 대해 고민하게 됐다.Note 해시는 중복을 허용하지 않는다는 점을 이용한다.Solutiondef solution(phone_book): no_set = set() sorted_phone_book = sorted(phone_book, key=len, reverse=True) for no in sorted_phone_book: added_nums = 0 for i in range(len(no)): if no[:i+1] not in no_set: no_set.add(no[:i+1]) added_nums += 1 if added_nums == 0: return False return True1. 사전 작업우선 사용할 해시 셋을 하나 준비한다.def solution(phone_book): no_set = set() # 1-1phone_book을 길이의 역순으로 정리한다.def solution(phone_book): no_set = set() sorted_phone_book = sorted(phone_book, key=len, reverse=True) # 1-22. sorted_phone_book 순회역순으로 정렬된 sorted_phone_book을 번호들을 순회한다.def solution(phone_book): no_set = set() sorted_phone_book = sorted(phone_book, key=len, reverse=True) for no in sorted_phone_book: # 1-3 passno를 앞에서 부터 n개씩 짤라서 no_set에 없으면 넣고 들어간 숫자의 개수를 카운트 한다. 길이의 역순으로 정렬해 두었기 때문에 뒤로 갈수록 넣는 횟수는 줄어든다.ex) “1235”의 경우 -&amp;gt; “1”, “12”, “123”, “1235”def solution(phone_book): no_set = set() sorted_phone_book = sorted(phone_book, key=len, reverse=True) for no in sorted_phone_book: added_nums = 0 for i in range(len(no)): # 1-4 if no[:i+1] not in no_set: no_set.add(no[:i+1]) added_nums += 1added_nums가 0이면 해당 no의 숫자는 이미 no_set에 들어있다는 의미이므로 False를 반환하고 종료한다. 순회가 모두 이상 없이 끝나면 중복이 없으므로 True를 반환한다.def solution(phone_book): no_set = set() sorted_phone_book = sorted(phone_book, key=len, reverse=True) for no in sorted_phone_book: added_nums = 0 for i in range(len(no)): if no[:i+1] not in no_set: no_set.add(no[:i+1]) added_nums += 1 if added_nums == 0: # 1-5 return False return True번외. 출제자의 의도이 사람의 풀이도 나처럼 글자를 하나씩 끊어서 찾아보고 찾아보는 방식이긴 하지만, 나와는 다르게 처음에 정렬을 하지 않는다.정렬이 O(nlogn)이라 해시맵을 채워나가는 과정인 O(n)보다는 더 느려서 그런지 내 풀이보다 수행시간이 2배 빨랐다.def solution(phone_book): answer = True hash_map = {} for phone_number in phone_book: hash_map[phone_number] = 1 for phone_number in phone_book: temp = &quot;&quot; for number in phone_number: temp += number if temp in hash_map and temp != phone_number: answer = False return answer번외2. 개썅마이웨이아름다워 (풀이들 중 수행속도가 젤 빠른게 유머)def solution(phoneBook): phoneBook = sorted(phoneBook) for p1, p2 in zip(phoneBook, phoneBook[1:]): if p2.startswith(p1): return False return True네 형제님 어떤 기분인지 압니다.Comment정리되지 않은 리스트에 대한 접근방식이 나는 아직 좀 미숙한 것 같다. (무작정 정렬부터 해버리다 보니…) 다른 사람의 Dictionary를 사용한 풀이를 보고 나서 무언가 힌트를 얻은 것 같기도 하지만." }, { "title": "2020 KAKAO BLIND RECRUITMENT - 괄호 변환", "url": "/posts/change-brackets/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2020, 카카오", "date": "2022-03-11 22:08:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/60058Introduction2019년 9월 시행된 카카오 블라인드 테스트에서 긴 시간동안 알고리즘에 대한 트라우마를 안겨주었던 정말 나로써는 두 번 다시 쳐다보기도 싫은 문제이다.당시 알고리즘 공부를 막 시작했던 내가 경험삼아 신청했던 2020 블라인드 테스트에서 이 문제는 도무지 이해가 안됐고, 3시간을 고군분투 했지만 정답에는 근접하지도 못한채 테스트가 끝났고 나는 좌절했다.3시간의 무력감을 견디며 그래도 좋은 경험일거라며 버텨야 했던 경험은 꽤 마음의 상처로 남아있다.이 때 이후로 알고리즘이 정말 힘들었었다. 한동안은 문제만 보면 정신이 멍해지고 집중을 못하고 도망치고 싶다는 생각밖에 들지 않았었다.대체 이 문제가 뭘 하고 싶어하는지도 모르겠고 솔직히 이 문제는 정리 안하고 넘어가려고 했었다.시간이 지난 지금 다시 봐도 이 문제는 대체 무슨 근거로 올바른 괄호 문자열을 판단하는지 알 수가 없다.예를 들어, “)()()()(“을 입력 파라미터로 넣으면 내가 생각하기엔 “()()()()”이 되어야 할 것 같은데 정답은 “(((())))”이다.그렇다고 문제에서 말하는 올바른 괄호 문자열라는 것이 어떤 건지 그것에 대한 정의가 제대로 서술되어 있는 것도 아니다.이 포스팅은 아마도 정리만 해놓고 다신 안 볼 것 같다. 내가 알고리즘을 잘하는 것도 아니고, 문제를 잘 만들 수 있을 정도로 머리가 좋지는 않지만 그럼에도 불구하고 이 문제가 좋은 문제라는 말은 못해줄 것 같다.Note 알고리즘대로 구현 한다.SolutionBRACKET_DIC = {&quot;(&quot;: &quot;)&quot;, &quot;)&quot;: &quot;(&quot;}def reverse(brackets): return &#39;&#39;.join([BRACKET_DIC[bracket] for bracket in brackets])def check_brackets(brackets): if not brackets: return False stack = [] for bracket in brackets: if bracket == &#39;(&#39;: stack.append(bracket) elif bracket == &#39;)&#39;: if not stack or stack[-1] != &#39;(&#39;: return False stack.pop() return Truedef check_if_balanced(brackets): return brackets.count(&#39;(&#39;) == brackets.count(&#39;)&#39;)def split_brackets(brackets): u, v = brackets, &#39;&#39; for i in range(2, len(brackets), 2): is_balanced = check_if_balanced(brackets[:i]) if is_balanced: u, v = brackets[:i], brackets[i:] break return u, vdef f(w): if not w: return &#39;&#39; u, v = split_brackets(w) is_valid = check_brackets(u) if is_valid: return u + f(v) else: return &#39;(&#39; + f(v) + &#39;)&#39; + reverse(u[1:-1])def solution(p): return f(p)1. 알고리즘대로 구현우선 알고리즘이 써져 있으니 그대로 따라서 구현해 보자1, 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다.def f(w): if not w: # 1-1 return &#39;&#39;def solution(p): return f(p)2, 문자열 w를 두 “균형잡힌 괄호 문자열” u, v로 분리합니다. 단, u는 “균형잡힌 괄호 문자열”로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다.def split_brackets(brackets): passdef f(w): if not w: return &#39;&#39; u, v = split_brackets(w) # 1-2def solution(p): return f(p)3, 문자열 u가 “올바른 괄호 문자열” 이라면 문자열 v에 대해 1단계부터 다시 수행합니다.3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다.def check_brackets(brackets): passdef split_brackets(brackets): passdef f(w): if not w: return &#39;&#39; u, v = split_brackets(w) is_valid = check_brackets(u) # 1-3 if is_valid: return u + f(v)def solution(p): return f(p)4, 문자열 u가 “올바른 괄호 문자열”이 아니라면 아래 과정을 수행합니다.4-1. 빈 문자열에 첫 번째 문자로 ‘(‘를 붙입니다.4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다.4-3. ‘)’를 다시 붙입니다.4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다.4-5. 생성된 문자열을 반환합니다.def reverse(brackets): passdef check_brackets(brackets): passdef split_brackets(brackets): passdef f(w): if not w: return &#39;&#39; u, v = split_brackets(w) is_valid = check_brackets(u) if is_valid: return u + f(v) else: # 1-4 return &#39;(&#39; + f(v) + &#39;)&#39; + reverse(u[1:-1])def solution(p): return f(p)2. 함수구현 - 괄호 분리괄호를 균형잡힌 괄호 문자열 u와 그렇지 않은 문자열 v로 나눠야 한다.처음에는 u에 입력받은 괄호문자열을 그대로 넣어주고 v에는 공백을 넣어준다.def split_brackets(brackets): u, v = brackets, &#39;&#39; # 2-1 return u, v앞에서 부터 2개씩 체크하며 균형잡힌 문자열인지 체크한다. 균형이 잡힌 부분문자열을 발견하면 거기서 끊어준다.def check_if_balanced(brackets): passdef split_brackets(brackets): u, v = brackets, &#39;&#39; for i in range(2, len(brackets), 2): # 2-2 is_balanced = check_if_balanced(brackets[:i]) if is_balanced: u, v = brackets[:i], brackets[i:] break return u, v균형이 잡혀 있는지는 간단하게 (의 개수와 )가 같은지만 체크하면 된다.def check_if_balanced(brackets): return brackets.count(&#39;(&#39;) == brackets.count(&#39;)&#39;)def split_brackets(brackets): u, v = brackets, &#39;&#39; for i in range(2, len(brackets), 2): # 2-2 is_balanced = check_if_balanced(brackets[:i]) if is_balanced: u, v = brackets[:i], brackets[i:] break return u, v3. 함수구현 - 괄호 체크올바른 괄호 문자열을 체크하는 함수를 구현해야 한다.우선 공백을 받았으면 False를 반환한다.def check_brackets(brackets): if not brackets: # 3-1 return Falsestack을 가지고 체크를 한다. 괄호의 개수 체크는 stack의 기본 응용이고 너무 쉬운 내용이라 넘어간다.def check_brackets(brackets): if not brackets: return False stack = [] for bracket in brackets: # 3-2 if bracket == &#39;(&#39;: stack.append(bracket) elif bracket == &#39;)&#39;: if not stack or stack[-1] != &#39;(&#39;: return False stack.pop() return True4. 함수구현 - 괄호 뒤집기(을 )로, )을 (로 변환할 함수를 Dictionary를 사용하여 편하게 구현한다.BRACKET_DIC = {&quot;(&quot;: &quot;)&quot;, &quot;)&quot;: &quot;(&quot;}def reverse(brackets): # 4 return &#39;&#39;.join([BRACKET_DIC[bracket] for bracket in brackets])Comment때로는 도망치는게 현명한 방법인줄 알았다면 고집 피우지 말걸 그랬다. 우직한게 언제나 정답은 아니라는 걸 배웠다.나는 이 문제를 감당할 수 있을 만큼 준비가 되었을 때 맞닥뜨렸어야 했다." }, { "title": "2020 KAKAO BLIND RECRUITMENT - 문자열 압축", "url": "/posts/compress-string/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2020, 카카오", "date": "2022-03-10 14:40:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/60057Introduction블라인드 코딩테스트에서 이 문제를 처음 풀었을 때는 풀이 언어가 C++과 Java 밖에 선택지가 없었지만, 이 문제가 공개되고 난 뒤 Python이 선택 가능해지면서 더욱 간단하고, 로직에만 집중하는 간결한 풀이가 가능해지게 되었다.Note 자른 문자열을 순회하면서 압축할 때 문자열 순서의 기준을 어디에 두느냐에 따라 마지막 string이 체크가 안 될수 있으므로 주의Solutiondef compress(sliced_strings): result, count, prev = &#39;&#39;, 0, sliced_strings[0] for string in sliced_strings: if string == prev: count += 1 else: result += f&#39;{count}{prev}&#39; if count &amp;gt; 1 else prev prev = string count = 1 if string == prev: result += f&#39;{count}{prev}&#39; if count &amp;gt; 1 else prev return resultdef split_string(string, no): return [string[i:i+no] for i in range(0, len(string), no)]def solution(s): answer = float(&#39;inf&#39;) for no in range(1, len(s)+1): sliced_strings = split_string(s, no) string = compress(sliced_strings) answer = min(answer, len(string)) return answer1. 필요한 함수 정의간단하게 문자열을 특정 개수만큼 자르고, 압축한 뒤에 길이를 재면 된다. 이를 위해 필요한 함수를 정의한다.def compress(sliced_strings): passdef split_string(string, no): passdef solution(s): answer = 0 return answer2. 주어진 함수 사용아래의 과정을 수행한다. 주어진 문자열을 1개~n개씩 잘라본다. 잘라진 문자열을 압축한다. 압축한 문자열이 더 작으면 해당 길이를 정답으로 저장한다.def compress(sliced_strings): passdef split_string(string, no): passdef solution(s): answer = float(&#39;inf&#39;) for no in range(1, len(s)+1): sliced_strings = split_string(s, no) # 2-1 string = compress(sliced_strings) # 2-2 answer = min(answer, len(string)) # 2-3 return answer3. 함수 구현 - 문자열 자르기주어진 문자열의 0번 인덱스 부터 마지막 인덱스까지 no개 간격으로 잘라서 리스트를 만들어 반환한다.def split_string(string, no): return [string[i:i+no] for i in range(0, len(string), no)] # 3-14. 함수 구현 - 문자열 압축우선 필요한 변수들을 정의해 준다.def compress(sliced_strings): result, count, prev = &#39;&#39;, 0, sliced_strings[0] # 4-1 return stringssliced_strings를 순회하면서 prev와 현재 string이 같다면 count를 1 올려준다.def compress(sliced_strings): result, count, prev = &#39;&#39;, 0, sliced_strings[0] for string in sliced_strings: if string == prev: # 4-2 count += 1 return result다른 경우에는 카운트를 체크해서 1 이상이면 result에 압축해서 붙여주고 아니면 그대로 붙여준 뒤에 prev와 count를 초기화 한다.def compress(sliced_strings): result, count, prev = &#39;&#39;, 0, sliced_strings[0] for string in sliced_strings: if string == prev: count += 1 else: # 4-3 result += f&#39;{count}{prev}&#39; if count &amp;gt; 1 else prev prev = string count = 1 return result마지막 string이 prev와 같은 경우 그 마지막 string만 체크가 안되므로 체크해주고 result를 반환한다.def compress(sliced_strings): result, count, prev = &#39;&#39;, 0, sliced_strings[0] for string in sliced_strings: if string == prev: count += 1 else: result += f&#39;{count}{prev}&#39; if count &amp;gt; 1 else prev prev = string count = 1 if string == prev: # 4-4 result += f&#39;{count}{prev}&#39; if count &amp;gt; 1 else prev return resultComment이 문제는 내가 알고리즘 코딩 테스트를 준비하고 처음으로 접한 실전 문제였다.그 당시에는 이 문제 딱 하나 푸는데 자바로 끙끙대며 풀면서 2시간 정도 걸렸던것 같은데 새삼 시간이 많이 흘렀구나 하는 생각이 든다." }, { "title": "2019 KAKAO BLIND RECRUITMENT - 오픈채팅방", "url": "/posts/open-chat-room/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2019, 카카오", "date": "2022-03-09 20:32:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/42888Introduction이름 변경을 제외하면 그냥 유저의 행동을 그대로 프린팅하기만 하면 되는 문제이다. 예전에 알고리즘 문제를 잘 못 풀던 시절에는 이 문제 푸는데 굉장히 끙끙댔던 것 같은데 왜 그랬는지 모르겠다.Note 이름 변경 여부를 체크 한 뒤 유저의 행동을 String으로 바꿔 정답리스트에 넣는다.SolutionACTION_DIC = { &#39;Enter&#39;: &#39;들어왔습니다.&#39;, &#39;Leave&#39;: &#39;나갔습니다.&#39;}def solution(record): answer, actions, name_dic = [], [], {} for r in record: msg = r.split() action, uid = msg[0], msg[1] name = msg[2] if len(msg) == 3 else None if name is not None: name_dic[uid] = name if action != &#39;Change&#39;: actions.append([uid, action]) for uid, action in actions: answer.append(f&#39;{name_dic[uid]}님이 {ACTION_DIC[action]}&#39;) return answer1. 필요한 변수 정의action에 해당하는 문구를 바로 출력할 수 있도록 ACTION_DIC을 준비하고, uid를 key로, 이름을 value로 갖는 name_dic을 준비한다.actions는 이름 변경이 아닌 경우의 모든 action을 다시 담아두기 위해 준비한다.ACTION_DIC = { # 1 &#39;Enter&#39;: &#39;들어왔습니다.&#39;, &#39;Leave&#39;: &#39;나갔습니다.&#39;}def solution(record): answer, actions, name_dic = [], [], {} # 1 return answer2. 이름 변경 처리record를 순회하면서 action, uid, name을 추출한다. Leave의 경우는 name 값이 없으므로 None을 넣어준다.ACTION_DIC = { &#39;Enter&#39;: &#39;들어왔습니다.&#39;, &#39;Leave&#39;: &#39;나갔습니다.&#39;}def solution(record): answer, actions, name_dic = [], [], {} for r in record: msg = r.split() # 2-1 action, uid = msg[0], msg[1] # 2-1 name = msg[2] if len(msg) == 3 else None # 2-1 return answer이름이 없는 경우를 제외하고는 name_dic에 uid별로 이름을 넣어준다. 이름 변경 action의 경우도 여기서 처리된다.ACTION_DIC = { &#39;Enter&#39;: &#39;들어왔습니다.&#39;, &#39;Leave&#39;: &#39;나갔습니다.&#39;}def solution(record): answer, actions, name_dic = [], [], {} for r in record: msg = r.split() action, uid = msg[0], msg[1] name = msg[2] if len(msg) == 3 else None if name is not None: # 2-2 name_dic[uid] = name return answer이름 변경 action 이외의 경우에는 actions에 차곡차곡 쌓아준다.ACTION_DIC = { &#39;Enter&#39;: &#39;들어왔습니다.&#39;, &#39;Leave&#39;: &#39;나갔습니다.&#39;}def solution(record): answer, actions, name_dic = [], [], {} for r in record: msg = r.split() action, uid = msg[0], msg[1] name = msg[2] if len(msg) == 3 else None if name is not None: name_dic[uid] = name if action != &#39;Change&#39;: # 2-3 actions.append([uid, action]) return answer3. 메시지로 변환아까 준비해뒀던 actions를 순회하며 메시지로 변환해 정답리스트에 넣어준다.ACTION_DIC = { &#39;Enter&#39;: &#39;들어왔습니다.&#39;, &#39;Leave&#39;: &#39;나갔습니다.&#39;}def solution(record): answer, actions, name_dic = [], [], {} for r in record: msg = r.split() action, uid = msg[0], msg[1] name = msg[2] if len(msg) == 3 else None if name is not None: name_dic[uid] = name if action != &#39;Change&#39;: actions.append([uid, action]) for uid, action in actions: answer.append(f&#39;{name_dic[uid]}님이 {ACTION_DIC[action]}&#39;) # 3-1 return answerComment블라인드 채용 문제 답지 않은 쉬운 문제였다. O(n)으로 풀어보려고 했지만 실패. 도중의 이름 변경 액션 때문에 가능한지 어떤지도 잘 모르겠다." }, { "title": "2019 KAKAO BLIND RECRUITMENT - 후보키", "url": "/posts/candidate-keys/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스", "date": "2022-03-08 15:35:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/42890Introduction좋은 코드의 기준은 언제나 명확하다. 작성하고 나서 1년 뒤에 읽어봐도 단번에 납득이 갈만한 코드가 그런데, 반대로 안 좋은 코드는 분명 작성한 사람이 나인데도 1달 정도 지나서 다시 보면 이해하는데 시간이 걸린다.이는 적절한 등장인물과 쉽게 납득할만한 스토리의 묘사가 충분히 이루어지지 않았기 때문이라고 생각한다.80%나 되는 개발자가 변수명을 짓는데에 어려움을 겪는다는 이유가 여기에 있다. 그 만큼 중요하니까. 이 코드 뭉치의 이야기를 전개해나가는 등장인물들이 명확하게 정의가 되어야 흐름이 눈에 보이니까.최근에 더욱 이런 등장인물들의 행동 묘사와 이야기의 흐름에 대해 신경쓰며 코딩하고 있지만, 역시나 너무 어렵다. 이유는 두 가지 이다. 내가 생각해낸 단어를 보고 사람들은 다른 것을 연상할 수 있다. 소설의 경우는 이를 돕기 위해 지면을 들여 부연설명 및 묘사를 하는데, 코딩에 있어서는 늘어난 코드의 라인 = 복잡도이기 때문에 어떻게 해도 만족스럽지가 않다. 3+5와 사과 3개가 있는데 거기에 사과 5개를 더한다는 설명은 결과물은 같을 수 있어도 그 안의 상황은 완전 다르다. 컴퓨터가 필요로 하는게 3+5라면 내가 작성한 코드를 읽는 사람들에게 더 도움이 되는 표현방법은 사과 3개가 있는데 거기에 사과 5개를 더한다고 하는 상상 속 세계 안에서 벌어지고 있는 어떤 사건들이다. 이 절충점을 잡는 것이 너무나도 어렵다.이번 문제를 풀면서도 이걸 어떻게 더 읽기 쉽게 만들 수 있을까 하는 고민을 엄청 많이 했지만 작성해 놓고 다시 보니 아직 한참 멀은 것 같다.Note 유일성과 최소성을 체크할 방법을 생각한다.Solutionfrom itertools import combinationsfrom collections import defaultdictdef check_minimality(index_set, registered_index_sets): for registered_index_set in registered_index_sets: if (index_set &amp;amp; registered_index_set) == registered_index_set: return False return Truedef get_unique_column_index_sets(relation, columns, no_of_cols): index_dict = defaultdict(set) for index_comb in combinations(columns, no_of_cols): for tuple_ in relation: value_comb = tuple([tuple_[index] for index in index_comb]) index_dict[index_comb].add(value_comb) return [set(indexes) for indexes, values in index_dict.items() if len(values) == len(relation)]def solution(relation): registered_index_sets = [] columns = [i for i in range(len(relation[0]))] for no_of_cols in range(1, len(columns)+1): index_sets = get_unique_column_index_sets(relation, columns, no_of_cols) for index_set in index_sets: is_valid = check_minimality(index_set, registered_index_sets) if is_valid: registered_index_sets.append(index_set) return len(registered_index_sets)1. 필요한 함수 정의이 문제의 핵심 키워드는 두 가지이다. 바로 유일성(uniqueness)과 최소성(minimality). 이를 판별해 줄 수 있는 함수를 정의해보자.유일성부터 살펴보자면, 우선 우리에겐 (이름, 전공)과 같은 유니크한 조합을 반환하는 함수가 필요하다.튜플의 정보를 모두 사용하기에는 너무 용량이 크니까 인덱스만 다루는 걸로 하고 원본 릴레이션, 컬럼 인덱스 리스트, 그리고 조합할 컬럼 갯수를 넣어주면 유니크한 컬럼 인덱스 조합셋을 반환하는 함수를 만든다고 하자.def get_unique_column_index_sets(relation, columns, no_of_cols): # 1-1 passdef solution(relation): answer = [] return answer다음은 최소성인데, 이런 경우를 생각해볼 수 있다.유일성만 따졌을 때 (이름, 전공)과 (이름, 전공, 학년) 조합은 똑같이 유일한 조합이지만, 이미 (이름, 전공)이 정답리스트에 포함되어 있다면 (이름, 전공, 학년)을 고려할 필요가 없다.따라서 이 경우를 체크하는 함수를 정의해준다. 필요한 것은 체크할 인덱스 조합셋과, 이미 등록되어 있는 인덱스 조합셋 리스트이다.def check_minimality(index_set, registered_index_sets): # 1-2 passdef get_unique_column_index_sets(relation, columns, no_of_cols): passdef solution(relation): answer = [] return answer2. 주어진 함수 사용우선 유효한 인덱스 조합셋을 저장할 리스트와 컬럼 인덱스 리스트를 생성한다.def solution(relation): registered_index_sets = [] columns = [i for i in range(len(relation[0]))]그 후에 조합할 컬럼 갯수 1개부터 모든 컬럼의 갯수까지 순회하며 아래의 과정을 거쳐 릴레이션을 체크한다. 컬럼 갯수별로 유니크한 컬럼 인덱스 조합 리스트를 생성한다. 이 컬럼 인덱스 조합들의 최소성을 체크하고 유효하면 정답에 넣는다.def solution(relation): registered_index_sets = [] columns = [i for i in range(len(relation[0]))] for no_of_cols in range(1, len(columns)+1): index_sets = get_unique_column_index_sets(relation, columns, no_of_cols) # 2-1 for index_set in index_sets: is_valid = check_minimality(index_set, registered_index_sets) # 2-2 if is_valid: registered_index_sets.append(index_set) return len(registered_index_sets)3. 함수 구현 - 유니크 인덱스 셋유니크 인덱스를 만들기 위해 이런 형태의 dictionary를 만드려고 한다.{ &quot;(0, 1)&quot;: [ [100, &quot;ryan&quot;], [200, &quot;apeach&quot;] ], &quot;(2, 3)&quot;: [ [&quot;music&quot;, 2], [&quot;math&quot;, 2] ]}key는 인덱스의 조합, value는 튜플의 해당 인덱스의 value 조합이다.우선 default value를 set으로 가지는 defaultdict를 만들어준다from collections import defaultdictdef get_unique_column_index_sets(relation, columns, no_of_cols): index_dict = defaultdict(set) # 3-1파이썬의 내장 라이브러리 combinations(iterable, r)는 배열과 갯수를 집어넣으면 조합을 만들어 반환한다. 이를 이용해 모든 인덱스 조합을 만든다.ex) combinations([1, 2, 3, 4, 5], 2) = [(1, 2), (1, 3), ...]from itertools import combinationsfrom collections import defaultdictdef get_unique_column_index_sets(relation, columns, no_of_cols): index_dict = defaultdict(set) for index_comb in combinations(columns, no_of_cols): # 3-2 pass인덱스 조합별로 릴레이션의 튜플의 인덱스에 해당하는 값을 꺼내 index_dict에 넣는다.파이썬에서 hashable한 것은 tuple(()) 뿐이므로 list([]) 형태로 바로 넣어주지 않고 tuple() 생성자를 통해 list를 tuple로 바꿔서 넣어준다.from itertools import combinationsfrom collections import defaultdictdef get_unique_column_index_sets(relation, columns, no_of_cols): index_dict = defaultdict(set) for index_comb in combinations(columns, no_of_cols): for tuple_ in relation: value_comb = tuple([tuple_[index] for index in index_comb]) # 3-3 index_dict[index_comb].add(value_comb) # 3-3index_dict에 들어 있는 value set 중 원래 릴레이션의 튜플의 갯수와 같은 인덱스 조합이 있다면 이를 set의 형태로 리스트를 만들어 반환한다.from itertools import combinationsfrom collections import defaultdictdef get_unique_column_index_sets(relation, columns, no_of_cols): index_dict = defaultdict(set) for index_comb in combinations(columns, no_of_cols): for tuple_ in relation: value_comb = tuple([tuple_[index] for index in index_comb]) index_dict[index_comb].add(value_comb) return [set(indexes) for indexes, values in index_dict.items() if len(values) == len(relation)] # 3-44. 함수 구현 - 최소성 체크파라미터로 받은 index_set과 registered_index_set의 교집합이 registered_index_set과 같다면 index_set은 이미 index_set은 이미 체크가 된 것이다.index_set이 registered_index_set보다 덩치가 큰 경우def check_minimality(index_set, registered_index_sets): for registered_index_set in registered_index_sets: # 4-1 if (index_set &amp;amp; registered_index_set) == registered_index_set: return False return TrueComment하루 만에 안 풀려서 진짜 몇 일에 걸쳐서 고민했던 문제였다다른거 하다가 생각나면 다시 풀어보고 안 되면 잠깐 냅두고 또 다른거 하고..코딩테스트에서 풀었다면 아마 난 이 문제를 바로 틀렸겠지뭔가 아이디어는 떠오르는데 구현이 잘 안 되었던 문제였던 것 같고, 풀이도 가독성이 그렇게 좋아보이지는 않아서 너무 아쉽다. 추후에 리팩토링을 하던 다른 아이디어로 풀어보던지 해야할 것 같다." }, { "title": "(프로그래머스) 연습문제 - 구명보트", "url": "/posts/life-boat/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 그리디, 투포인터", "date": "2022-03-07 11:17:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/42885Introduction그리디 알고리즘 문제는 쌀 가마니에서 어떤 ‘되’를 사용하여 다른 용기로 옮겨 담는 이미지가 떠오른다.이 광경은 그리디 알고리즘의 두 가지 조건인 대부분 탐욕스런 선택 조건(greedy choice property)과 최적 부분 구조 조건(optimal substructure)을 보여준다. 탐욕스런 선택 조건: 앞의 선택이 이후의 선택에 영향을 주지 않는다. 한 되를 퍼서 옮기고 빈 되가 되면 다시 또 한 되를 퍼낼 수 있다. 최적 부분 구조 조건: 문제에 대한 최적해가 부분문제에 대해서도 역시 최적해이다. 한 되, 한 되를 가장 많이 퍼낼 수 있어야 전체적으로 가장 빠르게 원하는 만큼을 옮겨 담을 수 있다. 1번 조건의 경우는 기존의 연산 결과가 현재의 연산 결과에 영향을 미치는 DP와는 완전히 반대되는 느낌이다.Note while 문이 끝나고 체크되지 않은 보트 하나를 잊지 말 것Solutiondef solution(people, limit): answer, boat = 0, 0 left, right = 0, len(people)-1 people.sort() while left &amp;lt;= right: if people[right] + boat &amp;lt;= limit: boat += people[right] right -= 1 elif people[left] + boat &amp;lt;= limit: boat += people[left] left += 1 else: answer += 1 boat = 0 return answer+11. 필요한 변수 정의투 포인터로 문제를 풀거라 포인터 2개와 사람을 태울 보트가 필요하다.def solution(people, limit): answer, boat = 0, 0 left, right = 0, len(people)-12. Greedy우선 누가 무겁고 가벼운지를 알기 위해 무인도에 있는 사람들을 몸무게 순으로 일렬로 세운다.def solution(people, limit): answer, boat = 0, 0 left, right = 0, len(people)-1 people.sort() # 2-1어떤 공간에 물건을 배치할 때 보통 큰 물건부터 배치하고 작은 물건은 남은 공간에 테트리스 하듯이 배치한다.그리고 이 방식은 공간을 효율적으로 사용할 수 있는 방법으로서 많은 사람들이 이미 체화한 방법이다.이걸 이번 풀이에도 적용해보자. 보트에 더 사람을 태울 수 없을 때는 보트를 보내서 보트를 비워준 후 정답 카운트를 1개씩 올려준다.def solution(people, limit): answer, boat = 0, 0 left, right = 0, len(people)-1 people.sort() while left &amp;lt;= right: # 2-2 if people[right] + boat &amp;lt;= limit: boat += people[right] right -= 1 elif people[left] + boat &amp;lt;= limit: boat += people[left] left += 1 else: answer += 1 boat = 0while 문이 끝나는 조건은 left나 right가 움직여서 left가 right보다 더 커질 때이다.즉, else문으로 들어간 뒤 while문을 빠져나가는 경우는 없기 때문에 마지막에 무조건 boat에는 누군가 타 있고 이 사람들은 카운트 되지 않은 상태이다.따라서, 이 사람들을 마지막으로 카운트 해준다.def solution(people, limit): answer, boat = 0, 0 left, right = 0, len(people)-1 people.sort() while left &amp;lt;= right: if people[right] + boat &amp;lt;= limit: boat += people[right] right -= 1 elif people[left] + boat &amp;lt;= limit: boat += people[left] left += 1 else: answer += 1 boat = 0 return answer+1 # 2-3Comment그리디 알고리즘에서는 옮겨 담을 쌀과 되가 어떤 것인지를 명확히 하는 것이 중요한 것 같다. 그리고 담을 때 부피가 큰 것 부터 담는다는 것 정도?" }, { "title": "(프로그래머스) 월간 코드 챌린지 시즌3 - n^2 배열 자르기", "url": "/posts/slicing-n-square-array/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 월간 코드 챌린지", "date": "2022-03-04 17:43:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/87390Introduction생각하는 것이 귀찮았던 나는 범위 내에서 하나 하나 체크한 다음에 정답리스트에 넣는 순진한 방식으로 구현했고, 시간초과가 났다. (n이 천만이나 되는걸 확인도 안함)결국 배열에 매겨진 숫자의 특성을 파악하여 문제를 푸는 방식으로 바꿨더니 문제가 해결되었다.Note n이 커서 최악의 케이스에서 O(n)이 나오면 시간 초과가 난다. 프로그래머스의 문제인건지 큰 숫자가 파라미터로 오면 런타임 에러가 나므로 int로 형변환 해줄 것Solutiondef solution(n, left, right): return [max(no%n, no//n)+1 for no in range(int(left), int(right)+1)]1. Brute Force생각하기 귀찮을 땐 머리 비우고 Brute Force가 짱이다! 우선 배열을 전부 순회해 보자def solution(n, left, right): answer = [] for y in range(n): for x in range(n): # 1-1 pass return answer주어진 2^n 배열을 자세히 보니 x나 y 중 더 큰 Index에 1을 더한 값이 그 위치의 값이다. 이 값을 정답에 넣어주면 된다.def solution(n, left, right): answer = [] for y in range(n): for x in range(n): value = max(x, y) + 1 # 1-2 answer.append(value) return answer근데 값을 다 넣을 수는 없으니까, 범위 안에 있을 때만 값을 넣도록 바꿔보자. 우선 배열을 1차원 배열로 바꿔서 넘버링 해보자.넘버링을 하는 규칙은 y의 인덱스가 하나 올라갈 때마다 n씩 값이 더해지고 거기에 x의 값을 더하면 된다.y가 몇 층인지, x가 몇 번째인지 생각하면 된다.따라서 번호의 넘버링은 x + n*y로 계산할 수 있다. 이걸 적용해주자. 이 숫자가 right를 넘어가면 더 이상 체크할 필요가 없으므로 순회를 종료한다. 현재 넘버링이 left와 right 사이에 있으면 정답에 추가한다.def solution(n, left, right): answer = [] for y in range(n): for x in range(n): no = x + n * y if right &amp;lt; no: return answer elif left &amp;lt;= no &amp;lt;= right: value = max(x, y) + 1 answer.append(value) return answer오잉? 시간초과가 난다. 이상해서 문제를 다시 보니 n이 천만……2. Fun하고 Cool하고 Sexy하게 풀기1번의 풀이의 경우 if문을 체크하기 위해 no = x + n * y라는 연산을 한 번 더 하기 때문에 예상했던 것 보다는 좀 더 느리다.아까 현재 위치의 값을 구하는 방법은 x나 y중 큰 수 + 1이라고 했는데, 넘버링된 숫자로도 비슷하게 구할 수 있을까?우선 그림을 다시 가져와서 살펴보니 n = 3인 정사각형일 때,x의 경우 0, 1, 2가 계속 반복 된다. 즉, x = no % n인 것을 알 수 있다.y의 경우 3번에 한 번씩 값이 올라간다. 즉, y = no // n인 것을 알 수 있다.이를 토대로 다시 구현해 보자. left부터 right까지의 no를 가지고 x, y를 계산해 value를 구해서 바로 리스트로 만들어 반환했다.def solution(n, left, right): return [max(no%n, no//n)+1 for no in range(left, right+1)]이 놈의 지긋지긋한 런타임 에러…지난 포스팅처럼 또 큰 숫자를 그대로 썼다고 에러나는건가? 파라미터로 받은 숫자를 다루기 전에 int로 형변환 시켜주자.def solution(n, left, right): return [max(no%n, no//n)+1 for no in range(int(left), int(right)+1)]Comment문제의 입출력 예에 굉장히 직관적이고 알기 쉬운 애니메이션이 있어서 정말 흥미롭게 봤던 것 같다. 프로그래머스팀의 진심을 알 수 있는 문제였다" }, { "title": "(프로그래머스) 월간 코드 챌린지 시즌2 - 2개 이하로 다른 비트", "url": "/posts/two-different-bits/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 월간 코드 챌린지", "date": "2022-03-03 15:09:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/12913Introduction일반적인 코딩은 사람이 읽을 수 있는 스토리가 담긴 대화지만, 비트 연산은 컴퓨터와의 대화와 가깝다.프로그래머는 컴퓨터와도 대화를 할 수 있어야 하는 직업임에도 불구하고 비트 연산이 약했던 나는 이번 문제를 푸는데에 엄청나게 많은 시간을 허비했다Note 비트 연산할 때 자바스크립트나 파이썬과 같이 long long 타입 등 큰 숫자를 다루는 타입이 없는 언어는 에러가 나는 경우가 있으므로 주의Solutiondef solution(numbers): answer = [] for no in numbers: no = int(no) if no % 2 == 0: answer.append(no+1) continue rightmost_zero = (no+1) &amp;amp; ~no next_one = rightmost_zero &amp;gt;&amp;gt; 1 no = no ^ rightmost_zero ^ next_one answer.append(no) return answer1. 케이스 나누기우선 숫자를 1부터 2진수로 쭉 나열해보자1 -&amp;gt; 1 (2)2 -&amp;gt; 10 (2)3 -&amp;gt; 11 (2)4 -&amp;gt; 100 (2)5 -&amp;gt; 101 (2)6 -&amp;gt; 110 (2)...여기서 짝수만 골라보면 당연한 얘기지만 다 0으로 끝난다.2 -&amp;gt; 10 (2)4 -&amp;gt; 100 (2)6 -&amp;gt; 110 (2)여기서 1을 더한다면?2 -&amp;gt; 10 (2) : 3 -&amp;gt; 11 (2)4 -&amp;gt; 100 (2) : 5 -&amp;gt; 101 (2)6 -&amp;gt; 110 (2) : 7 -&amp;gt; 111 (2)오잉? 짝수의 경우는 손쉽게 문제가 해결된다. 달라진 비트가 딱 1개이면서 기존의 수보다 더 크다.그럼 홀수의 경우는 어떨까? 대충 151이라는 숫자를 가져와 본다. 이 숫자를 이진수로 바꾸면 아래와 같은 느낌이다. (절대로 뮤 스티커 안 나와서 이러는거 아님)151 -&amp;gt; 10010111 (2)여기도 일단 1을 더해볼까?152 -&amp;gt; 10011000 (2)기존 숫자보다 커지긴 했는데 달라진 비트 수가 4개이다.(1001 1000 ) 이걸 2개 이하로 맞추려면 가장 오른쪽에서 첫 번째와 두 번째 비트를 1로 바꿔야 한다.155 -&amp;gt; 10011011 (2)(기존 숫자: 151 -&amp;gt; 10010111 (2))151 -&amp;gt; 10010111 (2)155 -&amp;gt; 10011011 (2)Hoxy?다른 숫자도 해볼까? 559를 가져와 1을 더해봤다.559 -&amp;gt; 1000101111 (2)560 -&amp;gt; 1000110000 (2)그리고 다른 비트의 수를 2개 까지로 맞추기 위해 뒤쪽의 0을 전부 1로 바꿔주면…559 -&amp;gt; 10001`01`111 (2)567 -&amp;gt; 10001`10`111 (2)패턴이 보인다. 가장 오른쪽의 0, 그 바로 오른쪽의 1, 이 2개를 전부 토글해주면 된다.2. 구현우선 짝수의 경우는 원래 숫자에 1을 더해서 정답 리스트에 넣어준다.def solution(numbers): answer = [] for no in numbers: if no % 2 == 0: answer.append(no+1) # 2-1홀수는 가장 오른쪽 0의 자리와 그 바로 오른쪽에 위치한 1의 자리를 찾는다.어떤 숫자의 가장 오른쪽에 위치한 비트의 위치를 찾는 법과 토글하는 법은 Bitwise Operation &amp;amp; Bitmask를 참고def solution(numbers): answer = [] for no in numbers: if no % 2 == 0: answer.append(no+1) continue rightmost_zero = (no+1) &amp;amp; ~no # 2-2 next_one = rightmost_zero &amp;gt;&amp;gt; 1 # 2-2찾았으면 토글해주고 정답리스트에 넣는다.def solution(numbers): answer = [] for no in numbers: if no % 2 == 0: answer.append(no+1) continue rightmost_zero = (no+1) &amp;amp; ~no next_one = rightmost_zero &amp;gt;&amp;gt; 1 no = no ^ rightmost_zero ^ next_one # 2-3 answer.append(no) # 2-3 return answer근데 7, 8, 9번의 케이스에서 런타임 에러가 난다.테스트 케이스 안에 포함된 엄청 큰 숫자(long long 정도 되는)를 NOT 연산할 때 문제가 생기는 것 같다. (다른 행동을 하지 않고 그냥 for문 돌면서 NOT 연산만 해도 런타임 에러가 발생한다.)신기한건 다른 언어로 하면 에러가 안 난다는 점이다.#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;long long&amp;gt; solution(vector&amp;lt;long long&amp;gt; numbers) { vector&amp;lt;long long&amp;gt; answer; for (long long no : numbers) { if (no % 2 == 0) { answer.push_back(no+1); continue; } long long rightmost_zero = (no+1) &amp;amp; ~no; long long next_one = rightmost_zero &amp;gt;&amp;gt; 1; no = no ^ rightmost_zero ^ next_one; answer.push_back(no); } return answer;}시험삼아 Python Console을 켜고 C++ long long 타입의 상한 숫자 9,223,372,036,854,775,807에다가 10을 곱한 수를 NOT 연산 해봤는데도 문제가 일어나지 않았다.아무래도 numbers의 길이가 MAX이면서 엄청나게 큰 숫자들만 계속 다루다 보면 메모리를 할당하다가 에러가 나는 것 같다.이를 해결하기 위해 숫자를 다루기 전에 int로 형변환 해주면 해결이 된다는데 도무지 알 수가 없는 미스테리…(문제의 질문하기란에 질문을 남겼는데 누군가가 이것을 해결하는 방법은 제시해주셨지만 왜 이렇게 되는지 이유를 설명해주는 사람은 아무도 없었다.)def solution(numbers): answer = [] for no in numbers: no = int(no) # 2-4 if no % 2 == 0: answer.append(no+1) continue rightmost_zero = (no+1) &amp;amp; ~no next_one = rightmost_zero &amp;gt;&amp;gt; 1 no = no ^ rightmost_zero ^ next_one answer.append(no) return answerComment비트 연산 넘모 어려운 것…근데 웹 개발하면서 비트 연산을 쓰는 경우는 많이 못 본 것 같다. 아무래도 가독성의 문제 때문이려나?아니면…이런건가?" }, { "title": "Bitwise Operation &amp; Bitmask", "url": "/posts/bitwise-bitmask/", "categories": "프로그래밍, 기초", "tags": "Bitwise, Bitmask", "date": "2022-03-01 18:59:00 +0900", "snippet": "Introduction일반적인 코딩은 사람이 읽을 수 있는 스토리가 담긴 대화지만, 비트 연산(Bitwise Operation)은 컴퓨터와의 대화에 가깝다.프로그래머는 컴퓨터와도 대화를 할 수 있어야 하는 직업임에도 불구하고 나는 비트 연산의 응용에 약해서 이번 기회에 정리해두기로 했다.Bitwise Operation아무래도 컴퓨터가 다루는 이진수의 비트를 직접 조절하기 때문에 비트 연산은 속도가 굉장히 빠르다.int remainder = value % divisor나눗셈에서 divisor(나누는 수; 제수)가 2의 n승인 경우 divisor-1과 AND 연산자(&amp;amp;)를 통해 나머지를 구할 수 있는데, 이를 이용해 일반 연산과 비트 연산의 속도차이를 측정할 수 있다.// 아래의 두 연산은 같은 결과값이 나온다.int remainder = value % 1024;int remainder = value &amp;amp; 0x3FF; // 0x3FF = 1024 - 1 = 1023% 연산과 &amp;amp; 연산의 수행시간 차이 by Marco Ziccardi두 연산의 수행속도는 위의 그래프와 같이 약 2배 가량 차이가 나는데, 이는 엄청난 차이이다.Bitmask비트 연산이 속도가 빠르다는건 알겠는데, 보통 어떤 때에 쓰이는걸까?Bitwise는 주로 Bitmask의 형태로 사용이 된다.Bitmask는 쉽게 말해 숫자를 이진수로 바꿨을 때 나오는 각각의 비트를 0을 off 상태, 1을 on 상태로 보고 이를 스위치처럼 껐다켰다 하면서 정보를 저장하는 형태를 말한다.예를 들어, 숫자 8의 경우 이진수 1000(2)로 표현할 수 있는데, 이는 스위치 4개를 가지고 있으면서 1번째 스위치 하나만 켜지고 나머지 3개의 스위치가 꺼졌다고 보면 된다.Bitmask를 이용하여 RGB 값을 저장 및 추출이를 통해 최대한 지연시간이 적어야 하면서 실시간으로 엄청나게 많은 연산이 필요한 모니터의 RGB 색상값을 표현한다.SDL 2.0 키보드의 키코드 헤더 파일또 다른 경우로는 동시에 입력값을 기억하고 처리해야 하는 키보드 조합키(modifier), 조이패드 버튼 키코드 등에 Bitmask를 사용한다.Basic OperationAND 연산 (&amp;amp;) 대응하는 숫자가 전부 1일 경우 1을 반환int a = 237; // 11101101int b = 221; // 11011101int c = a &amp;amp; b; // 11001101OR 연산 (|) 대응하는 숫자 중 하나라도 1일 때 1을 반환int a = 237; // 11101101int b = 221; // 11011101int c = a | b; // 11111101XOR 연산 (^) 대응하는 숫자가 다를 경우 1을 반환int a = 237; // 11101101int b = 221; // 11011101int c = a ^ b; // 110000NOT 연산 (~) 비트를 반전시킴 주의: 파이썬에서는 integer가 signed integer로 동작하는데, 이 연산 후에 bin() 함수 등으로 숫자를 표기하면 값이 생각했던거랑 다르게 찍힌다. (연산은 잘 된다. 표기만 좀 다르게 나올 뿐이지) [참고: Bitwise Operators in Python] 예) ~0b10101001 -&amp;gt; -0b10101000 주의: OR연산과 NOT연산은 같이 쓰지 말 것. OR연산을 하기 위해 4 = 100(2)같이 비트가 하나만 있고 나머지는 다 0으로 채워진 숫자에서 3 = 011(2)를 만들고 싶다면 비트를 반전시킬게 아니라 100(2)에서 1을 빼주자. 4 = 100(2)의 비트를 반전시키면 3 = 011(2)이 아니라 -5가 되어서 OR 연산 시에 마이너스 부호의 비트까지 들어가 버린다. 참고: The meaning of Bit-wise NOT in Python (링크는 python에 대한 설명이지만 C++도 Java도 동일하다. 아마 모든 언어가 다 그럴듯.) int a = 237; // 11101101int c = ~a; // 00010010SHIFT 연산 («, ») 비트를 한 칸씩 민다. &amp;lt;&amp;lt;로 밀 경우 가장 오른쪽에 0을 채우고, &amp;gt;&amp;gt;로 밀 경우 가장 오른쪽 비트는 유실된다. &amp;lt;&amp;lt; 연산의 경우 *2연산과 같고, &amp;gt;&amp;gt;의 경우 /2연산과 같다. int a, b, c;a = 237; // 11101101b = a &amp;lt;&amp;lt; 1; // 111011010b = a * 2; // 111011010c = a &amp;gt;&amp;gt; 2 // 111011c = a / 4 // 111011Operation Techniques비트 조회 n번째 비트가 1인지 아닌지를 조회(결과 값이 0이면 없고, 1 이상이면 있는 것)int n = 3;int a = 233; // 11101001int c = a &amp;amp; (1 &amp;lt;&amp;lt; n); // 1000비트 설정 n번째 비트에 1을 설정int n = 2;int a = 233; // 11101001int c = a | (1 &amp;lt;&amp;lt; n); // 11101101비트 제거 n번째 비트의 1을 제거int n = 3;int a = 233; // 11101001int c = a &amp;amp; ~(1 &amp;lt;&amp;lt; n); // 11100001비트 토글 n번째 비트를 뒤집는다.int n = 2;int a = 233; // 11101001int c = a ^ (1 &amp;lt;&amp;lt; n); // 11101101Advanced Techniques가장 오른쪽의 0 위치 획득int a = 233; // 11101001int c = (a+1) &amp;amp; ~(a); // 10가장 오른쪽에 설정된 1 위치 획득int a = 232; // 11101000int c = a &amp;amp; ~(a-1); // 1000가장 오른쪽에 설정된 1 제거int a = 232; // 11101000int c = a &amp;amp; (a-1); // 11100000Comment예전부터 정리해야지 해야지 해놓고 이제야 정리를 하게 됐다..비트 조작은 익숙해지면 강력한 도구이지만, 너무 어렵기도 하고 가독성이 별로 좋지 않아 사용에 주의가 필요하다.일단 뼈대만 만들고 내용을 추후에 조금씩 더 추가할 예정이다.References https://mziccard.me/2015/05/08/modulo-and-division-vs-bitwise-operations/ https://www.researchgate.net/figure/RGB-Color-Images-The-Figure8-shows-how-to-find-the-RGB-value-decomposition-of-a-32-bit_fig6_325568402 https://github.com/libsdl-org/SDL https://justkode.kr/algorithm/bitmash https://www.geeksforgeeks.org/turn-off-the-rightmost-set-bit/" }, { "title": "(프로그래머스) 연습문제 - 땅따먹기", "url": "/posts/land-taking/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 연습문제, 다이나믹 프로그래밍", "date": "2022-02-25 15:49:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/12913Introduction이전의 연산 결과를 기억하면서 그 결과를 가지고 연산을 계속해나간다는 DP(다이나믹 프로그래밍)의 개념을 이해 못해서 굉장히 고생했었던 기억이 있다.아무래도 처음 접했던 DP 문제들이 너무 난이도가 높아서 DP 자체에 집중하여 학습하기 보다는 문제가 주는 복잡함에 압도되어서 정신이 없어서 그랬던 것 같다.이 문제는 간단하면서도 전형적인 DP 문제로 DP의 개념을 익히는데 좋을 입문용 문제라고 생각한다.Note 연속으로 같은 열을 밟을 수 없다는 규칙에 주의Solutiondef solution(land): for row in range(1, len(land)): prev_row = land[row-1] land[row][0] += max(prev_row[1], prev_row[2], prev_row[3]) land[row][1] += max(prev_row[0], prev_row[2], prev_row[3]) land[row][2] += max(prev_row[0], prev_row[1], prev_row[3]) land[row][3] += max(prev_row[0], prev_row[1], prev_row[2]) return max(land[-1])1. 어떻게 이동해 나갈 것인가시작점에서 출발해 모든 경우를 고려하는 것도 문제를 해결할 수 있는 방법이겠지만, 더 효율적인 방법이 있다. 바로 점수의 합계가 최고점이 될 수 있는 경우만 고민하며 전진하는 것이다.한 칸 전진한 후가 가장 최고점인 경우만 고려하면서 가보자.우선 두 번째 행의. 두 번째 행의 첫 번째 열의 값이 최대값이 되기 위해서는 그 이전 열에서 가장 큰 점수와 현재 점수를 더한 점수여야 한다. 이 때 같은 열은 두 번 연속으로 못 밟으므로 첫 번째 열은 후보에서 제외하고 생각한다.두번째 행도 마찬가지로 현재 점수와 이전 열에서의 최대값을 더한게 최대값이다.def solution(land): row = 1 prev_row = land[row - 1] land[row][0] += max(prev_row[1], prev_row[2], prev_row[3]) land[row][1] += max(prev_row[0], prev_row[2], prev_row[3]) land[row][2] += max(prev_row[0], prev_row[1], prev_row[3]) land[row][3] += max(prev_row[0], prev_row[1], prev_row[2])이렇게 모든 열을 최대 점수를 구하고,def solution(land): for row in range(1, len(land)): prev_row = land[row-1] land[row][0] += max(prev_row[1], prev_row[2], prev_row[3]) land[row][1] += max(prev_row[0], prev_row[2], prev_row[3]) land[row][2] += max(prev_row[0], prev_row[1], prev_row[3]) land[row][3] += max(prev_row[0], prev_row[1], prev_row[2])두 번째 행부터 마지막 행까지 모든 최고점수를 구한다.그러면 가장 마지막 행에서 가장 큰 값이 최고점이다.def solution(land): for row in range(1, len(land)): prev_row = land[row-1] land[row][0] += max(prev_row[1], prev_row[2], prev_row[3]) land[row][1] += max(prev_row[0], prev_row[2], prev_row[3]) land[row][2] += max(prev_row[0], prev_row[1], prev_row[3]) land[row][3] += max(prev_row[0], prev_row[1], prev_row[2]) return max(land[-1])Comment때로는 시작점부터 하나의 길을 따라 문제를 해결해 나가는 방법이 아니라 최적의 결과값을 가지는 중간지점을 계속해서 갱신해나가는 방법이 더 간단하고 빠르게 문제를 해결하는 경우가 있다.머리로는 알고 있는데 가끔 이걸 떠올리지 못해 괜히 헤매는 경우가 많아서 문제지만.." }, { "title": "(프로그래머스) 월간 코드 챌린지 시즌1 - 쿼드 압축 후 개수 세기", "url": "/posts/quadtree-compression/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 월간 코드 챌린지, 시즌1", "date": "2022-02-24 16:26:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/68936Introduction쿼드 트리 압축이라는걸 이번 문제를 풀면서 처음 알게 되었는데, 뭔가 예전에 학교 수학시간에 배웠었던 어떤 그림이 떠오른다.이런거재귀함수에 대해서 모르는 사람이라도 문제를 재귀적으로 해결하면 되겠다고 감각적으로 알 수 있는 문제이다.우리가 테트리스 게임을 처음 해보더라도 어떤식으로 플레이할지 바로 알 수 있듯이 그냥 문제 자체가 보자마자 알 수 있는 THE 재귀문제 라는 느낌.다만 이걸 어떻게 구현할지에 대해서 조금 머릿속이 복잡해져서 살짝 헤매긴 했지만 귀찮다라고 느꼈지 어렵다라고 느끼진 않은 문제였다.Note 압축 가능한지 체크 하고 분할하는게 더 효율적이다. 분할 시에 고정된 좌표와 움직이는 좌표를 구분하며 구현한다.Solutiondef count_zero_and_one(arr, x1, y1, x2, y2): result = [0, 0] for y in range(y1, y2): for x in range(x1, x2): result[arr[y][x]] += 1 return resultdef check_if_compressible(arr, x1, y1, x2, y2): zero, one = count_zero_and_one(arr, x1, y1, x2, y2) n = (x2 - x1) * (y2 - y1) return zero == n or one == ndef split(x1, y1, x2, y2): MID_X, MID_Y = x1 + (x2 - x1) // 2, y1 + (y2 - y1) // 2 areas = [ [x1, y1, MID_X, MID_Y], [MID_X, y1, x2, MID_Y], [x1, MID_Y, MID_X, y2], [MID_X, MID_Y, x2, y2] ] return areasdef f(arr, x1, y1, x2, y2): result = [0, 0] compressible = check_if_compressible(arr, x1, y1, x2, y2) if compressible: result[arr[y1][x1]] += 1 return result areas = split(x1, y1, x2, y2) for area in areas: zero, one = f(arr, *area) result[0] += zero result[1] += one return resultdef solution(arr): return f(arr, 0, 0, len(arr), len(arr))1. 필요한 함수들 정의여기 이 4X4 사각형에서 점이 찍힌 두 좌표 (x1, y1) = (0, 0)와 (x2, y2) = (4,4) 사이에 있는 사각형들을 체크해나갈건데, 필요한 행동을 3가지 정도로 정리해봤다. 사각형 안의 숫자들을 전부 센다. 사각형 안의 숫자들이 압축 가능한지 판별한다. 사각형을 4분할로 나눈다.def count_zero_and_one(arr, x1, y1, x2, y2): passdef check_if_compressible(arr, x1, y1, x2, y2): passdef split(x1, y1, x2, y2): passdef solution(arr): answer = [] return answer그리고 어떻게 구성될지는 모르겠지만 배열과 사각형의 범위를 넣어주면 그 범위 안에서 압축도 알아서 하고 아무튼 숫자를 다 체크해서 반환해주는 마법의 함수 f()를 정의한다.def count_zero_and_one(arr, x1, y1, x2, y2): passdef check_if_compressible(arr, x1, y1, x2, y2): passdef split(x1, y1, x2, y2): passdef f(arr, x1, x2, y1, y2): passdef solution(arr): return f(arr, 0, 0, len(arr), len(arr))2. 숫자를 세는 함수 구현result 리스트에서 0번째 인덱스에는 0의 개수, 1번째 인덱스에는 1의 개수 이므로 해당 좌표의 값을 인덱스로 해서 개수를 하나씩 세면 깔끔한 코딩이 가능하다.def count_zero_and_one(arr, x1, y1, x2, y2): # 2 result = [0, 0] for y in range(y1, y2): for x in range(x1, x2): result[arr[y][x]] += 1 return result3. 사각형이 압축가능한지 판별좌표 범위 안에 있는 n개의 사각형과 0의 개수 혹은 1의 개수가 완벽하게 똑같으면 압축이 가능하다.def check_if_compressible(arr, x1, y1, x2, y2): # 3 zero, one = count_zero_and_one(arr, x1, y1, x2, y2) n = (x2 - x1) * (y2 - y1) return zero == n or one == n4. 분할4X4 정사각형을 실제로 분할해서 생각해보자우선 편의상(원래 수학에서 1~4사분면은 저 순서 아니다) 이렇게 1~4사분면으로 나누고, 1사분면부터 생각해보자.압축을 계속 하다보면 알 수 있겠지만, 점을 찍은 곳의 좌표(x1, y1) = (0, 0)는 변하지 않고 x2, y2만 변한다.2사분면은 어떨까? 점 찍은 곳의 좌표(x2, y1) = (4, 0)는 변하지 않고 x1, y2만 변한다.줄어들 때 변하는 좌표의 값은 중간값으로 변한다. 이를 코드로 표현해준다.def split(x1, y1, x2, y2): MID_X, MID_Y = x1 + (x2 - x1) // 2, y1 + (y2 - y1) // 2 areas = [ [x1, y1, MID_X, MID_Y], [MID_X, y1, x2, MID_Y], [x1, MID_Y, MID_X, y2], [MID_X, MID_Y, x2, y2] ] return areas5. 함수 f() 구현 그리고 어떻게 구성될지는 모르겠지만 배열과 사각형의 범위를 넣어주면 그 범위 안에서 압축도 알아서 하고 아무튼 숫자를 다 체크해서 반환해주는 마법의 함수 f()그리고 어떻게 구성될지는 모르겠지만 배열과 사각형의 범위를 넣어주면 그 범위 안에서 압축도 알아서 하고 아무튼 숫자를 다 체크해서 반환해주는 마법의 함수 f()의 구현에 대한 대략적인 아이디어는 이렇다. 압축 가능한지 체크한다. (크기 1의 사각형까지 쪼개진 경우 압축이 가능한것으로 판단한다.) 압축이 안되면 4분할 한다. 분할한 구역들별로 전부 다 사각형의 숫자를 세서 result에 더하고 반환한다.우선 압축이 되는지를 체크해보고 되면 범위 내의 사각형들 중 첫번째 사각형의 숫자를 result에 더하고 result를 반환한다.def f(arr, x1, y1, x2, y2): result = [0, 0] compressible = check_if_compressible(arr, x1, y1, x2, y2) if compressible: # 5-1 result[arr[y1][x1]] += 1 return result만약 우리가 체크할 사각형이 아래와 같은 사각형만 있다면 이걸로 끝나겠지만 안타깝게도 그렇진 않다.따라서, 압축이 불가능한 경우는 4분할 해준다.def f(arr, x1, y1, x2, y2): result = [0, 0] compressible = check_if_compressible(arr, x1, y1, x2, y2) if compressible: result[arr[y1][x1]] += 1 return result areas = split(x1, y1, x2, y2) # 5-2분할한 사분면별로 다시 체크해서 0과 1의 개수를 세온다. 그리고 어떻게 구성될지는 모르겠지만 배열과 사각형의 범위를 넣어주면 그 범위 안에서 압축도 알아서 하고 아무튼 숫자를 다 체크해서 반환해주는 마법의 함수 f()를 사용한다.(*area는 x1, y1, x2, y2 타이핑 다시 하기 귀찮아서 저렇게 그대로 넣어줬다.)def f(arr, x1, y1, x2, y2): result = [0, 0] compressible = check_if_compressible(arr, x1, y1, x2, y2) if compressible: result[arr[y1][x1]] += 1 return result areas = split(x1, y1, x2, y2) for area in areas: # 5-3 zero, one = f(arr, *area) result[0] += zero result[1] += one return resultComment처음에 구현할 때 형태를 보고 오 재귀적인 구성? 재귀 = 나눈다?로 생각이 먼저 들어서 나누는거 먼저 구현하다가 테스트 케이스 10번만 자꾸 틀리길래 압축 가능한지를 먼저 체크하도록 로직을 바꾸니 문제가 깔끔하게 해결되었다.무슨 일이든 역시 서순은 정말 중요한듯.." }, { "title": "(프로그래머스) 월간 코드 챌린지 시즌1 - 삼각 달팽이", "url": "/posts/triangle-snail/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 월간 코드 챌린지, 시즌1", "date": "2022-02-23 12:31:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/68645Introduction수학에 대해 이해를 잘못하고 있는 걸지도 모르겠지만, 내가 생각하기에 수학은 어떤 규칙들과 논리들이 서로 맞물려 있고 이를 토대로 절대적인 답이 정해져 있다.세상을 살면서 벌어지는 모든 일들에는 절대적인 게 없는데, 유독 수학의 세계는 변함이 없는 엄격함이 적용되어서 신기하기도 했지만 어릴 적에는 그게 이해가 잘 안 됐었다. 어떻게 그런 신기한 일이 벌어질 수 있는 거지? 수학에는 예외라는 게 없나?수학을 사용하는 입장에서는 예외가 없이 언제나 동일하게 적용되는 것만큼 안정적인 것도 없다. 그저 규칙을 찾고, 그 규칙을 가지고 문제를 해결하기만 하면 되니까Note 숫자를 채워 나가는 부분을 3파트로 나눈다. 파트별로 채워 나가는 숫자가 1씩 줄어듬에 유의Solutionfrom functools import reducedef solution(n): answer = [[0 for _ in range(i+1)] for i in range(n)] x, y, no = 0, -1, 0 for i in range(n, 0, -3): for j in range(i): y += 1 no += 1 answer[y][x] = no for j in range(i-1): x += 1 no += 1 answer[y][x] = no for j in range(i-2): x -= 1 y -= 1 no += 1 answer[y][x] = no return reduce(lambda a, b: a+b, answer)1. 규칙을 파악삼각 달팽이는 2차원 리스트를 통해 표현할 수 있다. 그리고 반시계 방향으로 회전하면서 숫자가 채워진다.그리고 아래와 같은 규칙이 있다. 세로로 한 줄, 가로로 한 줄, 대각선 한 줄로 숫자가 차는 것이 반복 된다. n개부터 시작해서 세로는 n개, 가로는 n-1개, 대각선은 n-2개 만큼 숫자를 채우고 다음 layer에서는 n에서 3만큼(이전 layer의 세로, 가로, 대각선 줄의 갯수만큼) 빠진 숫자로 반복한다.2. 구현우선 속이 0으로 비어있는 2차원 리스트를 만들어 준다.def solution(n): answer = [[0 for _ in range(i+1)] for i in range(n)] # 2-1한 줄 한 줄 연산을 할 수 있도록 for문을 써준다. n부터 시작해서 0보다 크면 계속 반복하고, layer가 증가 될 때마다 3씩 빼준다.다음 for문 3개는 첫 번째부터 세로줄, 가로줄, 대각선 순이다.def solution(n): answer = [[0 for _ in range(i+1)] for i in range(n)] for i in range(n, 0, -3): # 2-2 for j in range(i): pass for j in range(i-1): pass for j in range(i-2): pass아래의 조건 생각하며 구현해 준다. 세로줄: y가 1씩 커짐 가로줄: x가 1씩 커짐 대각선: x와 y가 1씩 작아짐초기 값은 처음에 더할 때 x=0, y=0, no=1로 적용되도록 맞춰준다.def solution(n): answer = [[0 for _ in range(i+1)] for i in range(n)] x, y, no = 0, -1, 0 # 2-3 for i in range(n, 0, -3): for j in range(i): y += 1 no += 1 answer[y][x] = no for j in range(i-1): x += 1 no += 1 answer[y][x] = no for j in range(i-2): x -= 1 y -= 1 no += 1 answer[y][x] = no이렇게 준비된 2차원 리스트([[1], [2, 15], [3, 16, 14], …]를 1차원 리스트([1, 2, 15, 3, 16, 14, …])로 변환해주면 된다.파이썬의 경우 리스트를 더하는 연산으로 각 리스트를 쉽게 합칠 수 있으므로 더 짧게 표기가 가능했다.ex) [1] + [2] = [1, 2]from functools import reducedef solution(n): answer = [[0 for _ in range(i+1)] for i in range(n)] x, y, no = 0, -1, 0 for i in range(n, 0, -3): for j in range(i): y += 1 no += 1 answer[y][x] = no for j in range(i-1): x += 1 no += 1 answer[y][x] = no for j in range(i-2): x -= 1 y -= 1 no += 1 answer[y][x] = no return reduce(lambda a, b: a+b, answer) # 2-4Comment알고 보면 정말 쉬운데 규칙을 발견하기가 까다로웠던 문제였다.문제를 보면 긴장부터 하는 습관을 고쳐야 할듯…" }, { "title": "(프로그래머스) 2017 팁스타운 - 짝지어 제거하기", "url": "/posts/remove-pairs/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2017, 팁스타운", "date": "2022-02-22 14:25:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/12973Introduction스택은 저장하고 있는 것 위에 다른 것을 얹어서 저장하는데, 이러한 특성 덕분에 현재 다루고 있는 것을 잠시 저장해두고 다른 것으로 전환하는 식의 활용이 가능한 독특한 형태의 자료구조이다.마치 작업하고 있는 일이 있는데 끊임 없이 일을 더 갖고 오는 동료로 인해 고통받는 현대인들의 기구한 일상을 표현하고 있는것 같다. (심지어 별로 급해보이지도 않는데 그거 먼저 해달라고 한다.)이 문제는 스택이 가지는 작업의 전환의 특성을 이용한 정말 멋진 문제이다.Note 스택이 가지는 특성을 잘 이해할 것Solutiondef solution(s): stack = [] for ch in s: if stack and stack[-1] == ch: stack.pop() else: stack.append(ch) return 0 if stack else 11. 빠요엔~ 빠요엔~ 빠요엔~스택의 특징은 위에서도 언급했듯이, 현재 작업중인 상태를 저장하고 다른 작업으로 넘어간다는 것이다.이 특성을 활용해 지울 수 없는 문자들은 스택에 넣고, 지울 수 있는 타이밍이 오면 스택에서 빼는 것으로 삭제 처리를 한다.예를 들면, s = baaabaa의 경우, 아래와 같은 과정으로 문자들이 왼쪽으로 밀리며 사라져간다. 색칠된 부분은 스택에 들어가 있다는 것을 의미한다.1. b를 스택에 추가2. a를 스택에 추가하고 다음 a를 체크할 때 제거3. 다음 b를 체크하면서 스택의 b도 제거4. a를 스택에 추가하고 다음 a를 체크할 때 제거이 과정을 코드로 옮긴다. 특별한 일이 없으면 스택에 넣고, 스택에 문자가 있으면서 그 문자와 현재 문자가 같으면 스택에서 하나씩 빼는 방식이다.def solution(s): stack = [] for ch in s: if stack and stack[-1] == ch: stack.pop() else: stack.append(ch)마지막으로 스택에 무언가가 남아있다면 지워지지 않은 문자가 남아있다는 것이므로 0을 반환하고 아니면 1을 반환한다.def solution(s): stack = [] for ch in s: if stack and stack[-1] == ch: stack.pop() else: stack.append(ch) return 0 if stack else 1Comment자료구조는 모두 간단한 구조를 가지고 있고 누구나 쉽게 사용할 수 있다.누구나 스택에 대해 설명해 달라고 하면 LIFO FIFO 이런 단어들을 말할수는 있다. 책에서 보고 배웠으니까.근데 그것들의 특징을 제대로 파악하고 사용하지 않는다면, 실제 퍼포먼스의 절반도 못 쓰게 되는 것이 아닐까 하는 생각을 해본다." }, { "title": "(프로그래머스) 2017 팁스타운 - 예상 대진표", "url": "/posts/tournament-table/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2017, 팁스타운", "date": "2022-02-21 13:42:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/12985Introduction뭔가 복잡해 보이지만 의외로 가상으로 대회를 해보면 간단하게 풀리는 문제이다.Note 두 사람의 거리(번호의 차이)가 1이라고 하더라도 대결을 하지 않는 경우가 있으므로 주의Solutionimport mathdef to_next_round(order): return math.ceil(order/2)def solution(n,a,b): matching_round = 1 while n &amp;gt; 1: if abs(a-b) == 1 and to_next_round(a) == to_next_round(b): break n //= 2 matching_round += 1 a = to_next_round(a) b = to_next_round(b) return matching_round1. 1명만 남을 때까지 대결1라운드 부터 시작해서 n명의 참가자가 1명이 남을 때까지 무작위로 상대를 골라 대결을 진행해보자. 토너먼트이기 때문에 대결이 진행될 때마다 참가자는 절반씩 줄어든다.def solution(n,a,b): matching_round = 1 while n &amp;gt; 1: # 1-1 n //= 2 matching_round += 1이번엔 무작위로 하지 말고, 문제에 써져 있는 것처럼 이긴 사람을 다시 번호를 매겨서 앞 사람과 대결하게 하자.여기서 규칙을 한 번 살펴보자.1번이 이기면 다음 번호는? 1번2번이 이기면 다음 번호는? 1번3번이 이기면 다음 번호는? 2번4번이 이기면 다음 번호는? 2번5번이 이기면 다음 번호는? 3번6번이 이기면 다음 번호는? 3번...다음 라운드의 번호를 얻는 규칙은 현재 번호를 2로 나누고 반올림 한 숫자가 다음 라운드의 번호가 된다.import mathdef to_next_round(order): return math.ceil(order/2)def solution(n,a,b): matching_round = 1 while n &amp;gt; 1: n //= 2 matching_round += 1 a = to_next_round(a) # 1-2 b = to_next_round(b) # 1-22. A가 B를 만났을 때현재 대결을 하는 사람과의 특징은 번호가 1만큼 차이가 난다는 것이다. (1번과 2번, 3번과 4번)import mathdef to_next_round(order): return math.ceil(order/2)def solution(n,a,b): matching_round = 1 while n &amp;gt; 1: if abs(a-b) == 1: # 2-1 break n //= 2 matching_round += 1 a = to_next_round(a) b = to_next_round(b)하지만 여기서 또 고려해줘야 할 것이 있다. 예를 들어, 2번과 3번의 경우 대결을 하지 않지만 번호 차이가 1인데, 두 사람이 대결을 하는지 어떤지는 어떻게 알 수 있을까?대결 후 무조건 이긴다고 가정했을 때 두 사람이 다음 라운드에서 같은 번호를 가지고 있으면 된다.4번과 5번은 번호 차이가 1이지만 대결하지 않는다import mathdef to_next_round(order): return math.ceil(order/2)def solution(n,a,b): matching_round = 1 while n &amp;gt; 1: if abs(a-b) == 1 and to_next_round(a) == to_next_round(b): # 2-2 break n //= 2 matching_round += 1 a = to_next_round(a) b = to_next_round(b) return matching_roundComment처음 이 문제를 접했을 때 엄청 복잡한 문제일거라 생각하고 지레 겁을 먹었던 기억이 난다.이 문제를 일반 수학 문제처럼 나 혼자 풀어야 하는게 아니라 컴퓨터랑 같이 푼다는 사실이 정말 다행인지도 모르겠다. 나는 상황을 주고 가상 세계에서 실제로 실험해보면 되니까." }, { "title": "(프로그래머스) 위클리 챌린지 - 모음사전", "url": "/posts/vowel-dictionary/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 위클리 챌린지, 수학", "date": "2022-02-18 19:04:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/84512Introduction부제: 우리가 수학을 배워야 하는 이유대학에서 물리학을 배우던 시절 나는 같은 학과 학부생들 중에 수학을 제일 못해 친구들의 도움을 많이 받았었다.가시적으로 무언가 진전이 보이는 것이 아닌 논리만으로 모든 것이 맞물리는 수학의 세계를 이해하기엔 내 머리가 그만큼 좋지 않았던 것 같다.사람은 자신이 잘하는 것이 있으면 그것에 더 관심을 갖게 되고 더 많은 시간을 할애하며, 익숙하지 분야에까지 자신이 잘하는 분야의 방법을 적용하는 등 사고방식에까지 영향을 주며 고착화되는 경향이 있다.수학을 못했기에 논리보다는 그 수들의 연산을 행할 때 어떤 일이 일어나는지를 상상하는데 더 많은 관심을 쏟기 시작했고, 다른 사람들과는 다른 독특한 방식으로 수를 다루기 시작했다.하지만 그건 어디까지나 제대로 된 수학은 아니여서 진짜 수학을 못해 벽에 부딪히는 경우가 많았다.예를 들면 이번 문제의 경우, n이 작기 때문에 실제로 “UUUUU”까지 만들어보다가 주어진 단어와 같아지는 순간 정답을 반환해도 최대 3905번의 연산만 하면 되기 때문에 시간초과는 안난다.하지만 만약 “UUUUUUUUUUUUUUUUU”가 몇 번째 단어인지를 찾는다면?38,146,972,655번의 연산을 해야한다. 당연히 시간초과다. 하지만, 수학을 적용하면 순식간에 문제를 해결할 수 있다.수학이라는 건 이미 논리적으로 검증된 사실들을 굳이 체크하지 않고 건너뛰는 마치 메모이제이션과 같은 도구라는 생각이 든다.아, 그래서 난 어떻게 했냐고?Note 글자가 5개 미만이라면 A를 붙이고, U에서 한 글자 더 올릴 때 다음 글자가 똑같이 U라면 해당 글자를 W로 치환해둔다.SolutionWORD_TABLE = &quot;AEIOU&quot;def change_up(ch): return WORD_TABLE[WORD_TABLE.index(ch) + 1]def carry_over(word): word_list = list(word) for i in range(len(word_list)-1, -1, -1): cur_ch, prev_ch = word_list[i], word_list[i-1] if cur_ch == &#39;W&#39;: if prev_ch == &#39;U&#39;: word_list[i-1] = &#39;W&#39; else: word_list[i-1] = change_up(prev_ch) return &#39;&#39;.join(filter(lambda w: w != &#39;W&#39;, word_list))def solution(word): w, answer = &#39;A&#39;, 1 while w != word: if len(w) &amp;lt; 5: w += &#39;A&#39; elif w[-1] != &#39;U&#39;: w = w[:-1] + change_up(w[-1]) elif w[-1] == &#39;U&#39;: w = w[:-1] + &#39;W&#39; w = carry_over(w) answer += 1 return answer풀이1. 필요한 함수 정의한 번 직접 만들어보자. 그러려면 어떤 행동이 필요할까? 단어의 뒤에 A를 붙이는 것 글자를 한 단계씩 올리는 것 (A -&amp;gt; E) 단어를 올림하는 것 (AAAAU -&amp;gt; AAAE)1번은 그냥 하면 될 것 같고, 2, 3번을 구현해야 할 것 같으니 정의 해보자def change_up(ch): passdef carry(word): passdef solution(word): answer = 0 return answer2. 원하는 단어가 될 때까지 변환우선 첫 번째 글자를 A로 준다.def change_up(ch): passdef carry_over(word): passdef solution(word): w, answer = &#39;A&#39;, 1 return answer취할 행동을 위에서 언급한 대로 3가지이다. 글자가 5개 미만이라면 뒤에 A를 붙인다. 마지막 글자가 U가 아니라면 마지막 글자를 한 단계 올린다. 마지막 글자가 U라면 해당 글자를 W로 치환하고 그 글자를 올림한다.이걸 내가 가진 단어가 주어진 단어와 같아질 때까지 반복한다.def change_up(ch): passdef carry_over(word): passdef solution(word): w, answer = &#39;A&#39;, 1 while w != word: if len(w) &amp;lt; 5: # 2-1 w += &#39;A&#39; elif w[-1] != &#39;U&#39;: # 2-2 w = w[:-1] + change_up(w[-1]) elif w[-1] == &#39;U&#39;: # 2-3 w = w[:-1] + &#39;W&#39; w = carry_over(w) answer += 1 return answer3. 함수 구현우선 파라미터로 받은 문자를 한 단계 올려주는 change_up()부터 살펴보자.이건 간단하다. 테이블을 하나 만들어 두고 받은 문자의 다음 인덱스의 문자를 반환하면 된다.WORD_TABLE = &quot;AEIOU&quot;def change_up(ch): # 3-1 return WORD_TABLE[WORD_TABLE.index(ch) + 1]다음으로 단어의 문자들을 올림하는 함수를 구현해보자.우선 사용 상의 편의를 위해 문자열(string)을 리스트로 만들고, 순회를 할건데 가장 마지막 인덱스에서부터 0번째 인덱스까지 역순으로 순회를 한다.i번째의 문자가 current_character이고, i-1번째의 문자가 previous_character이다.def carry_over(word): word_list = list(word) for i in range(len(word_list)-1, -1, -1): # 3-2 cur_ch, prev_ch = word_list[i], word_list[i-1]체크할 것은 아래와 같다. 현재 문자가 W인가? 맞으면, 앞의 문자가 U인가? 맞으면, 그 문자를 W로 바꾼다. 아니면, 그 문자를 한 단계 올린다. 아니면, pass def carry_over(word): word_list = list(word) for i in range(len(word_list)-1, -1, -1): cur_ch, prev_ch = word_list[i], word_list[i-1] if cur_ch == &#39;W&#39;: # 3-3 if prev_ch == &#39;U&#39;: word_list[i-1] = &#39;W&#39; else: word_list[i-1] = change_up(prev_ch)이제 이 단어 리스트에서 남아 있는 W는 올림처리를 다 해줬기 때문에 필요 없으므로 걸러내주고 문자열로 바꿔 반환한다.def carry_over(word): word_list = list(word) for i in range(len(word_list)-1, -1, -1): cur_ch, prev_ch = word_list[i], word_list[i-1] if cur_ch == &#39;W&#39;: # 3-3 if prev_ch == &#39;U&#39;: word_list[i-1] = &#39;W&#39; else: word_list[i-1] = change_up(prev_ch) return &#39;&#39;.join(filter(lambda w: w != &#39;W&#39;, word_list))번외. 수학을 적용한 풀이WORD_TABLE = &quot;AEIOU&quot;def solution(word): answer, r = 0, 5 for i, w in enumerate(word): a = WORD_TABLE.index(w) n = r - i answer += a * ((r ** n - 1) / (r - 1)) + 1 return answer정리 안 하려고 하다가 그건 좀 아닌 것 같아서 업데이트 했다.컴퓨터가 노가다를 해준 결과 이런 규칙을 발견할 수 있었다. 왼쪽에 채워진 A들은 무시하고 가장 오른쪽 알파벳만 보자5번째 자리 - 1씩 증가AAAAA: 5AAAAE: 6AAAAI: 7...4번쨰 자리 - 6씩 증가 (1 + 5)AAAA: 4AAAE: 10AAAI: 16...3번째 자리 - 31씩 증가 (6 + 25)AAA 3AAE 34AAI 65...2번째 자리 - 156씩 증가 (31 + 125)AA 2AE 158AI 314...1번째 자리 - 781씩 증가 (156 + 625)A 1E 782I 15635번째 자릿수 부터 역순으로 증가치를 나열해보자 1, 6, 31, 156, 781, …근데 이건 그냥 딱 봐도 등비수열이다.A1 1 = 1A2 6 = 1 + 1*5^1A3 31 = 1 + 1*5^1 + 1*5^2A4 156 = 1 + 1*5^1 + 1*5^2 + 1*5^3A5 781 = 1 + 1*5^1 + 1*5^2 + 1*5^3 + 1*5^4이므로, 일반항 An은 아래와 같다.a = 1, r = 5 일 때,An = a + r^(n-1)각각의 증가치는 등비수열의 합이다. 등비수열의 합 공식은 아래와 같다.시험 삼아 A5만 구해보자.1 * ((5^5)-1) / (5-1) = 781문제 없는 것 같으니 예시를 하나 생각해보자EIO는 1189라고 한다. 이 숫자는 어떻게 구해진 걸까? 여기서도 등비수열의 합 공식을 사용한다.1번째 자릿수에서 숫자를 하나 바꾸는 데는 781만큼 숫자가 더해진다.E는 A-&amp;gt;E로 1번 바꾸므로 781,2번째 자릿수에서 숫자를 하나 바꾸는 데는 156만큼 숫자가 더해진다.I는 A-&amp;gt;E-&amp;gt;I로 2번 바꾸므로 312,3번째 자릿수에서 숫자를 하나 바꾸는 데는 31만큼 숫자가 더해진다.O는 A-&amp;gt;E-&amp;gt;I-&amp;gt;O로 3번 바꾸므로 93정리하자면, 자릿수별로 등비수열의 합을 구한 다음에 아래의 인덱스를 곱해주면 된다.01234AEIOU다 더하면 1186이다. 음? 뭔가 이상한데? 다른 숫자로도 계산을 해보니 자릿수의 갯수 만큼 숫자가 빈다.이유는 알파벳이 바뀌고 바로 다음 자리수에 바로 알파벳이 차는게 아니라 공백부터 시작하기 때문에 시작점이 언제나 -1 된 상태에서 더해나가기 때문이다. (실제로 AAAA에서 5개 만큼 더하면 AAAE가 아니라 AAAAU가 된다.)이건 그냥 더할 때마다 값을 1씩 더해주면 된다.그럼 이걸 코드로 옮겨보자. 근데 n을 그대로 쓰려고 보니까 역순으로 되어 있어서 좀 헷갈린다. n을 우리에게 친숙한 인덱스 i를 사용해서 바꿔 써주자 n = r - iWORD_TABLE = &quot;AEIOU&quot;def solution(word): answer, r = 0, 5 for i, w in enumerate(word): a = WORD_TABLE.index(w) n = r - i answer += a * ((r ** n - 1) / (r - 1)) + 1 return answer광기 (지금 생각하고 있는 그거 맞다)Comment수학을 적용한 풀이는 안 정리하고 넘어갈까 하다가 정리했는데 생각보다 시간이 많이 걸렸다;;하지만 수학의 중요성을 다시금 되새기기 위해서라도 정리했어야 됐으니까 뭐…괜찮나?" }, { "title": "(프로그래머스) Summer/Winter Coding(~2018) - 점프와 순간 이동", "url": "/posts/jump-and-teleport/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2018, 서머/윈터코딩, 그리디", "date": "2022-02-17 12:52:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/12980Introduction프로그래머는 인류가 쌓아 온 경험과 설계 방식, 알고리즘 그리고 수학 지식 등 다양한 무기를 활용하여 문제를 해결하는 해결사들이다.그들은 문제 해결에 대한 아이디어를 얻을 때 이러한 무기들을 사용하는데, 여기서 활용할 수 있는 방법들은 무궁무진하기 때문에 사람마다 다른 방법을 생각해내고 다양한 시각으로 문제를 분석하여 해결해 나간다.경험이 적었던 나는 문제 해결에 대한 아이디어를 얻는 능력이 약했고, 왜인지 문제 해결에 대한 상상력을 발휘하는 것에는 제동이 걸려져 있는 상태였다.그렇기 때문에 이 문제도 쉽게 풀리지 않았었고, 다른 사람의 풀이를 보고 놀라게 되었다.처음에 이 문제를 풀 때 나는 어떻게든 시작점에서 목적지까지 도달하는 것만 신경 쓰고 있었지, 목적지에서부터 출발할 생각을 하지 못했었다.Note 최대한 많이 순간이동 하는 것이 건전지를 적게 쓰는 방법Solutiondef solution(n): steps = 0 while n &amp;gt; 0: if n % 2 == 1: steps += 1 n //= 2 return steps풀이인버전우선 목적지인 n번째 칸에 서서 1번째 칸을 바라본다. 저곳으로 최대한 건전지를 적게 써서 가야 한다.여기서 가장 많이 움직일 수 있는 방법은 한 칸 걷는 것보다는 순간이동이다. 순간 이동을 하면 현재 칸의 절반 숫자의 칸으로 건전지를 쓰지 않고 이동할 수 있다.가능하면 걷는 것보단 순간이동만 해서 가는게 좋다. 심지어 한 칸을 순간이동 하더라도 건전지를 사용하는 걷기보다는 낫다.def solution(n): n //= 2 # 1어? 그런데 밟고 있는 칸을 보니 101번째 칸이고, 50.5번째 칸이란건 안 보인다. 아무래도 순간이동을 할 수 있는 건 짝수칸 일 때 뿐인 것 같다.뭐라고?하는 수 없이 한 칸 앞으로 이동 후 순간이동을 한다.def solution(n): steps = 0 if n % 2 == 1: # 2 steps += 1 n //= 2이걸 1번째 칸에 도착할 때까지 반복한다.def solution(n): steps = 0 while n &amp;gt; 0: if n % 2 == 1: steps += 1 n //= 2 return stepsComment발상의 전환이 중요하다는 말은 많이 듣지만 머리가 많이 굳어져 있는 탓일까 쉽지 않은 것 같다." }, { "title": "(프로그래머스) Summer/Winter Coding(~2018) - 스킬트리", "url": "/posts/skill-tree/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2018, 서머/윈터코딩", "date": "2022-02-16 10:52:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/49993Introduction스킬 트리 중 선행스킬과 관련된 스킬만 뽑아서 순서대로 배웠는지만 체크하면 되는 간단한 문제이다.Note 특이사항 없음Solutiondef solution(skill, skill_trees): answer, skill_set = 0, set(skill) # 1 for skill_tree in skill_trees: required_skills = &#39;&#39;.join([s for s in skill_tree if s in skill_set]) # 2 if skill.startswith(required_skills): # 3 answer += 1 return answer 비교 연산의 속도를 빠르게 하기 위해 skill로 집합을 만든다. 스킬트리를 하나씩 순회하면서 선행 스킬만 뽑아 string을 다시 만든다. 선행 스킬을 순서대로 배웠는지 체크한다.Comment문자열과 배열을 손쉽게 다룰 수 있는 파이썬의 장점이 부각되는 문제였다.정말 알고리즘 한정 최고의 언어라고 생각한다." }, { "title": "(프로그래머스) Summer/Winter Coding(~2018) - 배달", "url": "/posts/delivery/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2018, 서머/윈터코딩, 그래프, 다익스트라", "date": "2022-02-15 19:41:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/12978Introduction다익스트라 알고리즘은 포스트로 하나쯤은 정리해둬야 겠다고 생각했는데 딱 이 문제가 눈에 들어왔다.N개의 마을 중 1번 마을에서부터 K시간 이하로 배달이 가능한 마을을 전부 찾는 이 문제는 각 노드들 간의 최단거리를 구하는 전형적인 다익스트라 알고리즘 문제이다.다익스트라 알고리즘은 한 노드를 기준으로 이어져 있는 모든 노드를 힙에 넣어 가까운 거리순으로 정렬하고, 힙에서 하나씩 꺼내서 방문하며 거리를 갱신하는 방식으로 각 정점별 거리들을 기록하는 DFS의 일종이다.이를 정말 간결하고 이해하기 쉬운 방식으로 구현해둔 블로그를 찾아서 그 링크를 남긴다. 이번 풀이에서도 다익스트라 탐색은 해당 구현방식을 차용했다.(이 구현방식은 정말 직관적이며, 이해하기에도 어렵지 않은 뛰어난 방식이다.)Python으로 다익스트라(dijkstra) 알고리즘 구현하기 at justkodeNote 처음 방문 그래프를 만들 때, 선택한 두 개의 노드 사이에 간선이 2개 이상 있는 경우 더 짧은 거리로 갱신한다.Solutionimport heapqfrom collections import defaultdictdef djikstra(graph, start): distances = {node:float(&#39;inf&#39;) for node in graph} distances[start] = 0 heap = [[distances[start], start]] while heap: distance, destination = heapq.heappop(heap) if distance &amp;gt; distances[destination]: continue for next_destination, next_distance in graph[destination].items(): new_distance = distance + next_distance if new_distance &amp;lt; distances[next_destination]: distances[next_destination] = new_distance heapq.heappush(heap, [new_distance, next_destination]) return distancesdef create_graph(road): graph = defaultdict(dict) for r in road: start, end, distance = r if start in graph and end in graph[start]: distance = min(graph[start][end], distance) graph[start][end] = distance graph[end][start] = distance return graphdef solution(N, road, K): graph = create_graph(road) distances = djikstra(graph, 1) answer = 0 for destination, distance in distances.items(): if distance &amp;lt;= K: answer += 1 return answer풀이1. 필요한 함수 정의우선 노드별 거리 정보가 담긴 그래프를 생성하는 함수를 정의하고 이 그래프와 시작점을 정하면 각 노드까지의 거리들을 반환하는 함수를 정의한다.def djikstra(graph, start): passdef create_graph(road): passdef solution(N, road, K): graph = create_graph(road) distances = djikstra(graph, 1)2. 노드별 거리 그래프 생성우선 딕셔너리(해쉬맵)로 노드간의 거리 정보가 담긴 그래프를 구현하여 사용한다. (ex. graph[1][4] = 3)그래프에는 선택된 노드 두 개(start, end)의 서로 같은 거리를 넣어준다.from collections import defaultdictdef create_graph(road): graph = defaultdict(dict) for r in road: # 2-1 start, end, distance = r graph[start][end] = distance graph[end][start] = distance return graph그런데 지도 그림을 보니 같은 노드 사이에 간선이 2개인 경우도 있다. 간선이 2개인 경우 더 작은 거리를 가진 간선의 거리를 선택하도록 수정해준다.from collections import defaultdictdef create_graph(road): graph = defaultdict(dict) for r in road: start, end, distance = r if start in graph and end in graph[start]: # 2-2 distance = min(graph[start][end], distance) graph[start][end] = distance graph[end][start] = distance return graph이렇게 모든 노드가 자신과 이어진 노드들과의 거리 값을 모두 기록하고 있는 그래프가 완성되었다.{ &quot;1&quot;: { &quot;2&quot;: 1, &quot;4&quot;: 2 }, &quot;2&quot;: { &quot;1&quot;: 1, &quot;3&quot;: 3, &quot;5&quot;: 2 }, &quot;3&quot;: { &quot;2&quot;: 3, &quot;5&quot;: 1 }, &quot;4&quot;: { &quot;1&quot;: 2, &quot;5&quot;: 2 }, &quot;5&quot;: { &quot;2&quot;: 2, &quot;3&quot;: 1, &quot;4&quot;: 2 }}3. 다익스트라 알고리즘으로 탐색djikstra() 함수의 목표는 그래프와 시작점을 넣어주면 시작점에서부터 모든 노드들을 탐색하여 각 노드까지의 거리를 담고 있는 distances라는 딕셔너리를 반환하는 것이다.이를 위해 distances라는 이름으로 {노드:거리}의 딕셔너리를 만든다. 이 때, 거리 값은 무한대로 초기화한다.import heapqdef djikstra(graph, start): distances = {node:float(&#39;inf&#39;) for node in graph} # 3-1첫 번째 노드의 거리를 0으로 설정하고 heap에 [거리, 목적지]순으로 넣어준다.인자로 받은 시작점부터 탐색할 것이기 때문에 목적지로 시작점을 넣어준다.import heapqdef djikstra(graph, start): distances = {node:float(&#39;inf&#39;) for node in graph} distances[start] = 0 # 3-2 heap = [[distances[start], start]] # 3-2heap에서 거리와 목적지를 차례로 꺼내서 현재 노드까지의 거리와 목적지의 거리를 더한 후 이 값이 원래 distances에 있는 값보다 크다면 무시하고 작다면 갱신해주고 해당 노드를 최단거리순 방문예정 리스트인 heap에 넣어준다.뭔가 복잡해보이지만 별거 없다. distances를 갱신한다는 목표만 잊지 않고 있으면 된다.import heapqdef djikstra(graph, start): distances = {node:float(&#39;inf&#39;) for node in graph} distances[start] = 0 heap = [[distances[start], start]] while heap: distance, destination = heapq.heappop(heap) # 3-3 for next_destination, next_distance in graph[destination].items(): # 3-4 new_distance = distance + next_distance if new_distance &amp;lt; distances[next_destination]: distances[next_destination] = new_distance heapq.heappush(heap, [new_distance, next_destination])3-4에서 목적지를 체크할 때 그 목적지를 방문하지 않아도 되는 경우가 있다. 바로 아래 그림처럼 목적지까지 다이렉트로 가는 간선의 거리가 조금 돌아서 가는 거리보다 더 멀 때이다.1번 노드의 인접 노드 중 5번 노드는 직접 갈 때 보다 3번을 거쳐 가는 경우가 더 빠르다. 그리고 이미 3번 노드를 거쳐 5번에 도착한 이력이 있을 경우, 굳이 5번 노드를 체크할 이유는 없으므로 이 경우는 넘어간다.import heapqdef djikstra(graph, start): distances = {node:float(&#39;inf&#39;) for node in graph} distances[start] = 0 heap = [[distances[start], start]] while heap: distance, destination = heapq.heappop(heap) if distance &amp;gt; distances[destination]: # 3-5 continue for next_destination, next_distance in graph[destination].items(): new_distance = distance + next_distance if new_distance &amp;lt; distances[next_destination]: distances[next_destination] = new_distance heapq.heappush(heap, [new_distance, next_destination]) return distances4. 원하는 거리 이하의 노드만 선택노드별 거리 정보가 들어간 딕셔너리를 얻었으면 이 딕셔너리를 순회하면서 거리가 K 이하인 노드를 찾고 이 노드들 개수를 반환한다.def solution(N, road, K): graph = create_graph(road) distances = djikstra(graph, 1) answer = 0 # 4 for destination, distance in distances.items(): if distance &amp;lt;= K: answer += 1 return answerComment다익스트라 알고리즘에 대해 길게 쓰여진 설명글들을 읽고 있으면 엄청 복잡해보이는데, 실제로 코드로 옮기고 나면 그렇게까지 복잡하지만도 않아서 놀랍다." }, { "title": "(프로그래머스) Summer/Winter Coding(~2018) - 방문 길이", "url": "/posts/visit-distance/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2018, 서머/윈터코딩", "date": "2022-02-14 14:35:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/49994Introduction게임 판에서 게임 캐릭터가 움직이면서 벌어지는 일들을 묘사해주면 되는 문제다.이런 일을 간단하게 할 수 있도록 도움을 준 기본 라이브러리들에 감사할 따름이다.Note 어떤 지점에 도착했느냐로 체크 하는게 아니라, 지점과 지점을 잇는 간선을 지나갔느냐를 체크 하는 것에 주의 같은 길은 두 방향으로 똑같이 지나갈 수 있다. 중복으로 체크하지 않도록 주의SolutionDISTANCE = { &quot;U&quot;: (0, 1), &quot;D&quot;: (0, -1), &quot;L&quot;: (-1, 0), &quot;R&quot;: (1, 0),}def solution(dirs): visited = dict() answer, current = 0, [0, 0] for direction in dirs: from_x, from_y = current dx, dy = DISTANCE[direction] to_x, to_y = from_x + dx, from_y + dy if not -5 &amp;lt;= to_x &amp;lt;= 5 or not -5 &amp;lt;= to_y &amp;lt;= 5: continue if (from_x, from_y, to_x, to_y) not in visited: answer += 1 visited[(from_x, from_y, to_x, to_y)] = True visited[(to_x, to_y, from_x, from_y)] = True current = to_x, to_y return answer1. 필요한 좌표 사전/방문 사전 준비게임 캐릭터는 U, D, L, R 4방향으로만 움직인다. 현재 좌표에서 입력받은 커맨드로 바로 좌표를 움직일 수 있게 커맨드와 좌표를 매핑한 사전을 준비한다.현재 위치는 (0, 0) 위치에서 부터 시작한다.DISTANCE = { # 1 &quot;U&quot;: (0, 1), &quot;D&quot;: (0, -1), &quot;L&quot;: (-1, 0), &quot;R&quot;: (1, 0),}def solution(dirs): visited = dict() answer, current = 0, [0, 0]2. 실제로 게임 캐릭터를 이동현재 위치를 from_x, from_y로 두고 입력받은 커맨드에 해당하는 만큼의 거리를 계속해서 이동해 준다.DISTANCE = { &quot;U&quot;: (0, 1), &quot;D&quot;: (0, -1), &quot;L&quot;: (-1, 0), &quot;R&quot;: (1, 0),}def solution(dirs): visited = dict() answer, current = 0, [0, 0] for direction in dirs: # 2 from_x, from_y = current dx, dy = DISTANCE[direction] to_x, to_y = from_x + dx, from_y + dy current = to_x, to_y3. 예외상황 고려이동을 하려는 곳이 맵 밖을 벗어났을 수도 있다. 이런 경우는 제외한다.DISTANCE = { &quot;U&quot;: (0, 1), &quot;D&quot;: (0, -1), &quot;L&quot;: (-1, 0), &quot;R&quot;: (1, 0),}def solution(dirs): visited = dict() answer, current = 0, [0, 0] for direction in dirs: from_x, from_y = current dx, dy = DISTANCE[direction] to_x, to_y = from_x + dx, from_y + dy if not -5 &amp;lt;= to_x &amp;lt;= 5 or not -5 &amp;lt;= to_y &amp;lt;= 5: # 3 continue current = to_x, to_y4. 지나가지 않은 길 체크지나가려는 길은 두 방향 다 한 번으로 체크되어야 한다. 갈 때 한 번, 올 때 한 번이다.한 번도 지나간적이 없는 길이라면 길의 갯수를 하나 올려준다.DISTANCE = { &quot;U&quot;: (0, 1), &quot;D&quot;: (0, -1), &quot;L&quot;: (-1, 0), &quot;R&quot;: (1, 0),}def solution(dirs): visited = dict() answer, current = 0, [0, 0] for direction in dirs: from_x, from_y = current dx, dy = DISTANCE[direction] to_x, to_y = from_x + dx, from_y + dy if not -5 &amp;lt;= to_x &amp;lt;= 5 or not -5 &amp;lt;= to_y &amp;lt;= 5: continue if (from_x, from_y, to_x, to_y) not in visited: # 4 visited[(from_x, from_y, to_x, to_y)] = True visited[(to_x, to_y, from_x, from_y)] = True answer += 1 current = to_x, to_y return answerComment처음에는 지점을 체크해야하는걸로 착각해서 삽질을 조금 했지만, 게임 문제라 이해하기도 쉽고 금방금방 재밌게 풀었던 것 같다." }, { "title": "(프로그래머스) Summer/Winter Coding(~2018) - 영어 끝말잇기", "url": "/posts/word-chain-game/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2018, 서머/윈터코딩", "date": "2022-02-11 15:51:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/12981Introduction간단한 구현 문제이다. 코드로 끝말잇기 게임이 진행되는 상황을 묘사하면 된다.Note 현재 order가 n과 같아졌을 때 다시 처음으로 맞춰주는 작업을 해야 한다Solutiondef solution(n, words): spoken_words = dict() order, phase = 1, 1 prev_word = words[0][0] for word in words: if word in spoken_words or prev_word[-1] != word[0]: return [order, phase] elif order == n: phase += 1 spoken_words[word] = True prev_word = word order = (order % n) + 1 return [0, 0]1. 혼자서 게임을 진행우선 혼자서 게임을 진행해 보자. 단어를 말하고 나면 이미 말한 단어 사전에 집어넣고 이전 단어만 기억한다.def solution(n, words): spoken_words = dict() for word in words: # 1 spoken_word[word] = True prev_word = word2. 여럿이서 게임을 진행여럿이서 연습게임을 할건데 틀리는건 상관없이 진행을 해보자마지막 사람까지 차례가 돌아왔을 때(order == n) phase를 하나씩 올려준다.order는 1씩 추가해 나가는데, 만약 order == n인 상황인 경우 값을 0으로 맞춰주고(order % n) 1을 더해준다.order = 3, n = 3일 때3 % 3 = 0 이므로,order = (3 % 3) + 1 = 1 이 된다.나머지의 경우 원래 숫자에 1만 더해진다.def solution(n, words): spoken_words = dict() order, phase = 1, 1 for word in words: if order == n: # 2-2 phase += 1 spoken_word[word] = True prev_word = word order = (order % n) + 1 # 2-13. 틀리는 경우를 걸러낸다.끝말잇기에서 틀리는 경우는 두 가지이다. 이미 말한 단어를 또 말할 때 이전 단어의 끝 단어와 다른 알파벳으로 시작하는 단어를 말할 때아무도 틀린 사람이 없을 때는 [0, 0]을 반환한다.def solution(n, words): spoken_words = dict() order, phase = 1, 1 prev_word = words[0][0] for word in words: if word in spoken_words or prev_word[-1] != word[0]: # 3 return [order, phase] elif order == n: phase += 1 spoken_words[word] = True prev_word = word order = (order % n) + 1 return [0, 0]Comment이번 문제와 같이 고려할 것이 적은 문제들을 해결할 때의 코드는 굉장히 명확한 경우가 많다.하지만 다루는 데이터의 양이 커지면 커질수록 순진한 방법으로는 문제를 해결할 수 없고, 어떻게든 다양한 아이디어를 적용하여 최적화를 해야한다.보통 그런 것들을 해결해 줄 알고리즘들은 머리좋은 사람들이 이미 만들어 놓은 경우가 대부분이라서 열심히 배우고 익혀나가고 있다. 세상엔 정말 대단한 사람들이 많은 것 같다." }, { "title": "(프로그래머스) 찾아라 프로그래밍 마에스터 - 게임 맵 최단거리", "url": "/posts/shortest-distance/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, BFS", "date": "2022-02-10 13:58:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/1844Introduction채용 관련된 코딩 테스트 레벨에서는 어느 정도 참고할 수 있는 템플릿 같은게 있었다. 어떻게 보면 코딩테스트를 치루는 많은 사람들이 알고 있는 기초지식 같은 것이라고 해야하나몇몇 알고리즘은 기본 원형 같은 것이 존재하는데, 이번 문제는 BFS의 원형을 응용할 것도 없이 정석대로 사용하면 그냥 풀린다.처음 이 유형의 문제를 접했을 때 아니 코드 길이도 긴데 왜 난이도가 이렇게 낮게 측정된거야 하고 의아해했었다.(하필 그 문제가 영역을 다른 색으로 칠하는 플러드 필 관련 문제에, 자바로 풀었었어서 코드가 더 길었었다.)지금 와서 다시 보면 채용 코테에서 문제가 이 수준으로 나오면 변별력이 없을 것 같기도 하다.유형을 그냥 외우기만 하면 굉장히 짧은 시간 내에 풀어버릴 수 있을 테니까알고리즘과 관련되어서 barkingdog님의 강의를 굉장히 추천하는 편인데, 이번 문제는 [바킹독의 실전 알고리즘] 0x09강 - BFS를 들으면 이론을 굉장히 쉽게 이해할 수 있다.Note 체크하려는 곳이 유효한지를 사전에 필터링할 것 체크하려는 곳의 거리가 지금 내가 있는 곳의 거리 + 1보다 크면 갱신해준다.Solutionfrom collections import dequeDX = [1, 0, -1, 0]DY = [0, 1, 0, -1]def solution(maps): distances = [[-1 for i in maps[0]] for j in maps] queue = deque() queue.append([0,0]) distances[0][0] = 1 while queue: cur_x, cur_y = queue.popleft() for i in range(4): x, y = cur_x + DX[i], cur_y + DY[i] if not 0 &amp;lt;= x &amp;lt; len(maps[0]) or not 0 &amp;lt;= y &amp;lt; len(maps) or maps[y][x] == 0: continue if distances[y][x] == -1 or distances[y][x] &amp;gt; distances[cur_y][cur_x] + 1: queue.append([x, y]) distances[y][x] = distances[cur_y][cur_x] + 1 return distances[-1][-1]풀이1. 방문한 곳을 표시할 배열과 큐를 준비BFS는 큐를 사용하여 구현하는데, 현재 지점으로부터 인접한 지점을 차례대로 큐에 넣고 그 순서대로 방문하기 때문에 탐색할 수 있는 모든 지점을 거리순으로 순차적으로 모두 방문한다.이러한 특성을 이용해서 게임 맵을 순차적으로 방문하고 방문할 때마다 기준 지점의 거리 + 1만큼 더해 나가면 된다.이를 위해 큐와 distances라는 배열을 준비하고 큐에 시작점의 좌표(0, 0)를 넣어준뒤 시작점의 거리를 갱신해 준다.(거리를 고려하지 않는 경우 템플릿에서는 이 distances라는 변수명이 보통 visited라는 이름으로 정의된다.)from collections import dequedef solution(maps): distances = [[-1 for i in maps[0]] for j in maps] queue = deque() queue.append([0, 0]) distances[0][0] = 12. 큐 안의 좌표 순회큐 안에 좌표가 남아 있는 동안은 계속 큐에서 좌표를 꺼낸다.from collections import dequedef solution(maps): distances = [[-1 for i in maps[0]] for j in maps] queue = deque() queue.append([0, 0]) distances[0][0] = 1 while queue: # 2 cur_x, cur_y = queue.popleft()3. 큐 안의 좌표를 기준으로 상하좌우 탐색위의 그림 처럼 기준점의 상하좌우 4방향을 탐색하려면 원래 좌표에서 1을 더하거나 빼주면 된다. 이를 코드로 표현해 보자.current_x와 current_y를 기준으로 DX, DY를 각각 더한 x, y를 구한다.from collections import dequeDX = [1, 0, -1, 0]DY = [0, 1, 0, -1]def solution(maps): distances = [[-1 for i in maps[0]] for j in maps] queue = deque() queue.append([0,0]) distances[0][0] = 1 while queue: cur_x, cur_y = queue.popleft() for i in range(4): # 3 x, y = cur_x + DX[i], cur_y + DY[i]4. 유효한 칸이 아니면 걸러내기체크하려는 x와 y가 유효하지 않으면 넘어간다. x, y가 게임맵을 벗어났다. maps의 (x, y) 좌표가 길이 아니다.(= 0)from collections import dequeDX = [1, 0, -1, 0]DY = [0, 1, 0, -1]def solution(maps): distances = [[-1 for i in maps[0]] for j in maps] queue = deque() queue.append([0,0]) distances[0][0] = 1 while queue: cur_x, cur_y = queue.popleft() for i in range(4): x, y = cur_x + DX[i], cur_y + DY[i] if not 0 &amp;lt;= x &amp;lt; len(maps[0]) or not 0 &amp;lt;= y &amp;lt; len(maps) or maps[y][x] == 0: # 4 continue5. 거리를 갱신최단거리를 갱신하는 조건은 아래와 같다. 방문한 적이 없어 거리 값이 -1일 때 체크하려는 곳이 기준점 + 1보다 더 거리값이 클 때이런 곳을 만나면 거리 값을 갱신해주고 해당 칸을 큐에 넣어 준다.순회가 끝나면 가장 마지막 칸의 값을 반환하면 된다. 시작점과 길이 이어져 있다면 거리 값이 나올 것이고, 그렇지 않다면 처음에 넣어준 -1이 반환된다.from collections import dequeDX = [1, 0, -1, 0]DY = [0, 1, 0, -1]def solution(maps): distances = [[-1 for i in maps[0]] for j in maps] queue = deque() queue.append([0,0]) distances[0][0] = 1 while queue: cur_x, cur_y = queue.popleft() for i in range(4): x, y = cur_x + DX[i], cur_y + DY[i] if not 0 &amp;lt;= x &amp;lt; len(maps[0]) or not 0 &amp;lt;= y &amp;lt; len(maps) or maps[y][x] == 0: continue if distances[y][x] == -1 or distances[y][x] &amp;gt; distances[cur_y][cur_x] + 1: # 5 queue.append([x, y]) distances[y][x] = distances[cur_y][cur_x] + 1 return distances[-1][-1]Comment처음 스택과 큐라고 하는 자료구조를 공부하고 이걸 응용한 DFS, BFS를 통한 탐색에 대해서 배웠을 때 정말 소름이 돋았다.“얼핏 보면 전혀 관려 없어 보이는 이 자료구조를 응용해서 어떻게 이런 알고리즘을 만들어 낼 수 있었을까 정말 천재들만 있나?”주어진 도구들을 이용해 어떤 창의적인 방법들을 만들어내는 개발자들의 행보를 보면 정말 감탄 밖에 나오지 않는다.나는 이런 업계에 있구나하는 생각이 들어 가슴이 벅차 오른다. 뭐 아직은 견습생과도 같은 신분이지만." }, { "title": "(프로그래머스) 월간 코드 챌린지 시즌2 - 괄호 회전하기", "url": "/posts/rotate-brackets/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 스택, 큐", "date": "2022-02-09 15:28:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/76502Introduction괄호 체크에는 빠지지 않고 등장하는 자료구조인 스택과, 문자열을 간편하게 회전시킬 수 있는 큐를 사용하면 간단하게 풀 수 있는 문제이다.여는 괄호((, {, [)가 나왔을 때는 스택에 넣고, 닫는 괄호(), }, ])가 나왔을 때 스택에서 하나씩 빼는 방식으로 체크할 수 있다.Note 괄호를 모두 체크 한 후 스택에 남아 있는 괄호가 있는지 체크Solutionfrom collections import dequeOPENING = [&quot;(&quot;, &quot;{&quot;, &quot;[&quot;]CLOSING = [&quot;)&quot;, &quot;}&quot;, &quot;]&quot;]def check_brackets(brackets): stack = [] for bracket in brackets: if bracket in OPENING: stack.append(bracket) elif bracket in CLOSING: if not stack or CLOSING.index(bracket) != OPENING.index(stack.pop()): return False return not stackdef solution(s): answer, bracket_queue = 0, deque(s) for _ in s: is_valid_brackets = check_brackets(bracket_queue) if is_valid_brackets: answer += 1 bracket_queue.rotate(1) return answer풀이1. 필요한 함수 정의괄호 문자열을 회전 시킬 큐는 이미 기본 라이브러리에 구현되어 있지만 괄호를 체크하는 기능은 직접 구현해야 한다.def check_brackets(brackets): passdef solution(s): answer = 0 return answer2. 정의된 함수를 가지고 문제를 해결우선 주어진 괄호 문자열을 가지고 괄호 큐를 만들어 준다.from collections import dequedef check_brackets(brackets): passdef solution(s): answer, brackets_queue = 0, deque(s) # 2-1 return answer괄호 문자열에 있는 괄호가 다시 제자리로 돌아올때까지 회전시킬 것이므로 괄호 문자열의 길이만큼 회전시킨다.from collections import dequedef check_brackets(brackets): passdef solution(s): answer, brackets_queue = 0, deque(s) for _ in s: brackets_queue.rotate(1) # 2-2 return answer회전하면서 괄호를 체크해 주고 올바른 괄호 문자열이면 정답 카운트를 하나씩 올린다.from collections import dequedef check_brackets(brackets): passdef solution(s): answer, brackets_queue = 0, deque(s) for _ in s: is_valid_brackets = check_brackets(brackets_queue) # 2-3 if is_valid_brackets: answer += 1 brackets_queue.rotate(1) return answer3. 정의된 함수를 구현stack을 사용하여 여는 괄호면 넣고, 닫는 괄호면 스택에서 뺀다. 이 타이밍에 스택이 비어있거나 종류가 다른 괄호면 False를 반환하고 함수를 종료한다.from collections import dequeOPENING = [&quot;(&quot;, &quot;{&quot;, &quot;[&quot;]CLOSING = [&quot;)&quot;, &quot;}&quot;, &quot;]&quot;]def check_brackets(brackets): stack = [] for bracket in brackets: # 3-1 if bracket in OPENING: stack.append(bracket) elif bracket in CLOSING: if not stack or CLOSING.index(bracket) != OPENING.index(stack.pop()): return Falsedef solution(s): answer, brackets_queue = 0, deque(s) for _ in s: is_valid_brackets = check_brackets(brackets_queue) if is_valid_brackets: answer += 1 brackets_queue.rotate(1) return answer모든 괄호를 체크했음에도 스택에 괄호가 남아있다면 잘못된 문자열이므로 이 또한 체크해 준다.from collections import dequeOPENING = [&quot;(&quot;, &quot;{&quot;, &quot;[&quot;]CLOSING = [&quot;)&quot;, &quot;}&quot;, &quot;]&quot;]def check_brackets(brackets): stack = [] for bracket in brackets: if bracket in OPENING: stack.append(bracket) elif bracket in CLOSING: if not stack or CLOSING.index(bracket) != OPENING.index(stack.pop()): return False return not stack # 3-2 스택이 비어 있으면 True 아니면 Falsedef solution(s): answer, brackets_queue = 0, deque(s) for _ in s: is_valid_brackets = check_brackets(brackets_queue) if is_valid_brackets: answer += 1 brackets_queue.rotate(1) return answerComment스택을 사용한 알고리즘 문제 풀이에서 괄호 관련된 문제가 나오는 경우는 많지 않았던 것 같다.괄호체크는 스택 입문용이고 보통 이것 보다는 더 난이도가 있는 DFS 문제로 나오는 경우가 많다." }, { "title": "(프로그래머스) 월간 코드 챌린지 시즌1 - 이진 변환 반복하기", "url": "/posts/repeat-binary-change/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, n진수", "date": "2022-02-08 12:54:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/70129Introduction함수는 정말 매력적인 도구다.함수의 역할은 그 함수가 가진 이름표에 적혀 있고, 어떻게 동작하는지에 대한 상세한 정보를 몰라도 어떤 입력 값을 주면 그에 맞는 출력 값이 나온다.심플하고, 명확하다.# 1def f(a): return &#39;&#39;.join([b for b in a if b != &#39;0&#39;])파이썬을 전혀 모르는 사람이 1번 함수를 보면 이게 대체 뭔소린지 이해가 안된다.# 2def remove_zeros(string): return &#39;&#39;.join([no for no in string if no != &#39;0&#39;])하지만 2번과 같이 함수의 이름을 지정하고 파라미터의 이름을 알맞게 적어주면 완벽하게 이해는 안되더라도 어떻게 돌아가는지를 짐작해볼 수 있다.# 3def remove_zeros(string): return string.replace(&#39;0&#39;, &#39;&#39;)좀 더 읽기 쉬운 문장으로 바꾼다면 3번과 같이 작성할 수도 있지만, 알고리즘을 생각하다 보면 필연적으로 모든걸 문장으로만 묘사할 수 없는 상황도 생겨난다.이것은 해당 프로그래머의 역량 부족일 수도 있고, 알고리즘 자체가 수학적 증명에 의존한 것일 수도 있다. 가령 예를 들면 힙의 자료구조를 구현하면서 그 자체로서 문장으로 설명하는건 정말 난해하다.인덱스가 i인 부모 노드의 왼쪽 자식 노드의 인덱스가 2 * i 이고 오른쪽 자식의 인덱스가 2 * i + 1 라는 것을 구현과 동시에 이해할 수 있는 설명문으로 적는 것은 쉽지 않다.구구절절 코멘트를 달아놓을 수도 있겠지만 어찌되었든 내용이 길어지는것은 복잡도도 그만큼 증가하기 때문에 직관성이 떨어진다.그래서 2번과 같이 로직을 작성하고 이를 함수로 래핑하는 경우도 많다.Note 이진수로 변환한 수 자체가 아니라 그 수의 길이를 다루는 것에 주의Solutiondef convert_no(no, n): nums, quotient = &#39;&#39;, no while quotient &amp;gt; 0: quotient, remainder = quotient // n, int(quotient % n) nums = str(remainder) + nums return nums if no &amp;gt; 0 else &#39;0&#39;def solution(s): answer, prev = [0, 0], s while True: current = prev.replace(&#39;0&#39;, &#39;&#39;) converted_no = convert_no(len(current), 2) answer[0] += 1 answer[1] += len(prev) - len(current) if converted_no == &#39;1&#39;: break prev = converted_no return answer풀이1. 필요한 함수 지정지문에는 어떤 행동을 하여 문제를 해결해야 할지 적혀 있다. x의 모든 0을 제거합니다. x의 길이를 c라고 하면, x를 “c를 2진법으로 표현한 문자열”로 바꿉니다.1번: 0을 제거, 2번: 어떤 수를 n진법으로 표현.def convert_no(no, n): passdef remove_zeros(string): passdef solution(s): answer = [] return answer2. 지정된 함수들을 가지고 문제를 해결우선 1번과 2번을 코드로 표현해보자.def convert_no(no, n): passdef remove_zeros(string): passdef solution(s): answer = [0, 0] while True: current = remove_zeros(s) converted_no = convert_no(len(current), 2) break return answer이걸 숫자가 1이 될 때까지 계속 반복한다.def convert_no(no, n): passdef remove_zeros(string): passdef solution(s): answer, prev = [0, 0], s while True: current = remove_zeros(prev) converted_no = convert_no(len(current), 2) if conveted_no == &#39;1&#39;: break prev = converted_no return answer이 과정 중에서 정답의 값을 계속 갱신해준다.def convert_no(no, n): passdef remove_zeros(string): passdef solution(s): answer, prev = [0, 0], s while True: current = remove_zeros(prev) converted_no = convert_no(len(current), 2) answer[0] += 1 answer[1] += len(prev) - len(current) if converted_no == &#39;1&#39;: break prev = converted_no return answer3. 지정된 함수들을 구현필요한 함수들을 구현해 준다.def convert_no(no, n): nums, quotient = &#39;&#39;, no while quotient &amp;gt; 0: quotient, remainder = quotient // n, int(quotient % n) nums = str(remainder) + nums return nums if no &amp;gt; 0 else &#39;0&#39;def remove_zeros(string): return string.replace(&#39;0&#39;, &#39;&#39;)def solution(s): answer, prev = [0, 0], s while True: current = remove_zeros(prev) converted_no = convert_no(len(current), 2) answer[0] += 1 answer[1] += len(prev) - len(current) if converted_no == &#39;1&#39;: break prev = converted_no return answer굳이 remove_zeros라는 함수를 쓸 필요 없이 string의 내장함수로 그대로 써주자def convert_no(no, n): nums, quotient = &#39;&#39;, no while quotient &amp;gt; 0: quotient, remainder = quotient // n, int(quotient % n) nums = str(remainder) + nums return nums if no &amp;gt; 0 else &#39;0&#39;def solution(s): answer, prev = [0, 0], s while True: current = prev.replace(&#39;0&#39;, &#39;&#39;) converted_no = convert_no(len(current), 2) answer[0] += 1 answer[1] += len(prev) - len(current) if converted_no == &#39;1&#39;: break prev = converted_no return answerCommentstring에 내장된 replace라는 함수는 내부에서 어떻게 동작하는지 알지 모르더라도 이 함수를 사용한 코드를 읽어나갈 때 흐름을 파악하는데는 아무런 문제가 없다.잘 쓰여진 글과 잘 만들어진 도구들은 일반적인 관점에서 매우 명료하고 이해하는데 추가적인 설명이 필요가 없이 직관적인데, 나는 그런 것들을 만들고 있는지 언제나 스스로를 돌아보게 된다.아직은 더 많은 연습이 필요한 것 같다.근데 이것도 문제가 Level 1 수준인데..?" }, { "title": "2018 KAKAO BLIND RECRUITMENT [1차] 캐시", "url": "/posts/kakao-cache/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2018, 카카오, 블라인드, 큐", "date": "2022-02-07 18:28:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/17680Introduction큐를 사용하면 정말 간단하게 풀 수 있는 문제이다.Level 2로 분류될 문제는 아닌듯Note 큐를 사용하여 캐시의 사용빈도를 관리한다.Solutionfrom collections import dequedef solution(cacheSize, cities): if cacheSize == 0: return 5 * len(cities) answer, cache = 0, deque() for c in cities: city = c.lower() if city in cache: cache.remove(city) cache.append(city) answer += 1 continue elif len(cache) == cacheSize: cache.popleft() cache.append(city) answer += 5 return answer풀이간단한 문제이다. cities 리스트를 순회하면서 city가 캐쉬에 있으면 갱신하고 없으면 캐쉬 사이즈를 체크한 다음에 넘으면 가장 오래된걸 버리고 캐쉬 큐에 집어넣는다.처음에는 cache_set을 만들어 해당 city가 cache 안에 있는지를 O(1)로 체크하려고 했는데, n이 30으로 굉장히 작아서 그냥 더 짧은 코드로 변경했다.cache를 갱신하는 부분(line 8, 9)을 처음에는 직접 구현했다가 저렇게 두 줄로 쓰는거나 큰 차이가 없을 것 같아서 더 짧은 쪽으로 선택했다. (지금 다시 보면 그 구현한 부분 너무 심각했다;;)이 문제는 파이썬 deque에 maxLen 기능을 알고 있다면 더 짧게 풀 수 있는 문제였다.아래는 maxLen 기능을 사용하여 더 짧게 푼 다른 사람의 풀이이다.def solution(cacheSize, cities): import collections cache = collections.deque(maxlen=cacheSize) time = 0 for i in cities: s = i.lower() if s in cache: cache.remove(s) cache.append(s) time += 1 else: cache.append(s) time += 5 return timeComment좀 더 사용하고 있는 기본 라이브러리에 대해 자세하게 공부하고 어떤 기능들이 있는지를 배워야겠다." }, { "title": "(프로그래머스) 위클리 챌린지 - 피로도", "url": "/posts/tiredness/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 위클리 챌린지, 그리디", "date": "2022-02-04 17:19:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/87946Introduction현재 상황에서 가장 최적의 값을 선택해 나가는 그리디 알고리즘을 설명하는데 이 문제는 가장 적합한 문제가 아닐까 싶다.Note 피로도 효율과 최소 피로 필요도 순으로 정렬하면 앞에서 부터 가장 최적의 던전을 고를 수 있다.Solutiondef solution(k, dungeons): answer = 0 relocated_dungeons = sorted(dungeons, key=lambda x: (x[1] / x[0], x[1])) for dungeon in relocated_dungeons: required, consumption = dungeon if k &amp;lt; required or k - consumption &amp;lt; 0: continue k -= consumption answer += 1 return answer풀이1. 던전을 재정렬던전은 당연히 효율이 좋은 순서대로, 그리고 같은 효율이라면 더 적은 피로도를 쓰는게 좋기 때문에 던전을 피로도 효율(소모 피로도/최소 필요 피로도), 소모 피로도 순으로 정렬해준다.def solution(k, dungeons): relocated_dungeons = sorted(dungeons, key=lambda x: [x[1] / x[0], x[1]]) # 12. 던전을 순회던전을 돌면서 피로도를 깎아나간다.def solution(k, dungeons): answer = 0 relocated_dungeons = sorted(dungeons, key=lambda x: (x[1] / x[0], x[1])) for dungeon in relocated_dungeons: # 2 required, consumption = dungeon k -= consumption answer += 1 return answer3. 입장불가 던전은 패스하기던전을 돌다보면 다음 던전이 내가 가진 피로도 보다 최소 필요 피로도가 높거나, 피로도가 부족해 입장 할 수 없는 던전이 있다.그런 던전들은 제외한다.continue로 다시 던전 순회를 계속하는 이유는, 내가 가진 피로도가 30이고 효율이 더 좋은 던전A(소모 피로도 50), 안 좋은 던전B(소모 피로도 20)가 뒤에 더 남아있을 때 A를 넘기고 B라도 입장하기 위해서이다.def solution(k, dungeons): answer = 0 relocated_dungeons = sorted(dungeons, key=lambda x: (x[1] / x[0], x[1])) for dungeon in relocated_dungeons: required, consumption = dungeon if k &amp;lt; required or k - consumption &amp;lt; 0: # 3 continue k -= consumption answer += 1 return answerComment간단하고 재미있는 문제였다. 어떤 던전을 우선적으로 들어갈지에 대한 정렬만 잘하면 어렵지 않게 풀리는 문제이다.프로그래머스의 몇몇 알고리즘 문제는 문제를 풀기 위해 추가로 독해능력을 필요로 한다.현업에서 말이 잘 안통하는 상대의 요구사항을 파악하는 능력을 기르기 위함인건지는 모르겠지만, 알고리즘 고민하는 것보다 문제를 이해하는데 더 많은 노력이 필요한 것 같기도 하고 여러모로 그런 문제들은 좀 피곤해지는 것은 사실이다.그런 점에서 지난 포스팅인 프렌즈4 블록도 그렇고 이번 문제와 같이 이해할 수 있는 명확한 조건들이 있는 문제들이 너무 좋다. 일단 풀면서 내가 뭘 해야할지 명확하니까 즐겁다." }, { "title": "2018 KAKAO BLIND RECRUITMENT [1차] 프렌즈4블록", "url": "/posts/kakao-friends4-block/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2018, 카카오, 시뮬레이션", "date": "2022-02-03 18:45:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/17679Introduction프로그래머스 문제에서는 이따금 게임 내용의 일부분을 구현하는 문제가 나온다.이번 문제가 딱 그런데, 정말 재미있게 풀었던 것 같다. 게임보다 구현해야 할 요구조건이 명확한 것도 없고 이해하기도 쉬운 것도 없다고 생각한다. 머릿속에서 더 쉽게 그려지니까.Note 필요한 행동(함수)을 미리 정의하고 이를 구현해 나가는 방식으로 진행Solutionfrom collections import dequeBLOCK_TABLE = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;BLOCK_DICT = {block:str(i) for i, block in enumerate(BLOCK_TABLE)}def valid_block(to_be_checked, given_block): if to_be_checked == &#39;-1&#39; or given_block == &#39;-1&#39;: return False elif to_be_checked == given_block: return True else: return to_be_checked == BLOCK_DICT[given_block]def mark(board): marked = False for y in range(len(board)): for x in range(len(board[0])): block = board[y][x] if block == &#39;-1&#39;: continue pos = [x-1, y, x, y-1, x-1, y-1] if any(p &amp;lt; 0 for p in pos) == True: continue if not valid_block(board[y][x-1], block) or \\ not valid_block(board[y-1][x], block) or \\ not valid_block(board[y-1][x-1], block): continue board[y][x-1] = BLOCK_DICT[block] board[y-1][x] = BLOCK_DICT[block] board[y-1][x-1] = BLOCK_DICT[block] board[y][x] = BLOCK_DICT[block] marked = True return markeddef delete(board): deleted_blocks = 0 for y in range(len(board)): for x in range(len(board[0])): if not board[y][x].isalpha() and int(board[y][x]) &amp;gt; -1: board[y][x] = &#39;-1&#39; deleted_blocks += 1 return deleted_blocksdef pulldown(board): for x in range(len(board[0])): blanks = deque() for y in range(len(board)-1, -1, -1): if board[y][x] == &#39;-1&#39;: blanks.append((x, y)) elif blanks: blank_x, blank_y = blanks.popleft() board[blank_y][blank_x] = board[y][x] board[y][x] = &#39;-1&#39; blanks.append((x,y))def solution(m, n, board): answer = 0 copied_board = [list(b) for b in board] while True: any_block_marked = mark(copied_board) if not any_block_marked: break deleted_blocks = delete(copied_board) answer += deleted_blocks pulldown(copied_board) return answer풀이1. 머릿속에서 시뮬레이션우선 문제와 그림을 보고 생각한다. 컴퓨터가 아닌 내가 이 문제를 직접 해결한다면 어떤 행동들이 필요할까?아마도 눈으로 퍼즐을 쭉 훑고, 4개씩 모여져 있는 곳에 마킹을 하고 지우지 않을까?def mark(board): passdef delete(board): passdef solution(m, n, board): answer = 0 return answer원래는 마킹과 지우는 것을 동시에 해야 하겠지만, 추후에 리팩토링을 하더라도 일단 단계별로 생각을 하자지운 다음에 퍼즐은 밑으로 떨어지겠지?def mark(board): passdef delete(board): passdef pulldown(board): passdef solution(m, n, board): answer = 0 return answer2. 주어진 함수들을 가지고 구현자 그럼 이 함수들이 구현이 되었다고 가정하고 주어진 함수를 사용해 상황을 만들어 보자.우선 파라미터로 받은 board를 변형시키는 것도 그렇고, string 형태면 중간에 있는 블록을 갈아끼거나 지우는게 번거로우므로 list 형태로 바꿔서 카피해준다.def mark(board): passdef delete(board): passdef pulldown(board): passdef solution(m, n, board): answer = 0 copied_board = [list(b) for b in board] return answer함수를 사용해서 구현 해보자. 아마 이런느낌이지 않을까?보드에 마킹하고, 지우고, 지운 블록 갯수를 정답에 더하고, 떠있는 블록들을 끌어내린다.def mark(board): passdef delete(board): passdef pulldown(board): passdef solution(m, n, board): answer = 0 copied_board = [list(b) for b in board] any_block_marked = mark(copied_board) deleted_blocks = delete(copied_board) answer += deleted_blocks pulldown(copied_board) return answer이걸 더 이상 마킹할 수 있는 블록이 없을 때까지 반복한다.def mark(board): passdef delete(board): passdef pulldown(board): passdef solution(m, n, board): answer = 0 copied_board = [list(b) for b in board] while True: any_block_marked = mark(copied_board) if not any_block_marked: break deleted_blocks = delete(copied_board) answer += deleted_blocks pulldown(copied_board) return answer3-1. 주어진 함수들을 구현 - mark()두 가지를 고려해야 한다. 어떻게 마킹해 나갈 것인가와, 마킹한 것을 어떤 방식으로 남겨놓을 것인가이다.어떻게 마킹할지 보니, 지난 포스팅의 가장 큰 정사각형 찾기 문제와 유사하다.이를 참고해서, 한 블록을 기준으로 그 블록의 왼쪽(x-1, y), 위쪽(x, y-1), 왼쪽 위(x-1, y-1)의 3방향을 체크하는 방식으로 마킹을 해보자.그리고 우선은, 지워진 블록은 &quot;-1&quot;로 표기되어 있다고 가정하자.def mark(board): for y in range(len(board)): for x in range(len(board[0])): block = board[y][x] # 기준 블록이 이미 지워진 블록이면 넘어가고 if block == &#39;-1&#39;: continue # 3방향 좌표 중 하나라도 인덱스 0보다 작으면 넘어가고 pos = [x-1, y, x, y-1, x-1, y-1] if any(p &amp;lt; 0 for p in pos) == True: continue # 아래의 3방향을 체크한다. board[y][x-1] board[y-1][x] board[y-1][x-1]자 이제 기준 블록의 3방향의 블록들을 체크해보자.def valid_block(to_be_checked, given_block): passdef mark(board): for y in range(len(board)): for x in range(len(board[0])): block = board[y][x] if block == &#39;-1&#39;: continue pos = [x-1, y, x, y-1, x-1, y-1] if any(p &amp;lt; 0 for p in pos) == True: continue # 어느 하나라도 기준에 부합하지 않으면 넘어간다. if not valid_block(board[y][x-1], block) or \\ not valid_block(board[y-1][x], block) or \\ not valid_block(board[y-1][x-1], block): continue블록은 마킹되고 나서도 마킹되지 않은 같은 종류의 블록과 동일하게 다룰 수 있어야 한다.이를 위해 특정 알파벳 블록을 집어넣으면 그와 연결된 숫자로 변환해주는 사전을 만들자.예를 들어 A(key)라는 블록을 집어넣으면 ‘0’(value)을, Z(key)를 집어넣으면 ‘25’(value)을 반환하는 사전이다.BLOCK_TABLE = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;BLOCK_DICT = {block:str(i) for i, block in enumerate(BLOCK_TABLE)}def valid_block(to_be_checked, given_block): passdef mark(board): for y in range(len(board)): for x in range(len(board[0])): block = board[y][x] if block == &#39;-1&#39;: continue pos = [x-1, y, x, y-1, x-1, y-1] if any(p &amp;lt; 0 for p in pos) == True: continue if not valid_block(board[y][x-1], block) or \\ not valid_block(board[y-1][x], block) or \\ not valid_block(board[y-1][x-1], block): continue3방향 블록들의 어떤 것들을 체크해야 할까? 블록들이 이미 지워졌는가? (하나라도 지워져 있다면 2X2의 단위 사각형을 이룰 수 없다.) 블록들이 같은 블록인가? 2-2. 이미 마킹되어 있다면 그 블록과 기준점 블록이 같은 종류의 블록인가?BLOCK_TABLE = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;BLOCK_DICT = {block:str(i) for i, block in enumerate(BLOCK_TABLE)}def valid_block(to_be_checked, given_block): if to_be_checked == &#39;-1&#39; or given_block == &#39;-1&#39;: return False elif to_be_checked == given_block: return True else: return to_be_checked == BLOCK_DICT[given_block]def mark(board): for y in range(len(board)): for x in range(len(board[0])): block = board[y][x] if block == &#39;-1&#39;: continue pos = [x-1, y, x, y-1, x-1, y-1] if any(p &amp;lt; 0 for p in pos) == True: continue if not valid_block(board[y][x-1], block) or \\ not valid_block(board[y-1][x], block) or \\ not valid_block(board[y-1][x-1], block): continue체크해서 문제가 없을 경우 4개의 블록을 전부 마킹해주고 marked를 True로 바꾼다.BLOCK_TABLE = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;BLOCK_DICT = {block:str(i) for i, block in enumerate(BLOCK_TABLE)}def valid_block(to_be_checked, given_block): if to_be_checked == &#39;-1&#39; or given_block == &#39;-1&#39;: return False elif to_be_checked == given_block: return True else: return to_be_checked == BLOCK_DICT[given_block]def mark(board): marked = False for y in range(len(board)): for x in range(len(board[0])): block = board[y][x] if block == &#39;-1&#39;: continue pos = [x-1, y, x, y-1, x-1, y-1] if any(p &amp;lt; 0 for p in pos) == True: continue if not valid_block(board[y][x-1], block) or \\ not valid_block(board[y-1][x], block) or \\ not valid_block(board[y-1][x-1], block): continue board[y][x-1] = BLOCK_DICT[block] board[y-1][x] = BLOCK_DICT[block] board[y-1][x-1] = BLOCK_DICT[block] board[y][x] = BLOCK_DICT[block] marked = True return marked3-2. 주어진 함수들을 구현 - delete()마킹된 블록은 모두 string 형태의 숫자이므로 이를 체크하고 삭제(“-1”)가 되어 있지 않다면 삭제해주고 삭제한 블록 개수를 세어준다.isalpha()는 해당 string이 알파벳으로만 이루어져 있는지 체크하는 내장함수이다.def delete(board): deleted_blocks = 0 for y in range(len(board)): for x in range(len(board[0])): if not board[y][x].isalpha() and int(board[y][x]) &amp;gt; -1: board[y][x] = &#39;-1&#39; deleted_blocks += 1 return deleted_blocks3-3. 주어진 함수들을 구현 - pulldown()위 그림의 A, B 블록을 떨어뜨릴 때는 아래와 같은 순서로 진행된다. 0번과 1번을 지나 2번의 빈칸을 발견한다. 빈칸의 좌표를 큐에 넣고 다음 칸으로 이동한다. 3번의 빈칸을 발견하고 똑같이 큐에 좌표를 넣고 다음칸으로 이동한다. 4번의 블록을 발견하고 아까 큐에서 빈칸 좌표를 하나 꺼내 그곳에 블록을 이동시키고 4번칸은 빈칸(“-1”) 처리 후 현재 좌표를 큐에 넣는다. 5번의 블록을 발견하고 큐에서 빈칸 좌표를 하나 꺼내 그곳에 블록을 이동시키고 5번칸은 빈칸처리 후 현재 좌표를 큐에 넣는다.이 1~5번 과정을 각 세로줄 마다 진행해 주면 된다.from collections import dequedef pulldown(board): for x in range(len(board[0])): blanks = deque() for y in range(len(board)-1, -1, -1): if board[y][x] == &#39;-1&#39;: blanks.append([x, y]) elif blanks: blank_x, blank_y = blanks.popleft() board[blank_y][blank_x] = board[y][x] board[y][x] = &#39;-1&#39; blanks.append([x, y])Comment풀고 나서 보니 너무 장황하고 길고 마킹할 때 게임판을 한 번, 지울 때 또 한 번 돌면서 수행시간도 더 길어지는것도 마음에 안 들어서 추후에 시간 나면 다시 풀어봐야겠다." }, { "title": "(프로그래머스) 가장 큰 정사각형 찾기", "url": "/posts/biggest-square/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 다이나믹 프로그래밍", "date": "2022-02-02 18:55:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/12905Introduction프로그래밍에서 가장 중요한 부분은 해결해야 할 문제를 나누어서 생각하는 것이다.아직도 많이 서툰 부분이긴 하지만, 이게 잘 안될 때는 한꺼번에 너무 많은 것들을 동시에 고민하다보니 머리속에서 꼬여서 문제 해결이 너무 힘들었던 경우가 있었다.이번 문제 해결에서는 단위 정사각형을 만들고 그 단위 정사각형을 기준으로 체크해 나가며 규칙을 파악한 뒤 문제 풀이에 적용한다.Note 2X2의 단위 정사각형을 먼저 생각해보고, 이를 움직이며 체크해 나간다.Solutiondef solution(board): if len(board) == 1: return max(board[0]) answer = 0 for i in range(1, len(board)): for j in range(1, len(board[0])): if board[i][j] == 1: board[i][j] = 1 + min(board[i-1][j-1], board[i][j-1], board[i-1][j]) answer = max(answer, board[i][j]) if answer == 0: for i in range(len(board)): answer = max(answer, board[i][0]) return answer ** 2풀이1. 단위 정사각형 체크우선 아래와 같은 정사각형들을 생각해보자. 이 정사각형(2X2)들은 앞으로 체크해나갈 기본 단위 사각형이다.이 단위 정사각형의 한 변의 길이가 2가 되는 기준은 모든 작은 사각형의 숫자가 1일 때이다. (하나라도 0이 섞여 있을 경우 단위 정사각형을 만들 수 없으므로)이걸 체크하는 방법은 색칠되어 있는 칸(x,y)을 기준으로 왼쪽(x-1, y), 위쪽(x, y-1), 왼쪽 위(x-1, y-1) 3방향의 사각형의 숫자가 모두 1인지 아닌지를 체크 하는 것이다.이걸 코드로 구현해보자. 보편적인 체크를 위해 (1,1) 위치에서부터 체크해 나간다. (위에서 그린 사각형의 색칠한 부분)def solution(board): for y in range(1, len(board)): for x in range(1, len(board[0])): if board[y][x] == 1: # 아래의 3개의 값이 1인지 체크만 하면 된다. board[y][x-1] # 왼쪽 board[y-1][x] # 위쪽 board[y-1][x-1] # 왼쪽 위2. 지뢰찾기체크하는 건 끝났으니 실제로 넓이를 구해보기 전에 우선 아래의 단위 사각형에 대해 생각해보자.? 안에 들어갈 숫자는 무엇일까?이를 알아보기 위해 주어진 사각형을 단위 사각형 별로 체크하며 확장시켜 나가보자.우선 진하게 색칠된 사각형을 기준으로, 이 사각형의 숫자가 1이기 위해서는 왼쪽과 왼쪽위 사각형의 숫자가 몇이어야 할까?어느쪽이든 하나는 값이 0이어야 한다. 둘 다 1 이상이면 단위 사각형이 완성되어버려 진하게 칠해진 숫자가 2가 될 수 밖에 없기 때문이다.또한, 숫자가 3인 사각형 옆의 사각형은 무조건 1 이상이다. 그렇지 않으면 단위 사각형이 완성되지 않기 때문이다. 따라서 위 그림과 같이 1과 0을 적어둔다.다음은 숫자가 2인 사각형을 보자. 이 사각형은 알기 쉽다. 3방향(왼쪽, 위쪽, 왼쪽위) 모두 숫자가 1 이상이면 된다. 일단 1로 적어두고 다음으로 넘어간다.이번에는 숫자가 3인 사각형을 체크해보자. 숫자가 3이기 위해서는 옅게 칠해진 모든 부분의 숫자가 1 이상이어야 한다. 따라서 우선은 1을 전부 채워둔다.다시 체크해보니 숫자가 모두 1은 아니다. 숫자가 2이어야 하는 부분은 숫자를 갱신해준다.진하게 색칠된 부분의 넓이가 1이기 위해서는 위쪽 사각형의 숫자가 0이어야 한다.마지막으로 남은 부분을 채워준다. 진하게 색칠된 부분의 숫자가 0이려면 바로 옆에 있는 사각형의 숫자도 0이어야 한다.표를 완성해놓고보니 규칙을 발견할 수 있다. 어떤 사각형의 숫자가 1 이상이라면 그 숫자는 3방향(왼쪽, 위쪽, 왼쪽위)의 사각형들의 숫자 중 가장 작은 것 + 1이라는 점이다. 따라서 ?에 들어갈 숫자는 2이다.그리고 표에서 숫자가 1 이상인 사각형들을 다 칠해보면 더 명확하게 알 수 있다.이 사실을 참고하여 숫자를 갱신하는 부분을 코드로 구현해 보자.def solution(board): for y in range(1, len(board)): for x in range(1, len(board[0])): if board[y][x] == 1: board[y][x] = 1 + min(board[y][x-1], board[y-1][x], board[y-1][x-1]) # 23. 최대 넓이 구하기아까 그 값들 중 숫자가 큰 값이 가장 큰 정사각형의 한 변의 길이이므로, 이를 저장해 두었다가 제곱한 값을 반환한다.def solution(board): answer = 0 for y in range(1, len(board)): for x in range(1, len(board[0])): if board[y][x] == 1: board[y][x] = 1 + min(board[y][x-1], board[y-1][x], board[y-1][x-1]) answer = max(answer, board[y][x]) # 3 return answer ** 24. 코너 케이스단위 정사각형이 2X2 사각형이기에 위 풀이에는 한 가지 고려하지 않은 것이 있다. 바로 아래와 같은 케이스이다.이 케이스를 고려하여 코드에 반영한다.def solution(board): if len(board) == 1: # 그림의 왼쪽 케이스 return max(board[0]) answer = 0 for y in range(1, len(board)): for x in range(1, len(board[0])): if board[y][x] == 1: board[y][x] = 1 + min(board[y][x-1], board[y-1][x], board[y-1][x-1]) answer = max(answer, board[y][x]) if answer == 0: # 그림의 오른쪽 케이스 for i in range(len(board)): answer = max(answer, board[i][0]) return answer ** 2Comment일일이 표 만들고 편집하느라 푸는 시간보다 정리하는 시간이 훨씬 더 많이 걸렸다. 그래도 만들어 놓고 보니 뭔가 뿌듯…" }, { "title": "2019 카카오 개발자 겨울 인턴십 튜플", "url": "/posts/kakao-tuple/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2019, 카카오, 정규표현식", "date": "2022-01-31 19:49:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/64065Introduction짧은 코드를 신봉하던 시절이 있었다. 읽어야 할 것도 적고 고려해야 할 것도 적기 때문에 짧을수록 다른 사람이 더 이해하기 좋은 코드라고 생각했었다.물론 이건 반은 맞고 반은 틀린 이야기. 아무리 짧은 코드라도 이해하기 난해한 코드도 있다. 특히 어떤 언어에 종속된 문법에 의존할수록 더 그런 경우가 많은 것 같다.그런 코드일수록 스토리가 담긴 문장보다는 무언가 자기네들끼리만 아는 규칙으로 도배해놓은 수학 공식 같은 느낌이 강하게 드는 코드가 많았다.짧지만 농도가 짙은 한 줄은 오히려 그 한 줄을 해석하는데 더 많은 정신적 에너지를 소모해야 한다. 차라리 그걸 2~3줄로 풀어 설명하는 것이 훨씬 나을수도 있다.Note 튜플 안에 담기는 원소의 순서는 가장 많이 출현한 숫자의 순서이다.Solutionimport refrom collections import defaultdictdef solution(s): dic, no_sets = defaultdict(int), re.findall(r&#39;(\\{[\\d,?]+\\})&#39;, s) for no_set in no_sets: for no in no_set[1:-1].split(&#39;,&#39;): dic[no] += 1 return list(map(lambda x: int(x[0]), sorted(dic.items(), key=lambda y: -y[1])))Comment이번 코드는 일부러 짧지만 가독성이 나쁘게 작성해보았다. 그리고 하나쯤 포스트로 남겨놓고 이런 나쁜 습관을 몸에 지니지 않게 기억해두는 것도 좋겠다고 생각했다.최근의 코딩테스트에는 언어의 제한이 없다. 이건 어떤 언어로 작성해도 이해하기 쉽게 내용이 명료한 방식으로 코드를 작성하라는 의미가 아닐까? 그러니까 제발 시간제한을 짧게 해서 마감에 쫓기듯이 코딩하지 않게 해주세요" }, { "title": "2018 KAKAO BLIND RECRUITMENT [1차] 뉴스 클러스터링", "url": "/posts/kakao-news-clustering/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2018, 카카오, 블라인드, 집합", "date": "2022-01-28 11:10:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/17683Introduction다중집합이라는 키워드를 보고 바로 set을 썼다가 중복된 원소 다루는 게 까다로워서 dictionary를 써서 풀었는데 다른 사람 풀이 보니까 set을 쓰고도 잘만 푼거 보고 놀랐다.언제나 다른 사람들의 풀이를 보고 많이 배운다. 참 대단한 사람들이 많은듯집합(Hashed Set)은 정말 매력적인 자료구조인 것 같다. 엄청 많은 데이터를 중복 없이 저장하면서 해당 자료를 O(1)로 가져오기 때문에 n이 많은 경우를 고려하는 알고리즘 문제에서 사용하기에 너무 좋다.Note 특수문자나 숫자가 포함된 문자열을 버리는 타이밍이 문자쌍을 만드는 순간이어야 한다. 교집합, 합집합이 맞게 잘 만들었는지 체크Solutionimport refrom collections import defaultdictdef get_valid_str(s): result = re.findall(r&#39;[A-Za-z]&#39;, s) return result[0] if result else &#39;&#39;def get_dict(string): result = defaultdict(int) for i in range(1, len(string)): s1 = get_valid_str(string[i-1]) s2 = get_valid_str(string[i]) if len(s1+s2) == 2: result[s1+s2] += 1 return resultdef solution(str1, str2): s1, s2 = str1.lower(), str2.lower() intersection, union = [], [] s1_dict = get_dict(s1) s2_dict = get_dict(s2) for k, v in s1_dict.items(): if k in s2_dict: most = max(s1_dict[k], s2_dict[k]) least = min(s1_dict[k], s2_dict[k]) union += [k] * most intersection += [k] * least else: union += [k] * v for k, v in s2_dict.items(): if k not in s1_dict: union += [k] * v answer = len(intersection) / len(union) if len(union) != 0 else 1 return int(answer * 65536)아래는 set과 내장함수를 이용한 다른 사람의 멋진 풀이다. isalpha()는 해당 문자열이 알파벳으로만 이루어져 있는지를 체크한다.def solution(str1, str2): list1 = [str1[n:n+2].lower() for n in range(len(str1)-1) if str1[n:n+2].isalpha()] list2 = [str2[n:n+2].lower() for n in range(len(str2)-1) if str2[n:n+2].isalpha()] tlist = set(list1) | set(list2) res1 = [] #합집합 res2 = [] #교집합 if tlist: for i in tlist: res1.extend([i]*max(list1.count(i), list2.count(i))) res2.extend([i]*min(list1.count(i), list2.count(i))) answer = int(len(res2)/len(res1)*65536) return answer else: return 65536" }, { "title": "2018 KAKAO BLIND RECRUITMENT [3차] 방금그곡", "url": "/posts/kakao-the-very-music/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2018, 카카오, 블라인드, 시뮬레이션, 힙", "date": "2022-01-27 23:17:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/17683Introduction나는 이미 짜둔 코드를 여러 번 다시 보는 것을 좋아한다. 시간이 없어 난장판으로 짠 코드를 리팩토링해서 다듬고 나만의 예술 작품으로 만들어 계속해서 감상하는 것을 좋아한다.더 간결하고 이해하기 쉬운 문장(코드)을 작성할 때 매우 흐뭇하고 이게 내가 코딩을 하는 가장 원초적인 원동력이 되는 것 같다. 계속해서 글을 고쳐쓰는 것과 같은 즐거움. 나는 그래서 코딩을 멈출 수가 없다.이번 문제도 풀어놓고 한참을 들여다 본 것 같다. 단순한 구현 문제이기 때문에 어려울 건 없지만, 그저 써놓은 문장을 여러번 고치면서 즐거웠다.Note &quot;ADEACC#BA#&quot;과 같이 연결된 string을 순회할 때 C# -&amp;gt; c로 변환하는 등의 방법으로 문자를 한 인덱스로 셀 수 있도록 해야함. &quot;ADEACC#BA#&quot; -&amp;gt; &quot;ADEACcBa&quot; Solutionimport heapqdef replace_sharps(melody): result = [] for mel in melody: if mel == &#39;#&#39;: result[-1] = result[-1].lower() else: result.append(mel) return &#39;&#39;.join(result)def play(melody, duration): n = len(melody) quotient, remainder = duration // n, int(duration % n) return melody * quotient + melody[:remainder]def convert_to_minute(time): h, m = time.split(&quot;:&quot;) return 60 * int(h) + int(m)def solution(m, musicinfos): answer, mel = [], replace_sharps(m) for i, info in enumerate(musicinfos): start, end, name, melody = info.split(&#39;,&#39;) start, end = convert_to_minute(start), convert_to_minute(end) duration = end - start melody = replace_sharps(melody) played_melody = play(melody, duration) if mel in played_melody: heapq.heappush(answer, [-len(played_melody), i, name]) return answer[0][2] if answer else &quot;(None)&quot; musicinfo에서 하나씩 시작시간과 끝나는 시간, 곡명, 멜로디 등을 추출한다. 이 때 멜로디에서 샵들은 전부 소문자로 변환하여 사용한다. 연주시간 만큼 멜로디를 길게 늘어뜨리고 그 멜로디 안에 네오가 들었던 멜로디가 있는지 찾고 있으면 정답 힙에 정렬 순서대로 맞춰서 넣는다. 정렬되어 있는 힙의 가장 맨 위의 멜로디의 곡명을 반환한다." }, { "title": "2018 KAKAO BLIND RECRUITMENT [3차] 파일명 정렬", "url": "/posts/kakao-sorted-files/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2018, 카카오, 블라인드, 정규표현식, 정렬", "date": "2022-01-25 18:32:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/17686Introduction세상엔 머리 좋은 사람들이 많은 것 같다. 해결해야 하는 문제를 보고 발상 자체를 바꿔서 다른 방식으로 해석하고 더 인텔리전트한 방법으로 풀어나가는 걸 보면 정말 경이롭기까지 하다.간단한 구현 문제였던 이 문제를 가져온 이유는 평소 약했던 정규표현식을 제대로 다시 공부하여 짧고 깔끔한 풀이를 하고 이를 기억하기 위함이었다.꽤 명료하고 짧은 코드를 작성한 뒤 자신에 차 다른 사람의 풀이를 확인하던 내가 발견한건 단 2줄짜리 코드…심지어 수행시간도 큰 차이가 없다.나도 언젠간 저런 발상을 역전한 코드를 짜야지Note 대소문자를 구별하지 않는 점에 주의 head에 공백(“ “)과 빼기 부호(“-“)가 포함될 수 있다는 조건에 주의. head가 F-가 될 수도 있고 F- 가 될 수도 있다. Solution 파일명에서 HEAD와 NUMBER를 나눠주고 정렬 기준에 따라 힙에 넣어 자동으로 정렬되며 차곡차곡 쌓이도록 한다. heap에 쌓인 순서대로 파일명만 꺼내어 정답리스트에 넣고 반환한다.import re, heapqdef solution(files): answer, heap = [], [] for i, file in enumerate(files): # 1 split_file = file.split(&#39;.&#39;)[0] head, no = re.findall(&#39;^([A-z\\-\\s]+)(\\d+)&#39;, split_file)[0] head, no = head.lower(), int(no) heapq.heappush(heap, [head, no, i, file]) while heap: # 2 answer.append(heapq.heappop(heap)[3]) return answer그리고 아래가 바로 그 문제의 풀이다..import redef solution(files): a = sorted(files, key=lambda file : int(re.findall(&#39;\\d+&#39;, file)[0])) b = sorted(a, key=lambda file : re.split(&#39;\\d+&#39;, file.lower())[0]) return b" }, { "title": "2018 KAKAO BLIND RECRUITMENT [3차] 압축", "url": "/posts/kakao-compression/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2018, 카카오, 블라인드, 투포인터, 슬라이딩 윈도우", "date": "2022-01-24 14:56:00 +0900", "snippet": "Link https://programmers.co.kr/learn/courses/30/lessons/17684Introduction나한테는 안 좋은 습관이 있다. 바로 코딩하기 전에 내가 해결하려는 문제가 명확하고 깔끔한 어떤 절대적 진리와도 같은(마치 유명한 수학 공식들과도 같이 아름다운 형태를 지닌) 풀이가 있을 것이라고 생각하고 코딩하는 것이다.이 사고방식은 때때로 내 발목을 잡는데 바로 처음 겪는 문제를 해결할 때 일단 도전해보기 전에 (또는 도전하는 도중에도) 생각이 많아지게 하는 것이 그렇다.더 좋은 방법이 있을거야..찾아내야 해그래서 문제를 풀기 전이나 심지어 푸는 도중에도 끊임없이 “아 이건 아닌거 같은데”, “더 좋은 방법이 있을텐데”라는 생각을 하며 코딩을 한다. 지금 작성하고 있는 코드가 완성되기도 전에 말이다.당연히 문제에 집중이 될리가 없고, 자꾸 제자리만 멤도는 경우가 많았다.이번 문제를 풀면서 특히 그랬던 것 같다. 보자마자 딱 떠오른 것은 트라이 알고리즘이었는데 풀이를 보면 알겠지만 그런거 관계없고 그냥 문제에 써져 있는대로 구현하면 된다.처음에는 정말 되는대로 풀었다가 리팩토링하고 나니 문제에 써져있는대로 구현이 되어 있었다.문제를 해결할 때 처음부터 너무 완벽하게 하려고 하는게 언제나 좋지만은 않을 수도 있겠다는 생각이 들었다. 일단 해결하고 보완하는 것이 아예 모르는 문제를 해결할 때는 더 적합하겠다는 생각이 든다.Note 슬라이딩 윈도우 알고리즘을 사용SolutionWORD_TABLE = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;def solution(msg): answer, index = [], 27 word_dic = {word:i+1 for i, word in enumerate(WORD_TABLE)} left, right = 0, 1 while right &amp;lt;= len(msg): word, next_word = msg[left:right], msg[left:right+1] if word in word_dic and next_word not in word_dic: answer.append(word_dic[word]) word_dic[next_word] = index index += 1 left = right right += 1 answer.append(word_dic[msg[left:]]) return answer풀이1, 필요한 변수들과 사전(dictionary)을 준비해둔다. 사전에는 미리 알파벳에 인덱스를 붙인 값을 넣어서 준비한다. ex) word_dic[word] = 12알파벳은 총 26글자 이므로 다음 인덱스는 27로 미리 세팅해 놓는다.WORD_TABLE = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;def solution(msg): answer, index = [], 27 word_dic = {word:i+1 for i, word in enumerate(WORD_TABLE)} # 12, 포인터를 두 개 두고 right를 끝까지 움직이도록 한다.WORD_TABLE = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;def solution(msg): answer, index = [], 27 word_dic = {word:i+1 for i, word in enumerate(WORD_TABLE)} left, right = 0, 1 while right &amp;lt;= len(msg): # 2 word = msg[left:right] right += 13, 사전에 있는 단어면 정답 리스트에 넣고 left의 위치를 옮겨준다.WORD_TABLE = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;def solution(msg): answer, index = [], 27 word_dic = {word:i+1 for i, word in enumerate(WORD_TABLE)} left, right = 0, 1 while right &amp;lt;= len(msg): word = msg[left:right] if word in word_dic: # 3 answer.append(word_dic[word]) left = right right += 14, 3번의 과정만으로는 압축이 안되므로, (사전에는 ‘A’, ‘B’와 같은 한 단어들만 있을테니) 압축을 시켜주기 위해 다음 글자까지 포함된 string이 사전에 있는지를 체크하고 있으면 right만 한 칸 옮기고, 없으면 다음 글자까지 포함된 string을 사전에 넣고 현재 글자를 정답에 넣는다.WORD_TABLE = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;def solution(msg): answer, index = [], 27 word_dic = {word:i+1 for i, word in enumerate(WORD_TABLE)} left, right = 0, 1 while right &amp;lt;= len(msg): word = msg[left:right] if word in word_dic: if msg[left:right+1] in word_dic: # 4 right += 1 continue else: word_dic[msg[left:right+1]] = index index += 1 answer.append(word_dic[word]) left = right right += 15, 위 로직은 마지막 단어가 사전에 들어있든 없든 절대 answer.append(word_dic[word]) 부분으로 가지 못한다. 따라서 마지막 문자를 정답에 넣어주고 반환한다.WORD_TABLE = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;def solution(msg): answer, index = [], 27 word_dic = {word:i+1 for i, word in enumerate(WORD_TABLE)} left, right = 0, 1 while right &amp;lt;= len(msg): word = msg[left:right] if word in word_dic: if msg[left:right+1] in word_dic: right += 1 continue else: word_dic[msg[left:right+1]] = index index += 1 answer.append(word_dic[word]) left = right right += 1 answer.append(word_dic[msg[left:]]) # 5 return answer근데 이렇게 작성하고 보니까 풀이가 너무 지저분하고, if문을 살펴보니 리팩토링을 할 여지가 보였다.그래서 리팩토링을 하니 아래와 같이 깔끔하게 정리가 되었다.WORD_TABLE = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;def solution(msg): answer, index = [], 27 word_dic = {word:i+1 for i, word in enumerate(WORD_TABLE)} left, right = 0, 1 while right &amp;lt;= len(msg): word, next_word = msg[left:right], msg[left:right+1] if word in word_dic and next_word not in word_dic: answer.append(word_dic[word]) word_dic[next_word] = index index += 1 left = right right += 1 answer.append(word_dic[msg[left:]]) return answer리팩토링 해놓고 보니 문제에 써져 있는 풀이방법과 유사하다....예를 들어 입력으로 `KAKAO`가 들어온다고 하자.1. 현재 사전에는 `KAKAO`의 첫 글자 `K`는 등록되어 있으나, 두 번째 글자까지인 `KA`는 없으므로, 첫 글자 `K`에 해당하는 색인 번호 11을 출력하고, 다음 글자인 `A`를 포함한 `KA`를 사전에 27 번째로 등록한다.2. 두 번째 글자 `A`는 사전에 있으나, 세 번째 글자까지인 `AK`는 사전에 없으므로, `A`의 색인 번호 1을 출력하고, `AK`를 사전에 28 번째로 등록한다.3. 세 번째 글자에서 시작하는 `KA`가 사전에 있으므로, `KA`에 해당하는 색인 번호 27을 출력하고, 다음 글자 `O`를 포함한 `KAO`를 29 번째로 등록한다.4. 마지막으로 처리되지 않은 글자 `O`에 해당하는 색인 번호 15를 출력한다....때로는 처음부터 정확한 접근법으로 풀어나가지 않아도 된다. 일단 도전하고 조금씩 고치고 수정하다보면 세련된 결과물이 나올거라 믿는다." }, { "title": "2018 KAKAO BLIND RECRUITMENT [3차] n진수 게임", "url": "/posts/kakao-n-base-game/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2018, 카카오, 블라인드, 큐", "date": "2022-01-21 14:48:00 +0900", "snippet": "Updated at 2022-01-30Link https://programmers.co.kr/learn/courses/30/lessons/17687Introduction알고리즘 문제를 풀다보면 언제나 드는 고민이 있다. 1, 내가 머리를 써서 좋은 방법을 생각해 컴퓨터에게 가르쳐 줄 것인가? 2, 주어진 조건을 컴퓨터에게 주고 시뮬레이션을 시켜 문제를 풀게 할 것인가? 소프트웨어의 세계에서 우리는 무한한 자원을 가지고 뭐든 할 수 있다머리가 좋지 않고(그리고 귀찮아 하는) 간결한 코드를 선호하는 나는 주로 후자를 선택하곤 하는데, 이러한 경향이 코딩 스타일에도 드러나는 편이다.그래서 DP 문제에서 시간초과가 안나면 일단 재귀를 써서 풀려고 하고(base condition과 k일 때, k+1일 때의 경우만 지정해 주면 계산이 빠른 컴퓨터가 알아서 풀어줄테니까), 지난 포스팅인 2022 KAKAO BLIND RECRUITMENT 양궁대회에서도 더 적은 화살을 맞춘 개수를 구할 때에도 직접 골라내는 함수를 구현하기 보다 sort() 함수를 먼저 돌려보는 방식을 선택했다.이번 문제도 그런식이었다. 숫자를 n진수로 바꾸고 자릿수를 몇으로 나누고 몇 번째 숫자만 골라서 반환하면 수행시간도 적고 좀 더 괜찮은 알고리즘이 나올 수도 있을지 모르겠지만(아마도 그럴 것이다.) 일단 컴퓨터한테 하라고 시켜보고 시간초과나면 바꿔야지라는 생각으로 조건을 주고 시뮬레이션 시켰다.물론 절대 좋은 습관은 아닌 것 같다. 효율성을 생각하면 코드를 작성하면서 이게 수행시간이 얼마나 걸릴것인지를 꼼꼼히 따져봐야하는데…아직 갈 길이 멀은 것 같다.Note 숫자가 0부터 시작하는 것에 주의 10진수 이상부터는 알파벳이 들어간다.Solutionfrom collections import dequeNO_DIC = { 10: &quot;A&quot;, 11: &quot;B&quot;, 12: &quot;C&quot;, 13: &quot;D&quot;, 14: &quot;E&quot;, 15: &quot;F&quot;}def convert_no(no, n): nums, quotient = &#39;&#39;, no while quotient &amp;gt; 0: quotient, remainder = quotient // n, int(quotient % n) remainder = str(remainder) if remainder &amp;lt; 10 else NO_DIC[remainder] nums = remainder + nums return nums if no &amp;gt; 0 else &#39;0&#39;def solution(n, t, m, p): answer, order_queue = &#39;&#39;, deque([i+1 for i in range(m)]) no = 0 while len(answer) &amp;lt; t: converted_no = convert_no(no, n) for number in converted_no: if len(answer) == t: break if order_queue[0] == p: # 4 answer += number order_queue.rotate(-1) no += 1 return answer풀이1, 순서대로 숫자를 말하는 상황을 재현하기 위해서 순서큐를 준비한다. 큐에는 m명의 사람들을 번호순으로 대기시킨다.from collections import dequedef solution(n, t, m, p): answer, order_queue = &#39;&#39;, deque([i+1 for i in range(m)]) # 12, 게임을 진행하기 앞서 숫자를 n진수로 변환하는 함수를 준비한다.16진수까지 구한다는 조건이므로 10~15의 경우에는 각 숫자에 해당하는 알파벳으로 변환하여 만들어준다.from collections import dequeNO_DIC = { 10: &quot;A&quot;, 11: &quot;B&quot;, 12: &quot;C&quot;, 13: &quot;D&quot;, 14: &quot;E&quot;, 15: &quot;F&quot;}def convert_no(no, n): nums, quotient = &#39;&#39;, no while quotient &amp;gt; 0: quotient, remainder = quotient // n, int(quotient % n) remainder = str(remainder) if remainder &amp;lt; 10 else NO_DIC[remainder] nums = remainder + nums return nums if no &amp;gt; 0 else &#39;0&#39;def solution(n, t, m, p): answer, order_queue = &#39;&#39;, deque([i+1 for i in range(m)])3, 우선 가볍게 연습게임으로 혼자 진행해보자. 숫자는 0부터 시작하고 변환된 숫자를 계속해서 말하기만 하면 된다.총 t개의 숫자를 말할때까지 반복한다.from collections import dequeNO_DIC = { 10: &quot;A&quot;, 11: &quot;B&quot;, 12: &quot;C&quot;, 13: &quot;D&quot;, 14: &quot;E&quot;, 15: &quot;F&quot;}def convert_no(no, n): nums, quotient = &#39;&#39;, no while quotient &amp;gt; 0: quotient, remainder = quotient // n, int(quotient % n) remainder = str(remainder) if remainder &amp;lt; 10 else NO_DIC[remainder] nums = remainder + nums return nums if no &amp;gt; 0 else &#39;0&#39;def solution(n, t, m, p): answer, order_queue = &#39;&#39;, deque([i+1 for i in range(m)]) no = 0 while len(answer) &amp;lt; t: # 3 converted_no = convert_no(no, n) for number in converted_no: if len(answer) == t: break answer += number no += 14, 자 이제는 다 같이 진행한다.달라진 점은 이제 숫자를 내 차례일 때만 말하고 순서가 계속 로테이션 되는 것 밖에 없다.from collections import dequeNO_DIC = { 10: &quot;A&quot;, 11: &quot;B&quot;, 12: &quot;C&quot;, 13: &quot;D&quot;, 14: &quot;E&quot;, 15: &quot;F&quot;}def convert_no(no, n): nums, quotient = &#39;&#39;, no while quotient &amp;gt; 0: quotient, remainder = quotient // n, int(quotient % n) remainder = str(remainder) if remainder &amp;lt; 10 else NO_DIC[remainder] nums = remainder + nums return nums if no &amp;gt; 0 else &#39;0&#39;def solution(n, t, m, p): answer, order_queue = &#39;&#39;, deque([i+1 for i in range(m)]) no = 0 while len(answer) &amp;lt; t: converted_no = convert_no(no, n) for number in converted_no: if len(answer) == t: break if order_queue[0] == p: # 4 answer += number order_queue.rotate(-1) no += 1 return answer" }, { "title": "Sliding Window", "url": "/posts/sliding-window/", "categories": "알고리즘, 이론", "tags": "알고리즘, 부분배열의 합, 투포인터, 슬라이딩 윈도우", "date": "2022-01-20 19:58:00 +0900", "snippet": "IntroductionSliding Window 알고리즘을 처음 접한게 언제였는지 기억이 안나지만 조금 헷갈리기 시작해 시간을 들여 정리해두면 다신 안 까먹겠지 싶어서 포스팅을 하게 됐다.LeetCode 문제를 풀다 보면 연습유형으로 굉장히 많이 보게 되는 단어가 있다. median(중간값), subset, subtree, subarray, …그 중에서도 subarray의 부분배열의 합에 대한 문제는 Sliding Window 알고리즘을 사용하기에 제격인데, 아주 명확하게 풀이가 된 곳(https://www.geeksforgeeks.org/find-subarray-with-given-sum/)이 있어서 참고하면서 정리해봤다.Brute Force아래와 같은 상황을 생각해보자. Input: arr = [1, 4, 20, 3, 10, 5], sum = 33 Output: 부분배열의 합 중 가장 길이가 긴 배열. 없을 경우 -1을 반환n(arr의 길이)이 한 1000 이하라면 아래와 같이 모든 부분 배열을 다 체크하는 풀이로 간단하게 끝낼 수 있을 것이다.# Brute Force [O(n^2)]def solution(arr, sum_): answer = [-1] for i in range(len(arr)): for j in range(i+1, len(arr)): if sum(arr[i:j]) == sum_: answer.append(arr[i:j]) return sorted(answer, key=len)[-1]n이 1000 이하일 경우 O(n^2)이니까 1,000,000번의 수행으로 끝나서 시간초과는 안날테지만 그 이상의 경우 더 짧은 시간 안에 해결해야 한다.여기서 사용되는 게 Sliding Window 알고리즘이다.Sliding Window나는 사실 슬라이딩 윈도우라고 하는 이름을 듣고 이 알고리즘이 어떻게 동작하는지 바로 떠올리기가 어려웠다. 오히려 이걸 앞뒤가 자유자재로 늘어나는 지렁이 한 마리가 배열 위를 기어가는걸 연상했다.슬라이딩 지렁이 윈도우 알고리즘에서는 포인터를 2개(left, right) 두고 이 포인터를 움직이면서 포인터 안에 있는 배열을 체크하며 앞으로 나아간다.더 많은 부분 배열을 포함할 수 있을 것 같다 싶으면 머리(right)가 전진하고, 부분 배열의 합이 특정 값을 넘을 경우 꼬리(left) 한 칸씩 줄어들어 부분 배열의 값을 줄이며 부분 배열의 합을 체크하는 방식이다.이런 느낌…Solution1, 우선 필요한 변수들을 준비해 둔다. 지렁이의 머리가 인덱스 1부터 시작하므로 현재 부분 배열의 합에는 배열의 첫번째 값을 미리 넣어 놓는다.def solution2(arr, sum_): answer = [-1] cur_sum, n = arr[0], len(arr) left, right = 0, 12, 지렁이 머리를 끝까지 움직이면서 계속 더해 나간다.def solution2(arr, sum_): answer = [-1] cur_sum, n = arr[0], len(arr) left, right = 0, 1 while right &amp;lt;= n: #2 if right &amp;lt; n: cur_sum += arr[right] right += 13, 더하다가 혹시라도 합이 원하는 수치와 일치하면 정답 리스트에 넣는다.def solution2(arr, sum_): answer = [-1] cur_sum, n = arr[0], len(arr) left, right = 0, 1 while right &amp;lt;= n: if cur_sum == sum_: #3 answer.append(arr[left:right]) if right &amp;lt; n: cur_sum += arr[right] right += 14, right가 전진하다보면 필요 이상으로 더할 때가 있다. 부분 배열의 합이 sum_보다 높아지는 경우인데, 이 때는 left가 right의 바로 이전 위치로 올 때까지 체크하면서 기존에 구해뒀던 부분 합에서 하나씩 빼준다.def solution2(arr, sum_): answer = [-1] cur_sum, n = arr[0], len(arr) left, right = 0, 1 while right &amp;lt;= n: while cur_sum &amp;gt; sum_ and left &amp;lt; right - 1: #4 cur_sum -= arr[left] left += 1 if cur_sum == sum_: answer.append(arr[left:right]) if right &amp;lt; n: cur_sum += arr[right] right += 15, 이 과정을 끝낸 후 정답 리스트를 길이 순으로 정렬하고 가장 마지막(가장 긴 길이의) 부분배열을 반환하면 된다.# Sliding Window [O(n)]def solution2(arr, sum_): answer = [-1] cur_sum, n = arr[0], len(arr) left, right = 0, 1 while right &amp;lt;= n: while cur_sum &amp;gt; sum_ and left &amp;lt; right - 1: cur_sum -= arr[left] left += 1 if cur_sum == sum_: answer.append(arr[left:right]) if right &amp;lt; n: cur_sum += arr[right] right += 1 return sorted(answer, key=len)[-1] #5처음에는 어떻게 한 방향으로만 전진만 하는데 빠지는 것 없이 모든 유효한 부분 배열을 체크할 수 있을까 하는 의구심이 들었는데, 그림을 그리고 손가락으로 포인터를 가리키며 이것저것 해보다 보니 이해가 됐다. 부분 합이 초과될 때마다 지렁이의 머리는 멈추고 꼬리는 앞으로 움직인다. 꼬리가 멈춰서는 지점에서의 부분배열의 합은 언제나 sum_보다 낮거나 같고 이러한 매 지점을 체크포인트로 하여 그 앞의 배열들을 체크해 나가기 때문에 가능성이 있는(부분배열의 합이 낮거나 같은) 배열들은 모두 체크를 할 수 있다.References https://www.geeksforgeeks.org/find-subarray-with-given-sum/" }, { "title": "2022 KAKAO BLIND RECRUITMENT 양궁대회", "url": "/posts/kakao-archery/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2022, 카카오, 블라인드, 완전탐색", "date": "2022-01-19 19:04:00 +0900", "snippet": "Updated at 2022-01-30Link https://programmers.co.kr/learn/courses/30/lessons/92342Introduction이번에도 달라진 풀이 방법을 적용하여 다시 풀어본다. 아이디어는 똑같다. 화살을 가지고 큰 점수부터 점수판을 순회하며 쏠지 말지 결정한다. 점수 계산을 하고 의미 있는 점수면 수집한다. 점수판 중 가장 적게 맞춘 점수판을 골라 반환한다.Note n이 크지 않아 완전탐색으로 풀어도 충분하다. 같은 득점 중에서도 적은 점수를 많이 맞춘 결과를 선택할 것 문제를 잘 읽읍시다. 카카오 프렌즈의 캐릭터 이름은 ‘lion’이 아니라 ‘ryan’ 입니다.SolutionSCORE_TABLE = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]answer = []max_score = 0def get_score(ryan, apeach): score = 0 for i in range(len(ryan)): if ryan[i] &amp;gt; apeach[i]: score += SCORE_TABLE[i] elif ryan[i] &amp;lt; apeach[i]: score -= SCORE_TABLE[i] return scoredef shoot(i, arrows, ryan, apeach): global max_score if i == len(ryan)-1 or arrows == 0: ryan_board = [_ for _ in ryan] ryan_board[i] += arrows score = get_score(ryan_board, apeach) if 0 &amp;lt; score and score == max_score: answer.append(ryan_board[::-1]) # 7 elif score &amp;gt; max_score: max_score = score answer.clear() answer.append(ryan_board[::-1]) # 7 return if arrows &amp;gt; 0 and arrows &amp;gt;= apeach[i]+1: ryan[i] = apeach[i]+1 shoot(i+1, arrows-ryan[i], ryan, apeach) ryan[i] = 0 shoot(i+1, arrows, ryan, apeach)def solution(n, info): i, ryan = 0, [0 for _ in info] shoot(i, n, ryan, info) return sorted(answer)[-1][::-1] if answer else [-1] # 7풀이1, info의 갯수 만큼(그래봐야 11개지만) 라이언을 위한 점수판을 마련한다.def solution(n, info): i, ryan = 0, [0] * len(info) # 12, 음…일단 한번 무지성으로 가지고 있는 화살을 큰 점수부터 화살을 다 쓸 때까지 한 발씩 점수별로 쏴보자.여기서 shoot 함수의 base condition(함수의 탈출조건)은 과녁이 0점까지 도달했을 때(인덱스가 마지막일 때)와 화살이 다 떨어졌을 때이다.def shoot(i, arrows, ryan, apeach): if i == len(ryan)-1 or arrows == 0: return shoot(i+1, arrows-1, ryan, apeach)def solution(n, info): i, ryan = 0, [0 for _ in info] shoot(i, n, ryan, info) # 23, 쏘는 건 구현했으니 좀 더 현명하게 쏠지 말지를 결정하면서 쏴보자.갖고 있는 화살이 0개 보다 많고, 어피치가 쏜 화살보다 1개 이상 많으면 쏜다.쏘고 나니 마음에 안드는 경우 방금 쏜 화살을 다시 회수(ryan[i] = 0)하고 해당 과녁은 지나간다.def shoot(i, arrows, ryan, apeach): if i == len(ryan)-1 or arrows == 0: return # 과녁을 향해 쏘세요! if arrows &amp;gt; 0 and arrows &amp;gt;= apeach[i]+1: # 3 ryan[i] = apeach[i]+1 shoot(i+1, arrows-(apeach[i]+1), ryan, apeach) ryan[i] = 0 # 안 쏘거나 위에서 못 쐈을 때 이 과녁은 그냥 지나간다. shoot(i+1, arrows, ryan, apeach)def solution(n, info): i, ryan = 0, [0 for _ in info] shoot(i, n, ryan, info)4, 점수판(ryan_board)을 찍어보자. 어 그런데 점수판 목록을 보니 뭔가가 이상하다....[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]...쏴도 되고 안 쏴도 된다고 하니까 화살 10개를 줬는데도 한 번도 안 쏘고 10개를 계속 가지고 있다. 아직은 쏠 때가 아니라나 뭐라나…뺏어서 지금 과녁에 남은 화살 다 쏴버렸다.def shoot(i, arrows, ryan, apeach): if i == len(ryan)-1 or arrows == 0: ryan_board = [_ for _ in ryan] ryan_board[i] += arrows # 4 return if arrows &amp;gt; 0 and arrows &amp;gt;= apeach[i]+1: ryan[i] = apeach[i]+1 shoot(i+1, arrows-(apeach[i]+1), ryan, apeach) ryan[i] = 0 shoot(i+1, arrows, ryan, apeach)def solution(n, info): i, ryan = 0, [0 for _ in info] shoot(i, n, ryan, info)5, 이제 점수 계산을 하기 위해 점수판을 두 개를 넣어주면 점수차를 반환하는 함수를 구현하고 점수차를 구해보자.SCORE_TABLE = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]def get_score(ryan, apeach): score = 0 for i in range(len(ryan)): if ryan[i] &amp;gt; apeach[i]: score += SCORE_TABLE[i] elif ryan[i] &amp;lt; apeach[i]: score -= SCORE_TABLE[i] return scoredef shoot(i, arrows, ryan, apeach): if i == len(ryan)-1 or arrows == 0: ryan_board = [_ for _ in ryan] ryan_board[i] += arrows score = get_score(ryan_board, apeach) # 5 return if arrows &amp;gt; 0 and arrows &amp;gt;= apeach[i]+1: ryan[i] = apeach[i]+1 shoot(i+1, arrows-(apeach[i]+1), ryan, apeach) ryan[i] = 0 shoot(i+1, arrows, ryan, apeach)def solution(n, info): i, ryan = 0, [0 for _ in info] shoot(i, n, ryan, info)6, 최고 점수를 갱신한 점수판들만 정답리스트에 모아 넣는다.체크하는 기준은 아래와 같다.(최고점수의 초기값은 0) 점수가 0보다 크면서(유의미한 점수) 점수가 최고점수와 같은가? 정답 리스트에 똑같이 넣어주면 된다. 최고점수보다 높은가? 정답 리스트를 다시 만들고 거기에 지금 점수판을 넣어준다. SCORE_TABLE = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]answer = []max_score = 0def get_score(ryan, apeach): score = 0 for i in range(len(ryan)): if ryan[i] &amp;gt; apeach[i]: score += SCORE_TABLE[i] elif ryan[i] &amp;lt; apeach[i]: score -= SCORE_TABLE[i] return scoredef shoot(i, arrows, ryan, apeach): global max_score if i == len(ryan)-1 or arrows == 0: ryan_board = [_ for _ in ryan] ryan_board[i] += arrows score = get_score(ryan_board, apeach) if 0 &amp;lt; score and score == max_score: # 6 answer.append(ryan_board) elif score &amp;gt; max_score: max_score = score answer.clear() answer.append(ryan_board) return if arrows &amp;gt; 0 and arrows &amp;gt;= apeach[i]+1: ryan[i] = apeach[i]+1 shoot(i+1, arrows-ryan[i], ryan, apeach) ryan[i] = 0 shoot(i+1, arrows, ryan, apeach)def solution(n, info): i, ryan = 0, [0 for _ in info] shoot(i, n, ryan, info)7, 마지막으로 정답리스트 중에 가장 적은 과녁에 많이 맞힌 점수판을 골라 반환한다.이를 위해 정답 리스트에 값을 넣을 때 점수판 배열을 뒤집어서 넣어주는 걸로 수정하고([::-1] 연산) 정답을 반환할 때 정답리스트를 정렬한 뒤 가장 마지막에 위치한 점수판을 다시 원래대로 뒤집어서 반환한다.뒤집은 점수판은 앞에서부터(0점 과녁부터) 숫자가 적은 순서대로 정렬될 것이고, 그 말은 정렬되고 난 뒤집힌 점수판 중에 가장 뒤에 위치하는 녀석들은 앞에서부터 숫자가 큰 녀석들만 들어간 상태로 배치된다는 것이다.SCORE_TABLE = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]answer = []max_score = 0def get_score(ryan, apeach): score = 0 for i in range(len(ryan)): if ryan[i] &amp;gt; apeach[i]: score += SCORE_TABLE[i] elif ryan[i] &amp;lt; apeach[i]: score -= SCORE_TABLE[i] return scoredef shoot(i, arrows, ryan, apeach): global max_score if i == len(ryan)-1 or arrows == 0: ryan_board = [_ for _ in ryan] ryan_board[i] += arrows score = get_score(ryan_board, apeach) if 0 &amp;lt; score and score == max_score: answer.append(ryan_board[::-1]) # 7 elif score &amp;gt; max_score: max_score = score answer.clear() answer.append(ryan_board[::-1]) # 7 return if arrows &amp;gt; 0 and arrows &amp;gt;= apeach[i]+1: ryan[i] = apeach[i]+1 shoot(i+1, arrows-ryan[i], ryan, apeach) ryan[i] = 0 shoot(i+1, arrows, ryan, apeach)def solution(n, info): i, ryan = 0, [0 for _ in info] shoot(i, n, ryan, info) return sorted(answer)[-1][::-1] if answer else [-1] # 7Legacy지난 풀이. 과거의 생각.다 풀었는데 자꾸 테스트 케이스 8번과 18번이 통과가 안되서 삽질을 엄청 했다.처음 내가 푼 방식은 백트래킹의 기본형으로 남은 화살의 개수가 0개가 될 때까지 체크하다가 0개가 되면 둘의 점수차를 비교하고 유효하면 정답 리스트에 넣는 방식이었다.문제의 조건에는 이런게 있었다....- 라이언이 가장 큰 점수 차이로 우승할 수 있는 방법이 여러 가지 일 경우, 가장 낮은 점수를 더 많이 맞힌 경우를 return 해주세요. - 예를 들어, [2,3,1,0,0,0,0,1,3,0,0]과 [2,1,0,2,0,0,0,2,3,0,0]를 비교하면 [2,1,0,2,0,0,0,2,3,0,0]를 return 해야 합니다....혹시나 해서 두 리스트를 새로운 리스트에 넣고 sort()를 하니 원하는 대로 [2,1,0,2,0,0,0,2,3,0,0]가 가장 앞으로 왔다.ㅎㅎ 이거네 개꿀근데 자꾸만 테스트케이스 8번과 18번에서만 걸려서 하루종일 삽질을 하다가 이상하다 싶어서 문제를 다시 읽어보았다. ... - 다른 예로, [0,0,2,3,4,1,0,0,0,0,0]과 [9,0,0,0,0,0,0,0,1,0,0]를 비교하면 [9,0,0,0,0,0,0,0,1,0,0]를 return 해야 합니다. ...dk..sort()를 해버리면 단순히 숫자의 높고 낮음으로 정렬하기에 위의 상황에서 [0,0,2,3,4,1,0,0,0,0,0]을 반환한다. 그래서 결국 pick_one()이라는 함수를 구현하여 더 적은 점수를 많이 맞춘 정답을 뽑도록 하였다.그렇게 완성된게 이 풀이score_table = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]max_score = 0def pick_one(answer): result = [] for i in range(10, -1, -1): most_hit, count = 0, 0 for ans in answer: if ans[i] &amp;gt; most_hit: most_hit, result = ans[i], ans count += 1 if count == 1: return result return [-1]def get_score(apeach, lion): score = 0 for i in range(len(apeach)): if apeach[i] &amp;gt; lion[i]: score -= score_table[i] elif apeach[i] &amp;lt; lion[i]: score += score_table[i] return scoredef helper(n, apeach, lion, answer, visited): global max_score if n == 0: score = get_score(apeach, lion) if score &amp;lt;= 0: return elif score == max_score: answer.append([_ for _ in lion]) elif score &amp;gt; max_score: answer.clear() answer.append([_ for _ in lion]) max_score = score return elif n &amp;gt; 0: for i in range(len(lion)): if not visited[i]: visited[i] = True lion[i] = n if i == len(lion)-1 else apeach[i]+1 helper(n - lion[i], apeach, lion, answer, visited) lion[i] = 0 visited[i] = Falsedef solution(n, info): answer, lion, visited = [], [0 for _ in info], [False for _ in info] helper(n, info, lion, answer, visited) return pick_one(answer)수행시간 편차가 엄청 크다근데 이상하게 수행시간도 엄청 길고 answer에도 같은 값이 6개씩 들어가 있고 뭔가 구현이 이상한 것 같아 결국 인터넷에서 다른 사람의 풀이를 참고해서 index를 늘려가며 탐색하는 방식으로 다시 풀었다.score_table = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]max_score = 0def pick_one(answer): result = [] for i in range(10, -1, -1): most_hit, count = 0, 0 for ans in answer: if ans[i] &amp;gt; most_hit: most_hit, result = ans[i], ans count += 1 if count == 1: return result return [-1]def get_score(apeach, ryan): score = 0 for i in range(len(apeach)): if apeach[i] &amp;gt; ryan[i]: score -= score_table[i] elif apeach[i] &amp;lt; ryan[i]: score += score_table[i] return scoredef helper(index, arrows, apeach, ryan, answer): global max_score if index == len(ryan)-1 or arrows == 0: # 1-1 ryan[index] += arrows score = get_score(apeach, ryan) # 1-2 if 0 &amp;lt; score and score == max_score: # 1-3 answer.append([r for r in ryan]) elif score &amp;gt; max_score: # 1-4 answer.clear() answer.append([r for r in ryan]) max_score = score ryan[index] = 0 # 1-5 return if arrows - (apeach[index]+1) &amp;gt;= 0: # 2 ryan[index] = apeach[index]+1 helper(index+1, arrows-ryan[index], apeach, ryan, answer) ryan[index] = 0 helper(index+1, arrows, apeach, ryan, answer) # 3def solution(n, info): answer, ryan = [], [0 for _ in info] helper(0, n, info, ryan, answer) return pick_one(answer) 0~10까지 인덱스를 가지고 재귀를 돈다. base condition(탈출 조건)은 index가 배열의 끝에 도달했을 때 또는 가지고 있는 화살을 다 쏘았을 때이다. 마지막 인덱스(0점 과녁)인데도 화살이 남아있을 경우 다 쏜다. 어피치와 라이언의 점수차를 구한다. 이긴 경우만(0점 초과) 고려하고 점수가 최고 점수와 같다면 원래 있던 정답 리스트에 현재까지 쏜 화살의 기록을 적는다. 방금 라이언이 쏜 화살들이 최고점 보다 더 높다면 정답 리스트를 초기화 하고 현재까지 쏜 화살의 기록을 적는다. 1번에서 쏜 화살들을 전부 도르마무 초기화 하고 함수를 끝낸다. 어피치가 쏜 화살보다 1개 더 쏠 수 있을 경우 쏘고(재귀함수 호출) 다시 돌아왔을 때 방금 쏜 화살을 초기화한다. 안 쏘고 넘어간다.(인덱스만 +1)" }, { "title": "2022 KAKAO BLIND RECRUITMENT 주차 요금 계산", "url": "/posts/kakao-parking-fee/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2022, 카카오, 블라인드", "date": "2022-01-17 12:35:00 +0900", "snippet": "Note 문제에 적혀 있는대로 풀면 된다.Solution 입차시간과 출차시간을 계산해서 차량별로 누적시간을 계산해둔다. 입차만 하고 출차를 하지 않은 차량이 남아있으면 이 차량을 23시 59분에 출차한 것으로 요금을 계산한다. 누적시간이 기본요금보다 많으면 기본요금 + 누적시간에 따른 단위요금을 계산하고, 적으면 기본요금만 청구하여 번호순으로 리스트를 만들어 반환한다.import mathfrom collections import defaultdictdef to_minute_time(time): h, m = time.split(&#39;:&#39;) return int(h) * 60 + int(m)def solution(fees, records): answer, park_dic, acc_time_dic = [], dict(), defaultdict(int) for record in records: # 1 time, no, action = record.split() time = to_minute_time(time) if action == &#39;IN&#39;: park_dic[no] = time elif action == &#39;OUT&#39;: acc_time_dic[no] += time - park_dic.pop(no) close_time = 23 * 60 + 59 # 2 for no, time in park_dic.items(): acc_time_dic[no] += close_time - time for no, time in acc_time_dic.items(): # 3 fee = fees[1] if time &amp;gt;= fees[0]: fee += math.ceil((time-fees[0]) / fees[2]) * fees[3] answer.append((no, fee)) return [fee for no, fee in sorted(answer)]Comment알고리즘 코테를 준비하는 사람 중에 이 문제를 못 푸는 사람은 거의 없을 것 같다. 어려운 문제도 아니고 문제에 풀이방법이 아예 써 있으니까다만, 이번 문제의 풀이는 내 성향이자 단점을 잘 드러내는 것 같다. 난 수행시간 보다 코드의 가독성이나 짧은 정도를 더 선호한다.23-29 라인의 풀이가 그런데, 저 과정에서 acc_time을 한 번, answer를 두 번(sorted()에서 한 번, 다시 time만 뽑아내기 위해 한 번) 순회한다.처음엔 힙을 사용해서 리스트에 넣을 때 정렬하면서 넣고 그걸 순서대로 pop하면서 time을 뽑아낸 result를 만들까 생각했는데 그건 코드가 좀 더 투박해질 것 같고, 입출차 한 자동차의 대수가 많지 않다면 수행시간이 크게 차이가 나지 않을 것 같아 저렇게 구현했다.수행시간과 가독성…정말 어렵다." }, { "title": "2022 KAKAO BLIND RECRUITMENT k진수에서 소수 개수 구하기", "url": "/posts/kakao-prime-no/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2022, 카카오, 블라인드, 슬라이딩 윈도우, 투포인터", "date": "2022-01-15 12:15:00 +0900", "snippet": "Updated at 2022-01-29Link https://programmers.co.kr/learn/courses/30/lessons/92335Introduction달라진 풀이 스타일을 적용하여 다시 풀어보았다. 이번에는 종이, 펜 그리고 손가락 두 개를 가지고 시뮬레이션을 한다.슬라이딩 윈도우를 적용한 이 풀이는 Sliding Window에서 다룬 내용을 참고하여 진행한다.Note python에서 % 연산자를 사용해 어떤 숫자를 10으로 나눈 나머지를 구할 때는 소수점이 붙는 경우가 있으므로 주의 (ex) 1 -&amp;gt; 1.0, 0 -&amp;gt; 0.0) Solutionimport mathfrom collections import dequedef convert_no(n, k): nums, quotient = deque(), n while quotient &amp;gt; 0: quotient, remainder = quotient // k, int(quotient % k) nums.appendleft(str(remainder)) return &#39;&#39;.join(nums)def is_prime_no(no): if no &amp;lt; 2: return False offset = int(math.sqrt(no)) + 1 for i in range(2, offset): if no % i == 0: return False return Truedef contain_zero(no): return True if &#39;0&#39; in str(no) else Falsedef solution(n, k): answer = 0 no = convert_no(n, k) left, right = 0, 0 while right &amp;lt; len(no): if no[right] == &#39;0&#39;: cur_no = int(no[left:right]) if is_prime_no(cur_no) and not contain_zero(cur_no): answer += 1 left = right = right + 1 if right == len(no) - 1: # 5 cur_no = int(no[left:]) if is_prime_no(cur_no) and not contain_zero(cur_no): answer += 1 right += 1 return answer풀이1, 어떤 수의 k진수를 구하는 법은 그 수를 k로 나누며 0이 될 때까지 나누고 나머지를 이어주면 된다.ex) 35를 2진수로 표현하는 방법35 —2진수로 변환—&amp;gt; 100011(2)이를 구현한다.from collections import dequedef convert_no(n, k): nums, quotient = deque(), n while quotient &amp;gt; 0: quotient, remainder = quotient // k, int(quotient % k) nums.appendleft(str(remainder)) return &#39;&#39;.join(nums)def solution(n, k): no = convert_no(n, k) # 12, 이렇게 변환된 숫자를 종이에 쓰고 왼쪽 검지와 오른쪽 검지를 숫자 가장 첫 번째 위치(인덱스 0)에 둔다. 우리는 이 오른쪽 손가락을 숫자의 끝자락까지 움직일거다.from collections import dequedef convert_no(n, k): nums, quotient = deque(), n while quotient &amp;gt; 0: quotient, remainder = quotient // k, int(quotient % k) nums.appendleft(str(remainder)) return &#39;&#39;.join(nums)def solution(n, k): no = convert_no(n, k) left, right = 0, 0 while right &amp;lt; len(no): # 2 right += 13, 자 이제 손가락을 움직이면서 손가락 사이의 글자를 체크할 건데, 생각을 해본다. 우리는 언제 숫자를 체크해야 하나? 바로 0과 0 사이에 숫자가 존재할 때이다.즉, 오른쪽 손가락이 0인 지점에 멈췄을 때 손가락 사이의 숫자를 체크하면 된다. (편의상 손가락 사이라는 표현을 했지만 실제로는 왼쪽 손가락이 가리키는 글자까지 포함해서 센다.)from collections import dequedef convert_no(n, k): nums, quotient = deque(), n while quotient &amp;gt; 0: quotient, remainder = quotient // k, int(quotient % k) nums.appendleft(str(remainder)) return &#39;&#39;.join(nums)def solution(n, k): no = convert_no(n, k) left, right = 0, 0 while right &amp;lt; len(no): if no[right] == &#39;0&#39;: # 3 cur_no = int(no[left:right]) right += 14, 문제의 조건에 따르면 숫자는 각 자릿수에 0을 포함하지 않는 소수이다. 소수이며, 0을 포함하지 않는다.3번에서 고른 숫자들을 이 기준에 따라 체크한다. 체크 후에는 양 손가락을 방금 오른쪽 손가락이 있던 바로 다음 위치로 옮겨준다.소수는 1과 자기 자신으로 밖에 나누지 못한다. 즉 1과 자기 자신 이외의 약수를 가지지 않는 수인데, 이 약수를 빠르게 구하는 법을 다 담으면 포스팅이 너무 길어져서 괜찮은 다른 블로그의 링크를 대신한다. (구글에서 약수 찾는 알고리즘 쳐서 제일 위에 나오는 거 링크 걸었다.) [알고리즘] 효율적으로 약수를 찾는 알고리즘 by 욱파카의 괴발개발스포일러 하자면, 그 숫자의 제곱근까지만 약수가 되는지 체크해보면 된다.import mathfrom collections import dequedef convert_no(n, k): nums, quotient = deque(), n while quotient &amp;gt; 0: quotient, remainder = quotient // k, int(quotient % k) nums.appendleft(str(remainder)) return &#39;&#39;.join(nums)def is_prime_no(no): if no &amp;lt; 2: return False offset = int(math.sqrt(no)) + 1 for i in range(2, offset): if no % i == 0: return False return Truedef contain_zero(no): return True if &#39;0&#39; in str(no) else Falsedef solution(n, k): answer = 0 no = convert_no(n, k) left, right = 0, 0 while right &amp;lt; len(no): if no[right] == &#39;0&#39;: cur_no = int(no[left:right]) if is_prime_no(cur_no) and not contain_zero(cur_no): # 4 answer += 1 left = right = right + 1 right += 15, 오른쪽 손가락이 마지막 지점까지 갔을 때 그 숫자가 0이 아니면 마지막 손가락 사이의 소수는 체크가 되지 않는다. 따라서 이 경우에는 현재 왼쪽 손가락 부터 앞에 있는 모든 숫자를 체크해준다.import mathfrom collections import dequedef convert_no(n, k): nums, quotient = deque(), n while quotient &amp;gt; 0: quotient, remainder = quotient // k, int(quotient % k) nums.appendleft(str(remainder)) return &#39;&#39;.join(nums)def is_prime_no(no): if no &amp;lt; 2: return False offset = int(math.sqrt(no)) + 1 for i in range(2, offset): if no % i == 0: return False return Truedef contain_zero(no): return True if &#39;0&#39; in str(no) else Falsedef solution(n, k): answer = 0 no = convert_no(n, k) left, right = 0, 0 while right &amp;lt; len(no): if no[right] == &#39;0&#39;: cur_no = int(no[left:right]) if is_prime_no(cur_no) and not contain_zero(cur_no): answer += 1 left = right = right + 1 if right == len(no) - 1: # 5 cur_no = int(no[left:]) if is_prime_no(cur_no) and not contain_zero(cur_no): answer += 1 right += 1 return answerLegacy지난 풀이. 주어진 수를 n진수로 변환한다. 커서를 두 개 두고 하나를 전진시키면서 커서 사이의 숫자가 소수이면서 0이 포함되어 있지 않다면 정답에 포함시키고 두 커서의 위치를 다음 숫자로 옮긴다. 110011 같이 11을 정답에 포함시킨 후 left, right 커서들의 위치가 index 3인 0에(110011) 위치하는 경우가 있다. 이 때는 커서들을 index 4인 1로(110011) 옮겨준다.import mathfrom collections import dequedef convert_no(n, k): nums, quotient = deque(), n while quotient &amp;gt; 0: quotient, remainder = quotient // k, int(quotient % k) nums.appendleft(str(remainder)) return &#39;&#39;.join(nums)def is_prime_no(no): if no &amp;lt; 2: return False offset = math.floor(math.sqrt(no)) + 1 for i in range(2, offset): if no % i == 0: return False return Truedef contain_zero(no): return True if &#39;0&#39; in str(no) else Falsedef solution(n, k): answer, left, right = [], 0, 0 no = convert_no(n, k) while right &amp;lt; len(no): if no[right] == &#39;0&#39;: if left == right: left = right = right+1 else: cur_no = int(no[left:right]) if is_prime_no(cur_no) and not contain_zero(cur_no): answer.append(cur_no) left = right+1 elif right == len(no)-1: cur_no = int(no[left:]) if is_prime_no(cur_no) and not contain_zero(cur_no): answer.append(cur_no) right += 1 return len(answer)Comment코테에 시간제한이 있어야 변별력이 있겠지만 없었으면 좋겠다. 난 같은 코드를 진득하니 보면서 계속 깔끔하게 다듬어나가는 걸 좋아하는데 시간제한이 있으면 너무 허겁지겁 푸느라 가독성이 개판이 되어버린다.아직 실력이 부족해서 한 번에 깔끔한 코드를 못 짜서 그런거겠지?2022-01-29 내용 추가달라진 문제 풀이 스타일 덕분에 이 문제가 어느정도 해결될 것 같은 조짐이 보인다. 뭔가 희망이 생겼다." }, { "title": "2021년을 보내며", "url": "/posts/rushrushrush/", "categories": "회고록", "tags": "", "date": "2021-12-31 17:20:00 +0900", "snippet": "속도에 중독되다오토바이나 자전거로 빠르게 질주할 때 사람의 시선은 전방으로 고정되며 양옆의 시야는 흐려진다. 온 신경은 눈앞과 뺨을 가르는 바람 소리, 그리고 긴장감에 꽉 깨문 어금니로 인해 어느 샌가부터 아파지는 관자놀이에 집중된다. 바쁜 사람들을 묘사하는데 자주 사용되는 이 상황은 올해의 나를 완벽하게 표현하고 있었다.활동적인 성향이었던 나는 일을 할 때도 언제나 완급조절을 못 하며 움직이지 못할 상황이 올 때까지 자신을 학대하는 것 처럼 몰아세웠고 계획보다 일이 빠르게 처리되면 그 시간에 새로운 일을 채워 넣었다. 공백을 참을 수 없었고, 개발하고 있을 때 내가 개발자로서 존재한다고 느꼈다.꽉 차 있는 그릇에 무엇을 더 담을 수 있을까? 머릿속에 일밖에 없었던 나는 다른 모든 것에 대해 점점 흥미를 잃게 됐고, 관심이 없었던 건지 옆을 돌아볼 엄두가 안 났던 건지, 그렇게 더 멍청해지기 시작했다.무언가에 몰두하고 있으면 그 일이 너무 재밌어서 멈추기 힘든 순간이 온다. 특히나 그 일이 가치 있다고 생각하는 일이고 내가 그것에 시간을 쏟는 것이 정당하다고 느껴질 때는 더더욱 그렇다. 도박 중독이나 마약, 그런 것들도 아니고 일을 하고 배워나가며 스스로가 나아지는 방향으로 걷고 있는 건데, 뭐…잘못될 게 있겠어?하지만, 무언가가 잘못되고 있다는 것을 깨달았을 때는 보통 조금 늦은 경우가 많다. 소중한 인연을 잃었고, 아이러니하게도 기억력과 표현력, 사고력이 감퇴하고 있었다.성장부채기업에서는 흔히 기술부채라는 표현을 사용한다.기술부채현 시점에서 더 오래 소요될 수 있는더 나은 접근방식을 사용하는 대신쉬운(제한된) 솔루션을 채택함으로써발생되는 추가적인 재작업의 비용을 반영하는소프트웨어 개발의 한 관점이다.- Wikipedia -쉽게 말해 당장의 중요도에 따라 빠르게 무언가를 해결하고 나중에 보강한다는 뜻이다.주니어 개발자인 나는 이것을 나의 개발적 성장에 적극적으로 도입했다. 일상생활 보다도 성장을 위해 필요한 노력을 더 중요시하고 달려만 갔다. 일이 끝나고 집에 가면 공부, 주말도 공부, 지하철 이동 시에도 책을 읽고, 학교 수업과 동시에 진행하며 스터디에 공모전까지, 공백을 참지 못하고 그렇게 빚을 늘려만 갔다.빚의 특성은 이자로 인해 시간이 지날수록 갚아야 하는 양이 늘어난다는 것이다. 제때 잘 쉬어주면 조금이면 해결되었을 것을 나중에 몰아쉴 때는 2~3배 더 긴 시간이 필요했다. 일을 그만두자마자 번아웃이 찾아왔고, 이전보다 무겁게 느껴진 키보드와 희미해진 감각들을 되찾는데는 정말 많은 시간이 필요했다.달리는 물체는 관성이 있어서 더 빠른 속도로 달릴수록 방향을 쉽게 바꾸지 못하고 부딪혔을 때의 대미지가 크다. 나는 부딪히고 난 뒤에야 멈출 수 있었고, 후유증으로 긴 시간을 어찌해야 할지 모른 채 허공에 손을 가르는 시간을 반복했다.올 한 해 개발 외적으로 내가 배운 것이 있다면, 성장 부채를 조절하는 것에 대한 중요성이다. 개발을 1~2년 하고 말 것이 아니었기에 무리하지 않는 것이 중요하다는 것을 깨달았다.아니 난 괜찮을 줄 알았지…물론 당시에는 너무 빠른 속도로 달리고 있어서 주변에서 좀 쉬어야 한다는 말이 잘 들리지 않았고 이해가 안 됐지만.개발자로서 첫 걸음힘들었지만 그만큼 남은 것도 많았다. 책으로만 배우던 것들이 왜 필요한지를 몸소 경험했다. 경험하고 난 뒤에 다시 읽어보는 개발 이론들은 이전보다 더 쉽게 공감이 가고 단순 암기가 아니라 체화될 수 있었다.기획이 확정되지 않은 채 개발을 먼저 시작했기에 다음에 수정사항이 생길 때마다 코드를 엎었고(이건 클로즈 알파 대응 때 특히 더 심각했다.), 사용하던 게임패드 인풋 캡처 라이브러리에 버그가 생겨 다른 라이브러리로 변경하면서 달라진 이벤트 처리 방식과 키코드의 수정 때문에 고통받았다.너희는 더 유연해야 한다변경되는 부분과 변경되지 않는 부분을 나누고 필요한 때에 필요한 기능이 구현된 구현체를 주입받는 설계가 왜 중요한지를 알게 되었다. 이때부터 변경에 강한 설계의 중요성에 대해 인식하게 되었다.스스로에 대한 자기효능감이 굉장히 높아졌던 한 해 였던 것 같다. 생각했던대로 개발을 할 수 있었고, 예상했던대로 움직이는 클라이언트 어플리케이션을 보면서 스스로가 굉장히 개발을 잘하는 것만 같은 착각에 빠지는 것 같았다. 주니어 시기에 위축된 자신감을 회복하는데에는 큰 도움이 됐고, 그 기저에는 훌륭한 라이브러리들과 프레임워크가 도와주고 있었다.바퀴를 다시 발명하지 마라회사에서는 이것 저것 개발을 했지만 그 중에서도 많은 것을 고민해보게 했던 프로젝트는 윈도우와 안드로이드로 이미 구현되어 있는 클라이언트 프로그램/앱을 웹으로 포팅하는 일이었다.클로즈 알파 당시에 회사에서 사용하는 클라이언트 앱은 C++(Windows), Java(Android)로 구현이 되어있었고, 유저의 PC나 핸드폰에 설치해서 테스트 해봐야 했다. 당연히 유저들이 테스트를 해보고 있는 동안에는 버그 패치 등의 업데이트가 있어도 바로 반영할 수 없었고, 추후에 서버 쪽에 변경사항이 있어서 버전이 달라졌을 때 각각에 대응하는 클라이언트를 찾아 사용하는데에 번거로움이 있었다.지긋지긋한 업데이트물론 이를 해결하기 위해 웹 클라이언트가 도입된 것은 아니고 처음엔 하나의 옵션으로서 개발을 하게 됐는데(아무래도 네이티브 앱에 비해 성능이 매우 낮아 못 써먹을 것이라 예상했었다), 굉장히 만족스러운 결과물이 나왔다.웹 클라이언트가 가져다 주는 이점은 다음과 같았다. 유저가 앱을 설치하지 않아도 되기에 테스트 시에 클라이언트의 버전을 신경쓰지 않아도 된다. 전자기기를 사용하는 현대인 중에 웹 브라우저를 가지고 있지 않은 사람은 없다. 이 프로그램은 인터넷 사용을 위해 필수적이기도 하지만 보안성을 위해 개발자가 유저의 기기에 접근하는 것이 제한되어 있어 안심하고 설치할 수 있었기 때문이다. 따라서, 누구나 이 클라이언트를 즉시 간단하게 실행할 수 있다. 플랫폼을 따지지 않는다. 크롬과 사파리를 실행할 수 있다면 그 기기가 윈도우 컴퓨터든 안드로이드 폰이든 맥북이든 상관없이 사용할 수 있었다. 기존에 지원하지 않았던 맥OS도 지원할 수 있게 되어 맥을 사용하던 웹 개발자들도 기능 테스트를 할 수 있게 되었다. (기존에는 윈도우 컴퓨터를 따로 켜서 거기에서만 테스트 해야 했다) 위의 장점들을 모두 적용할 수 있음에도 이를 웹으로 포팅하는데는 혼자서 개발했는데도 약 3개월 정도밖에 시간이 걸리지 않았다.(내가 C++ 코드에 익숙하지 않고, Web API를 잘 몰랐음에도 말이다!) 그 만큼 Web API는 내가 생각했던 것 이상의 기능들이 구현되어 있었고, 이는 굉장히 사용하기 편하고 합리적으로 구현되어 있었다.가장 우려했었던 것은 Javascript의 느린 처리 속도였는데, Web API에서 I/O 처리는 어차피 네이티브 코드로 구현되어 있을터라 그런지 윈도우 클라이언트와의 체감속도에 있어서 큰 차이는 없었다.하지만 마냥 순조롭지만은 않았다. iOS 한정으로(MacOS는 괜찮았음) Web RTC(웹 기술로 구현된 실시간 통신 프레임워크; 동영상, 음성, 일반 데이터 통신이 가능)를 이용하여 받아온 서버쪽 영상을 자동재생 할 때는 보안상의 이유로 muted가 강제되는데, 이는 User Interaction을 통해서만 풀 수 있다.그래서 고민하던 중 어차피 앱을 사용하는데 있어서 매핑된 버튼의 UI가 화면에 뜨고 이를 터치하는 방식으로 사용하기 때문에 어디든 화면을 한 번 터치하면 이 이벤트를 받아서 muted가 되어 있을 때는 해제하는 방식으로 해결했고, 개발을 하는 것이 단순히 정해진 기능을 구현하는 것이 아니라 상황에 따른 제한사항을 어떻게 창의적으로 풀어나가야 하는 것인지도 고민해야 한다는 것을 배웠다.이 프로젝트를 하면서 나는 Javascript에 대한 편견 그리고 프론트 엔드 개발자가 만드는 것이 단순히 CRUD 결과를 좀 더 예쁘게 표시하는 웹 페이지일 것이라는 편견을 완전히 버리고 한동안 웹 브라우저라는 프로그램의 매력에 푹 빠졌었다.어떤 개발자이고 싶은가?나는 웹 백엔드 개발자로서 커리어를 닦아나가고 싶었다. 다만, 그렇기에는 이것 저것 다 손대서 애매한 상황이었고, 경력 1년을 가진 백엔드 개발자치고는 깊이가 없었다.따로 공부는 하고 있었지만 어디까지나 우선순위는 월급을 주는 회사에서 부여하는 일을 처리하는데에 있었고, 앞서 말한 것처럼 헤비한 생활에 지쳐 있는 상태에서 학습을 하려고 돌아오면 이전에 배웠던 것이 기억이 안나는 상황이 반복되고 있었다.많은 시니어 개발자들이 개발 지식에만 집중하는 것이 아니라 개발을 통해 문제를 해결하고 비즈니스 밸류를 만들어 내야 한다고 한다. 하지만 이것을 적용하기에 나는 아직 스타트라인에도 못 서있는 것 같은 기분이 들었다.아직 나에겐 최소한의 개발 지식과 경험이 더 필요했다. 그래서 퇴사의사를 밝히고 더 많이 배울 수 있는 곳으로 가기 위해 이직 준비를 하기로 결심했다.이제는 같은 실수를 반복하지 않기로 했다. 느리더라도 상관없다. 멈추지만 않으면 된다. 조급해 할 필요도 없고, 원래 페이스 이상으로 달려봐야 결국 나중에는 다 대가를 치룬다. 어차피 모든 일은 충분한 시간과 노력이 필요하다." }, { "title": "2018 KAKAO BLIND RECRUITMENT [1차] 셔틀버스", "url": "/posts/shuttle-bus/", "categories": "알고리즘, 프로그래머스", "tags": "알고리즘, 프로그래머스, 2018, 카카오, 셔틀버스, 큐", "date": "2021-12-29 21:25:00 +0900", "snippet": "Updated at 2022-01-29Link https://programmers.co.kr/learn/courses/30/lessons/17678Introduction작년(2021년)에 포스팅 한 문제이긴 하지만 다시 봤을 때 한 눈에 안 들어와서 다시 풀어보기로 했다. 한 달 정도 지났지만 풀어나가는 스타일이 조금 바뀌기도 했고, 모든 코드에 스토리를 넣는 방식으로 풀어나가는 거라 이번에는 좀 더 시간이 지나고 봤을 때도 납득이 갈만한 풀이를 작성했다.기본 틀은 똑같다. 버스가 지나가고 사람들은 줄을 서고, 막차 자리가 한 자리 남았을 때 콘을 새치기 시킨다. 이 스토리를 코드로 풀어나간다.Note 큐를 사용해서 풀 수 있는 문제이다. timetable이 정렬되어 있지 않은 점에 주의 시간 비교의 편의를 위해 모든 시간은 분 단위로 바꾸어 비교한다.Solutionfrom collections import dequedef get_minute(time): h, m = time.split(&#39;:&#39;) return 60 * int(h) + int(m)def add_leading_zero(no): return str(no) if no &amp;gt; 9 else f&#39;0{no}&#39;def format_time(time): h, m = time // 60, time % 60 return f&#39;{add_leading_zero(h)}:{add_leading_zero(m)}&#39;def solution(n, t, m, timetable): i, dept_time, queue = 0, 9 * 60, deque() timetable.sort() while n &amp;gt; 0: while i &amp;lt; len(timetable): queued_time = get_minute(timetable[i]) if queued_time &amp;gt; dept_time: break queue.append(queued_time) i += 1 seats = m while seats &amp;gt; 0 and queue: queued_time = queue.popleft() if n == 1 and seats == 1: return format_time(queued_time - 1) seats -= 1 dept_time += t n -= 1 dept_time -= t return format_time(dept_time)풀이1, n개의 버스가 정류장에 도착하고 떠나는 것을 구현한다. 이 버스들은 9시(540분)에 처음으로 출발하여 t분 간격으로 정류장에 도착하고 떠난다. 마지막엔 막차 시간을 반환한다.from collections import dequedef add_leading_zero(no): return str(no) if no &amp;gt; 9 else f&#39;0{no}&#39;def format_time(time): h, m = time // 60, time % 60 return f&#39;{add_leading_zero(h)}:{add_leading_zero(m)}&#39;def solution(n, t, m, timetable): dept_time = 9 * 60 while n &amp;gt; 0: # 1 dept_time += t n -= 1 dept_time -= t return format_time(dept_time)2, 이제 이 버스를 타기 위해 줄을 서고 있는 크루들이 있는 정류장을 구현해보자. 버스가 출발하는 시간 전까지 정류장에 도착한 크루들은 모두 정류장에 줄 세운다.(deque에 집어넣는다.)from collections import dequedef get_minute(time): h, m = time.split(&#39;:&#39;) return 60 * int(h) + int(m)def add_leading_zero(no): return str(no) if no &amp;gt; 9 else f&#39;0{no}&#39;def format_time(time): h, m = time // 60, time % 60 return f&#39;{add_leading_zero(h)}:{add_leading_zero(m)}&#39;def solution(n, t, m, timetable): i, dept_time, queue = 0, 9 * 60, deque() timetable.sort() while n &amp;gt; 0: while i &amp;lt; len(timetable): # 2 queued_time = get_minute(timetable[i]) if queued_time &amp;gt; dept_time: break queue.append(queued_time) i += 1 dept_time += t n -= 1 dept_time -= t return format_time(dept_time)3, 줄은 세웠으니, 버스에 태우는 것을 구현한다. 좌석이 더 이상 없거나 정류장 줄에 더 이상 사람이 없을 때까지 버스에 태운다.from collections import dequedef get_minute(time): h, m = time.split(&#39;:&#39;) return 60 * int(h) + int(m)def add_leading_zero(no): return str(no) if no &amp;gt; 9 else f&#39;0{no}&#39;def format_time(time): h, m = time // 60, time % 60 return f&#39;{add_leading_zero(h)}:{add_leading_zero(m)}&#39;def solution(n, t, m, timetable): i, dept_time, queue = 0, 9 * 60, deque() timetable.sort() while n &amp;gt; 0: while i &amp;lt; len(timetable): queued_time = get_minute(timetable[i]) if queued_time &amp;gt; dept_time: break queue.append(queued_time) i += 1 seats = m while seats &amp;gt; 0 and queue: # 3 queued_time = queue.popleft() seats -= 1 dept_time += t n -= 1 dept_time -= t return format_time(dept_time)4, 문제는 콘 보다 더 부지런한 크루가 마지막 좌석에 탔을 때 벌어진다.여기서 콘은 고민한다. 자신이 버스에 가장 마지막으로 탈 수 있는 타이밍은 언제일까? 바로 버스가 막차(n == 1)이고, 자리가 딱 한 자리 남았을 때 그 마지막 좌석에 앉으려는 사람보다 1분 더 일찍 줄을 서면 된다.from collections import dequedef get_minute(time): h, m = time.split(&#39;:&#39;) return 60 * int(h) + int(m)def add_leading_zero(no): return str(no) if no &amp;gt; 9 else f&#39;0{no}&#39;def format_time(time): h, m = time // 60, time % 60 return f&#39;{add_leading_zero(h)}:{add_leading_zero(m)}&#39;def solution(n, t, m, timetable): i, dept_time, queue = 0, 9 * 60, deque() timetable.sort() while n &amp;gt; 0: while i &amp;lt; len(timetable): queued_time = get_minute(timetable[i]) if queued_time &amp;gt; dept_time: break queue.append(queued_time) i += 1 seats = m while seats &amp;gt; 0 and queue: queued_time = queue.popleft() if n == 1 and seats == 1: # 4 return format_time(queued_time - 1) seats -= 1 dept_time += t n -= 1 dept_time -= t return format_time(dept_time)Legacy지난 풀이. (코드는 더 간결한듯 보이지만 뭔가 시간이 지나고 다시 봤을 때 기억이 잘 안날정도로 와닿지가 않았다.) 크루들을 정류장 도착 시간 순으로 정렬하여 큐에 넣는다. 버스의 대수만큼 현재 시간을 t씩 계속 증가시키면서 정류장에 더 올 사람이 있는지 체크하고 없는데 자리가 남으면 콘을 태우고 버스에 탄 시간을 반환한다. 큐의 맨 앞에 있는 사람이 정류장에 도착하는 시간이 버스보다 느리면 해당 버스를 그냥 보낸다. 큐에 있는 사람들을 버스에 계속 태우다가 마지막 한 자리가 남았다면 콘을 태우기 위해 현재 정류장의 가장 앞에 있는 사람보다 1분 빠르게 콘이 도착하게 하도록 하고 그 시간을 반환한다. 마지막 버스가 떠나기 전에 정류장에 사람이 기다리고 있다면 그 사람들보다 1분 빠르게 도착하게 한 뒤 그 시간을 반환하고, 마지막 버스가 도착했을 때 정류장에 사람이 없다면 마지막 버스가 떠나는 시간을 반환한다.from collections import dequedef get_second(time): t = time.split(&#39;:&#39;) return 60 * int(t[0]) + int(t[1])def add_leading_zero(no): return f&#39;{no}&#39; if no &amp;gt;= 10 else f&#39;0{no}&#39;def format_time(time): h = time // 60 m = time % 60 return f&#39;{add_leading_zero(h)}:{add_leading_zero(m)}&#39;def solution(n, t, m, timetable): queue = deque(sorted(timetable)) now = 9 * 60 - t for i in range(n): now += t seats = m left_buses = n-i while seats &amp;gt; 0: if queue: current = get_second(queue.popleft()) else: return format_time(now) if now &amp;lt; current: queue.appendleft(format_time(current)) break left_seats = (left_buses-1) * m + seats if left_seats == 1: return format_time(current-1) seats -= 1 if queue: now = min(now, get_second(queue[0])-1) return format_time(now)Comment어려운 문제는 아닌데 문제가 길어서 풀기 전에 계속 멍 때렸다. 이러니까 시간 제한 있는 코딩테스트에서 맨날 시간 부족해서 못 풀지Level 3 치고는 쉽다. 2018년도 문제인데, 확실히 코딩 테스트는 해를 거듭할 수록 어려워지는 듯" }, { "title": "Chirpy 테마 삽질기", "url": "/posts/chirpy-test/", "categories": "잡담", "tags": "jekyll, chirpy", "date": "2021-12-22 16:25:00 +0900", "snippet": "Chirpy 테마 자체는 정말 깔끔하고 좋은데, 내가 난독증이 있는건지 README.md를 읽어도 이해가 안되서 일단 그냥 막 해보다가 삽질을 엄청 많이 했다. 배포하는 브랜치를 gh-pages에서 master로 바꿨더니 아래와 같이 빌드가 제대로 안된 화면이 나왔다. jekyll 블로그가 빌드가 제대로 안되었거나, 무언가 충돌이 일어난 것 같다. 이래서 빌드하는 파일을 다른 브랜치로 하고 그 브랜치로 서빙하는 것이 안전하다고 readme에 적혀 있나보다. (처음에는 이게 무슨말인지 이해를 못했음) 카테고리랑 태그 써놓은 부분이 갱신이 안되길래 검색을 하다보니 이런 글을 발견했다. https://github.com/cotes2020/jekyll-theme-chirpy/issues/70 처음에 init.sh를 실행해준 것 같은데 아마 위에서 master 브랜치로 뭔가 잘못하다가 다시 날리고 만들 때 init.sh 실행하는 걸 깜빡해서 일어난 일인 것 같다. 위의 이슈 댓글처럼 글을 작성할 때마다 init.sh를 실행할 필요는 없고, 처음 블로그를 만들 때 한 번만 실행하면 되는 것 같다. 아직은 좀 익숙하지 않은 블로깅이지만, 조금씩 나아지겠지………..?" }, { "title": "게시글 테스트", "url": "/posts/posting-test/", "categories": "잡담", "tags": "깔끔한, 깃허브 블로그, 테마, 이제 진짜 이걸로 결정", "date": "2021-12-22 16:20:00 +0900", "snippet": "진짜 깔끔한 깃허브 블로그 테마를 추천 받았다!기존에 쓰던 깃허브 블로그 테마는 어떤 건 버그가 있고, 어떤건 또 카테고리별로 보기 좋게 분류가 안되고 그래서 쓰다말다 하고 있었는데 이거다 싶은 테마를 하나 추천받아서 적용해 보았는데 기능이 적절하게 적절한 위치에 정확하게 있어서 좋다. 테마를 바꾼김에 모든 게시글 그냥 다 초기화하고 처음부터 시작하려고 함원래는 핸드폰 메모장에 개발 관련된 메모들도 같이 적다가 도저히 분류가 안되고 나중에 찾아볼 때도 너무 힘들어서 언제든 곧바로 찾아볼 수 있고 분류도 잘되는 깃허브 블로그에 정리하도록 결정왜 인지 설정하느라 엄청 고생했다;; 뭐가 잘못됐던거지?카테고리랑 태그가 제대로 안보이고 프로필 설정이 반영이 안된다" } ]
